//#![cfg(feature = "flecs-nightly")]
#![allow(
	dead_code,
	mutable_transmutes,
	non_camel_case_types,
	non_snake_case,
	non_upper_case_globals,
	unused_assignments,
	unused_mut
)]

trait DeprecatedPtrOps {
	fn wrapping_offset_from<T: Sized>(self, origin: *const T) -> isize;
}
impl DeprecatedPtrOps for *const i8 {
	#[inline]
	fn wrapping_offset_from<T: Sized>(self, origin: *const T) -> isize {
		let pointee_size = std::mem::size_of::<T>();
		assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);
		let d = isize::wrapping_sub(self as _, origin as _);
		d.wrapping_div(pointee_size as _)
	}
}
impl DeprecatedPtrOps for *mut libc::c_char {
	#[inline]
	fn wrapping_offset_from<T: Sized>(self, origin: *const T) -> isize {
		let pointee_size = std::mem::size_of::<T>();
		assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);
		let d = isize::wrapping_sub(self as _, origin as _);
		d.wrapping_div(pointee_size as _)
	}
}

extern "C" {
	// #[no_mangle]
	fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
	// #[no_mangle]
	fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> libc::c_int;
	// #[no_mangle]
	fn atol(__nptr: *const libc::c_char) -> libc::c_long;
	// #[no_mangle]
	fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
	// #[no_mangle]
	fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
	// #[no_mangle]
	fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
	// #[no_mangle]
	fn free(__ptr: *mut libc::c_void);
	// #[no_mangle]
	fn abort() -> !;
	// #[no_mangle]
	fn qsort(__base: *mut libc::c_void, __nmemb: size_t, __size: size_t, __compar: __compar_fn_t);
	// #[no_mangle]
	fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
	// #[no_mangle]
	fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
	// #[no_mangle]
	fn memcmp(_: *const libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> libc::c_int;
	// #[no_mangle]
	fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
	// #[no_mangle]
	fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
		-> *mut libc::c_char;
	// #[no_mangle]
	fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
	// #[no_mangle]
	fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
	// #[no_mangle]
	fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
	// #[no_mangle]
	fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
	// #[no_mangle]
	fn strlen(_: *const libc::c_char) -> libc::c_ulong;
	// #[no_mangle]
	static mut stdout: *mut _IO_FILE;
	// #[no_mangle]
	static mut stderr: *mut _IO_FILE;
	// #[no_mangle]
	fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
	// #[no_mangle]
	fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
	// #[no_mangle]
	fn vfprintf(_: *mut FILE, _: *const libc::c_char, _: ::std::ffi::VaList) -> libc::c_int;
	// #[no_mangle]
	fn vsprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ::std::ffi::VaList)
		-> libc::c_int;
	// #[no_mangle]
	fn vsnprintf(
		_: *mut libc::c_char,
		_: libc::c_ulong,
		_: *const libc::c_char,
		_: ::std::ffi::VaList,
	) -> libc::c_int;
	// #[no_mangle]
	fn __ctype_b_loc() -> *mut *const libc::c_ushort;
	// #[no_mangle]
	fn tolower(_: libc::c_int) -> libc::c_int;
	// #[no_mangle]
	fn toupper(_: libc::c_int) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
	pub gp_offset: libc::c_uint,
	pub fp_offset: libc::c_uint,
	pub overflow_arg_area: *mut libc::c_void,
	pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __clockid_t = libc::c_int;
pub type __syscall_slong_t = libc::c_long;
pub type clockid_t = __clockid_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
	pub tv_sec: __time_t,
	pub tv_nsec: __syscall_slong_t,
}
pub type int8_t = libc::c_schar;
pub type int16_t = libc::c_short;
pub type int32_t = libc::c_int;
pub type int64_t = libc::c_long;
pub type __compar_fn_t =
	Option<unsafe extern "C" fn(_: *const libc::c_void, _: *const libc::c_void) -> libc::c_int>;
pub type va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
	pub _flags: libc::c_int,
	pub _IO_read_ptr: *mut libc::c_char,
	pub _IO_read_end: *mut libc::c_char,
	pub _IO_read_base: *mut libc::c_char,
	pub _IO_write_base: *mut libc::c_char,
	pub _IO_write_ptr: *mut libc::c_char,
	pub _IO_write_end: *mut libc::c_char,
	pub _IO_buf_base: *mut libc::c_char,
	pub _IO_buf_end: *mut libc::c_char,
	pub _IO_save_base: *mut libc::c_char,
	pub _IO_backup_base: *mut libc::c_char,
	pub _IO_save_end: *mut libc::c_char,
	pub _markers: *mut _IO_marker,
	pub _chain: *mut _IO_FILE,
	pub _fileno: libc::c_int,
	pub _flags2: libc::c_int,
	pub _old_offset: __off_t,
	pub _cur_column: libc::c_ushort,
	pub _vtable_offset: libc::c_schar,
	pub _shortbuf: [libc::c_char; 1],
	pub _lock: *mut libc::c_void,
	pub _offset: __off64_t,
	pub __pad1: *mut libc::c_void,
	pub __pad2: *mut libc::c_void,
	pub __pad3: *mut libc::c_void,
	pub __pad4: *mut libc::c_void,
	pub __pad5: size_t,
	pub _mode: libc::c_int,
	pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_marker {
	pub _next: *mut _IO_marker,
	pub _sbuf: *mut _IO_FILE,
	pub _pos: libc::c_int,
}
pub type FILE = _IO_FILE;
pub type uint8_t = libc::c_uchar;
pub type uint32_t = libc::c_uint;
pub type uint64_t = libc::c_ulong;
pub type uintptr_t = libc::c_ulong;
/* FLECS_LEGACY should be defined when building for C89 */
// #define FLECS_LEGACY
/* FLECS_NO_CPP should be defined when building for C++ without the C++ API */
// #define FLECS_NO_CPP
/* FLECS_CUSTOM_BUILD should be defined when manually selecting features */
// #define FLECS_CUSTOM_BUILD
/* Modules */
/* Addons */
/* *
 * @file api_defines.h
 * @brief Supporting defines for the public API.
 *
 * This file contains constants / macro's that are typically not used by an
 * application but support the public API, and therefore must be exposed. This
 * header should not be included by itself.
 */
/* Standard library dependencies */
/* Non-standard but required. If not provided by platform, add manually. */
/* Contains macro's for importing / exporting symbols */
/*
								  )
								 (.)
								 .|.
								 | |
							 _.--| |--._
						  .-';  ;`-'& ; `&.
						 \   &  ;    &   &_/
						  |"""---...---"""|
						  \ | | | | | | | /
						   `---.|.|.|.---'

* This file is generated by bake.lang.c for your convenience. Headers of
* dependencies will automatically show up in this file. Include bake_config.h
* in your main project file. Do not edit! */
/* Headers of public dependencies */
/* No dependencies */
/* Convenience macro for exporting symbols */
// //////////////////////////////////////////////////////////////////////////////
// // Language support defines
// //////////////////////////////////////////////////////////////////////////////
/* The API uses the native bool type in C++, or a custom one in C */
pub type ecs_flags32_t = uint32_t;
/* Keep unsigned integers out of the codebase as they do more harm than good */
pub type ecs_size_t = int32_t;
// //////////////////////////////////////////////////////////////////////////////
// // Convenience macro's for ctor, dtor, move and copy
// //////////////////////////////////////////////////////////////////////////////
/* Constructor / destructor convenience macro */
/* Copy convenience macro */
/* Move convenience macro */
/* Public, so we can do compile-time offset calculation */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_vector_t {
	pub count: int32_t,
	pub size: int32_t,
}
pub type ecs_comparator_t =
	Option<unsafe extern "C" fn(_: *const libc::c_void, _: *const libc::c_void) -> libc::c_int>;
/* Memory management */
pub type ecs_os_api_malloc_t = Option<unsafe extern "C" fn(_: ecs_size_t) -> *mut libc::c_void>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_os_api_t {
	pub init_: ecs_os_api_init_t,
	pub fini_: ecs_os_api_fini_t,
	pub malloc_: ecs_os_api_malloc_t,
	pub realloc_: ecs_os_api_realloc_t,
	pub calloc_: ecs_os_api_calloc_t,
	pub free_: ecs_os_api_free_t,
	pub strdup_: ecs_os_api_strdup_t,
	pub thread_new_: ecs_os_api_thread_new_t,
	pub thread_join_: ecs_os_api_thread_join_t,
	pub ainc_: ecs_os_api_ainc_t,
	pub adec_: ecs_os_api_ainc_t,
	pub mutex_new_: ecs_os_api_mutex_new_t,
	pub mutex_free_: ecs_os_api_mutex_free_t,
	pub mutex_lock_: ecs_os_api_mutex_lock_t,
	pub mutex_unlock_: ecs_os_api_mutex_lock_t,
	pub cond_new_: ecs_os_api_cond_new_t,
	pub cond_free_: ecs_os_api_cond_free_t,
	pub cond_signal_: ecs_os_api_cond_signal_t,
	pub cond_broadcast_: ecs_os_api_cond_broadcast_t,
	pub cond_wait_: ecs_os_api_cond_wait_t,
	pub sleep_: ecs_os_api_sleep_t,
	pub get_time_: ecs_os_api_get_time_t,
	pub log_: ecs_os_api_log_t,
	pub log_error_: ecs_os_api_log_t,
	pub log_debug_: ecs_os_api_log_t,
	pub log_warning_: ecs_os_api_log_t,
	pub abort_: ecs_os_api_abort_t,
	pub dlopen_: ecs_os_api_dlopen_t,
	pub dlproc_: ecs_os_api_dlproc_t,
	pub dlclose_: ecs_os_api_dlclose_t,
	pub module_to_dl_: ecs_os_api_module_to_path_t,
	pub module_to_etc_: ecs_os_api_module_to_path_t,
}
pub type ecs_os_api_module_to_path_t =
	Option<unsafe extern "C" fn(_: *const libc::c_char) -> *mut libc::c_char>;
pub type ecs_os_api_dlclose_t = Option<unsafe extern "C" fn(_: ecs_os_dl_t) -> ()>;
pub type ecs_os_dl_t = uintptr_t;
pub type ecs_os_api_dlproc_t =
	Option<unsafe extern "C" fn(_: ecs_os_dl_t, _: *const libc::c_char) -> ecs_os_proc_t>;
/* Generic function pointer type */
pub type ecs_os_proc_t = Option<unsafe extern "C" fn() -> ()>;
/* Dynamic libraries */
pub type ecs_os_api_dlopen_t = Option<unsafe extern "C" fn(_: *const libc::c_char) -> ecs_os_dl_t>;
/* Application termination */
pub type ecs_os_api_abort_t = Option<unsafe extern "C" fn() -> ()>;
/* Logging */
pub type ecs_os_api_log_t =
	Option<unsafe extern "C" fn(_: *const libc::c_char, _: std::ffi::VaList) -> ()>;
pub type ecs_os_api_get_time_t = Option<unsafe extern "C" fn(_: *mut ecs_time_t) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_time_t {
	pub sec: uint32_t,
	pub nanosec: uint32_t,
}
pub type ecs_os_api_sleep_t = Option<unsafe extern "C" fn(_: int32_t, _: int32_t) -> ()>;
pub type ecs_os_api_cond_wait_t =
	Option<unsafe extern "C" fn(_: ecs_os_cond_t, _: ecs_os_mutex_t) -> ()>;
pub type ecs_os_mutex_t = uintptr_t;
pub type ecs_os_cond_t = uintptr_t;
pub type ecs_os_api_cond_broadcast_t = Option<unsafe extern "C" fn(_: ecs_os_cond_t) -> ()>;
pub type ecs_os_api_cond_signal_t = Option<unsafe extern "C" fn(_: ecs_os_cond_t) -> ()>;
pub type ecs_os_api_cond_free_t = Option<unsafe extern "C" fn(_: ecs_os_cond_t) -> ()>;
/* Condition variable */
pub type ecs_os_api_cond_new_t = Option<unsafe extern "C" fn() -> ecs_os_cond_t>;
pub type ecs_os_api_mutex_lock_t = Option<unsafe extern "C" fn(_: ecs_os_mutex_t) -> ()>;
pub type ecs_os_api_mutex_free_t = Option<unsafe extern "C" fn(_: ecs_os_mutex_t) -> ()>;
/* Mutex */
pub type ecs_os_api_mutex_new_t = Option<unsafe extern "C" fn() -> ecs_os_mutex_t>;
/* Atomic increment / decrement */
pub type ecs_os_api_ainc_t = Option<unsafe extern "C" fn(_: *mut int32_t) -> libc::c_int>;
pub type ecs_os_api_thread_join_t =
	Option<unsafe extern "C" fn(_: ecs_os_thread_t) -> *mut libc::c_void>;
/* Allocation counters (not thread safe) */
/* Use handle types that _at least_ can store pointers */
pub type ecs_os_thread_t = uintptr_t;
pub type ecs_os_api_thread_new_t = Option<
	unsafe extern "C" fn(_: ecs_os_thread_callback_t, _: *mut libc::c_void) -> ecs_os_thread_t,
>;
/* Threads */
pub type ecs_os_thread_callback_t =
	Option<unsafe extern "C" fn(_: *mut libc::c_void) -> *mut libc::c_void>;
pub type ecs_os_api_strdup_t =
	Option<unsafe extern "C" fn(_: *const libc::c_char) -> *mut libc::c_char>;
pub type ecs_os_api_free_t = Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>;
pub type ecs_os_api_calloc_t = Option<unsafe extern "C" fn(_: ecs_size_t) -> *mut libc::c_void>;
pub type ecs_os_api_realloc_t =
	Option<unsafe extern "C" fn(_: *mut libc::c_void, _: ecs_size_t) -> *mut libc::c_void>;
/* OS API deinit */
pub type ecs_os_api_fini_t = Option<unsafe extern "C" fn() -> ()>;
/* OS API init */
pub type ecs_os_api_init_t = Option<unsafe extern "C" fn() -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_sparse_t {
	pub dense: *mut ecs_vector_t,
	pub chunks: *mut ecs_vector_t,
	pub size: ecs_size_t,
	pub count: int32_t,
	pub max_id_local: uint64_t,
	pub max_id: *mut uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct chunk_t {
	pub sparse: *mut int32_t,
	pub data: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_map_t {
	pub buckets: *mut ecs_sparse_t,
	pub elem_size: int32_t,
	pub type_elem_size: int32_t,
	pub bucket_size: int32_t,
	pub bucket_count: int32_t,
	pub count: int32_t,
	pub offset: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_bucket_t {
	pub count: int32_t,
}
pub type ecs_map_key_t = uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_map_iter_t {
	pub map: *const ecs_map_t,
	pub bucket: *mut ecs_bucket_t,
	pub bucket_index: int32_t,
	pub element_index: int32_t,
	pub payload: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_switch_header_t {
	pub element: int32_t,
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_switch_node_t {
	pub next: int32_t,
	pub prev: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_switch_t {
	pub min: uint64_t,
	pub max: uint64_t,
	pub headers: *mut ecs_switch_header_t,
	pub nodes: *mut ecs_vector_t,
	pub values: *mut ecs_vector_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_strbuf_element {
	pub buffer_embedded: bool,
	pub pos: int32_t,
	pub buf: *mut libc::c_char,
	pub next: *mut ecs_strbuf_element,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_strbuf_element_embedded {
	pub super_0: ecs_strbuf_element,
	pub buf: [libc::c_char; 512],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_strbuf_element_str {
	pub super_0: ecs_strbuf_element,
	pub alloc_str: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_strbuf_list_elem {
	pub count: int32_t,
	pub separator: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_strbuf_t {
	pub buf: *mut libc::c_char,
	pub max: int32_t,
	pub size: int32_t,
	pub elementCount: int32_t,
	pub firstElement: ecs_strbuf_element_embedded,
	pub current: *mut ecs_strbuf_element,
	pub list_stack: [ecs_strbuf_list_elem; 32],
	pub list_sp: int32_t,
}
/* *
 * @defgroup api_types Basic API types
 * @{
 */
/* * An entity identifier. */
pub type ecs_entity_t = uint64_t;
/* * A vector containing component identifiers used to describe a type. */
pub type ecs_type_t = *const ecs_vector_t;
/* * The world stores and manages all ECS data. An application can have more than
 * one world, but data is not shared between worlds. */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_world_t {
	pub magic: int32_t,
	pub context: *mut libc::c_void,
	pub fini_actions: *mut ecs_vector_t,
	pub c_info: [ecs_c_info_t; 256],
	pub t_info: *mut ecs_map_t,
	pub range_check_enabled: bool,
	pub store: ecs_store_t,
	pub queries: *mut ecs_vector_t,
	pub component_monitors: ecs_component_monitor_t,
	pub parent_monitors: ecs_component_monitor_t,
	pub pipeline: ecs_entity_t,
	pub on_activate_components: *mut ecs_map_t,
	pub on_enable_components: *mut ecs_map_t,
	pub fini_tasks: *mut ecs_vector_t,
	pub type_handles: *mut ecs_map_t,
	pub aliases: *mut ecs_vector_t,
	pub stage: ecs_stage_t,
	pub temp_stage: ecs_stage_t,
	pub worker_stages: *mut ecs_vector_t,
	pub stage_count: int32_t,
	pub child_tables: *mut ecs_map_t,
	pub name_prefix: *const libc::c_char,
	pub workers: *mut ecs_vector_t,
	pub worker_cond: ecs_os_cond_t,
	pub sync_cond: ecs_os_cond_t,
	pub sync_mutex: ecs_os_mutex_t,
	pub workers_running: int32_t,
	pub workers_waiting: int32_t,
	pub world_start_time: ecs_time_t,
	pub frame_start_time: ecs_time_t,
	pub fps_sleep: libc::c_float,
	pub stats: ecs_world_info_t,
	pub arg_fps: libc::c_int,
	pub arg_threads: libc::c_int,
	pub mutex: ecs_os_mutex_t,
	pub thr_sync: ecs_os_mutex_t,
	pub thr_cond: ecs_os_cond_t,
	pub valid_schedule: bool,
	pub quit_workers: bool,
	pub in_progress: bool,
	pub is_merging: bool,
	pub auto_merge: bool,
	pub measure_frame_time: bool,
	pub measure_system_time: bool,
	pub should_quit: bool,
	pub locking_enabled: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_world_info_t {
	pub last_component_id: ecs_entity_t,
	pub last_id: ecs_entity_t,
	pub min_id: ecs_entity_t,
	pub max_id: ecs_entity_t,
	pub delta_time_raw: libc::c_float,
	pub delta_time: libc::c_float,
	pub time_scale: libc::c_float,
	pub target_fps: libc::c_float,
	pub frame_time_total: libc::c_float,
	pub system_time_total: libc::c_float,
	pub merge_time_total: libc::c_float,
	pub world_time_total: libc::c_float,
	pub world_time_total_raw: libc::c_float,
	pub sleep_err: libc::c_float,
	pub frame_count_total: int32_t,
	pub merge_count_total: int32_t,
	pub pipeline_build_count_total: int32_t,
	pub systems_ran_frame: int32_t,
}
/* * A stage is a data structure in which delta's are stored until it is safe to
 * merge those delta's with the main world stage. A stage allows flecs systems
 * to arbitrarily add/remove/set components and create/delete entities while
 * iterating. Additionally, worker threads have their own stage that lets them
 * mutate the state of entities without requiring locks. */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_stage_t {
	pub world: *mut ecs_world_t,
	pub id: int32_t,
	pub defer: int32_t,
	pub defer_queue: *mut ecs_vector_t,
	pub defer_merge_queue: *mut ecs_vector_t,
	pub post_frame_actions: *mut ecs_vector_t,
	pub scope_table: *mut ecs_table_t,
	pub scope: ecs_entity_t,
}
/* * A table is the Flecs equivalent of an archetype. Tables store all entities
 * with a specific set of components. Tables are automatically created when an
 * entity has a set of components not previously observed before. When a new
 * table is created, it is automatically matched with existing column systems */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_table_t {
	pub type_0: ecs_type_t,
	pub c_info: *mut *mut ecs_c_info_t,
	pub lo_edges: *mut ecs_edge_t,
	pub hi_edges: *mut ecs_map_t,
	pub data: *mut ecs_data_t,
	pub queries: *mut ecs_vector_t,
	pub monitors: *mut ecs_vector_t,
	pub on_set: *mut *mut ecs_vector_t,
	pub on_set_all: *mut ecs_vector_t,
	pub on_set_override: *mut ecs_vector_t,
	pub un_set_all: *mut ecs_vector_t,
	pub dirty_state: *mut int32_t,
	pub alloc_count: int32_t,
	pub id: uint32_t,
	pub flags: ecs_flags32_t,
	pub column_count: int32_t,
	pub sw_column_count: int32_t,
	pub sw_column_offset: int32_t,
}
/* * Stage-specific component data */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_data_t {
	pub entities: *mut ecs_vector_t,
	pub record_ptrs: *mut ecs_vector_t,
	pub columns: *mut ecs_column_t,
	pub sw_columns: *mut ecs_sw_column_t,
	pub marked_dirty: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_sw_column_t {
	pub data: *mut ecs_switch_t,
	pub type_0: ecs_type_t,
}
/* * A component column. */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_column_t {
	pub data: *mut ecs_vector_t,
	pub size: int16_t,
	pub alignment: int16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_edge_t {
	pub add: *mut ecs_table_t,
	pub remove: *mut ecs_table_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_c_info_t {
	pub component: ecs_entity_t,
	pub on_add: *mut ecs_vector_t,
	pub on_remove: *mut ecs_vector_t,
	pub lifecycle: EcsComponentLifecycle,
	pub lifecycle_set: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsComponentLifecycle {
	pub ctor: ecs_xtor_t,
	pub dtor: ecs_xtor_t,
	pub copy: ecs_copy_t,
	pub move_0: ecs_move_t,
	pub ctx: *mut libc::c_void,
}
/* * Move is invoked when a component is moved to another component. */
pub type ecs_move_t = Option<
	unsafe extern "C" fn(
		_: *mut ecs_world_t,
		_: ecs_entity_t,
		_: *const ecs_entity_t,
		_: *const ecs_entity_t,
		_: *mut libc::c_void,
		_: *mut libc::c_void,
		_: size_t,
		_: int32_t,
		_: *mut libc::c_void,
	) -> (),
>;
/* * Copy is invoked when a component is copied into another component. */
pub type ecs_copy_t = Option<
	unsafe extern "C" fn(
		_: *mut ecs_world_t,
		_: ecs_entity_t,
		_: *const ecs_entity_t,
		_: *const ecs_entity_t,
		_: *mut libc::c_void,
		_: *const libc::c_void,
		_: size_t,
		_: int32_t,
		_: *mut libc::c_void,
	) -> (),
>;
// //////////////////////////////////////////////////////////////////////////////
// // Function types
// //////////////////////////////////////////////////////////////////////////////
/* * Constructor/destructor. Used for initializing / deinitializing components. */
pub type ecs_xtor_t = Option<
	unsafe extern "C" fn(
		_: *mut ecs_world_t,
		_: ecs_entity_t,
		_: *const ecs_entity_t,
		_: *mut libc::c_void,
		_: size_t,
		_: int32_t,
		_: *mut libc::c_void,
	) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_component_monitor_t {
	pub dirty_flags: [bool; 256],
	pub monitors: [*mut ecs_vector_t; 256],
	pub rematch: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_store_t {
	pub entity_index: *mut ecs_sparse_t,
	pub tables: *mut ecs_sparse_t,
	pub root: ecs_table_t,
}
/* World snapshot */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_snapshot_t {
	pub world: *mut ecs_world_t,
	pub entity_index: *mut ecs_sparse_t,
	pub tables: *mut ecs_vector_t,
	pub last_id: ecs_entity_t,
	pub filter: ecs_filter_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_filter_t {
	pub include: ecs_type_t,
	pub exclude: ecs_type_t,
	pub include_kind: ecs_match_kind_t,
	pub exclude_kind: ecs_match_kind_t,
}
pub type ecs_match_kind_t = libc::c_uint;
pub const EcsMatchExact: ecs_match_kind_t = 3;
pub const EcsMatchAny: ecs_match_kind_t = 2;
pub const EcsMatchAll: ecs_match_kind_t = 1;
pub const EcsMatchDefault: ecs_match_kind_t = 0;
/* * Query that is automatically matched against active tables */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_query_t {
	pub sig: ecs_sig_t,
	pub world: *mut ecs_world_t,
	pub tables: *mut ecs_vector_t,
	pub empty_tables: *mut ecs_vector_t,
	pub system: ecs_entity_t,
	pub sort_on_component: ecs_entity_t,
	pub compare: ecs_compare_action_t,
	pub table_slices: *mut ecs_vector_t,
	pub rank_on_component: ecs_entity_t,
	pub group_table: ecs_rank_type_action_t,
	pub subqueries: *mut ecs_vector_t,
	pub flags: ecs_flags32_t,
	pub cascade_by: int32_t,
	pub match_count: int32_t,
	pub prev_match_count: int32_t,
}
/* * Compare callback used for sorting */
pub type ecs_rank_type_action_t =
	Option<unsafe extern "C" fn(_: *mut ecs_world_t, _: ecs_entity_t, _: ecs_type_t) -> int32_t>;
/* * Compare callback used for sorting */
pub type ecs_compare_action_t = Option<
	unsafe extern "C" fn(
		_: ecs_entity_t,
		_: *mut libc::c_void,
		_: ecs_entity_t,
		_: *mut libc::c_void,
	) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_sig_t {
	pub name: *const libc::c_char,
	pub expr: *mut libc::c_char,
	pub columns: *mut ecs_vector_t,
}
/* * The ecs_iter_t struct allows applications to iterate tables.
 * Queries and filters, among others, allow an application to iterate entities
 * that match a certain set of components. Because of how data is stored
 * internally, entiites with a given set of components may be stored in multiple
 * consecutive arrays, stored across multiple tables. The ecs_iter_t type
 * enables iteration across tables. */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_iter_t {
	pub world: *mut ecs_world_t,
	pub system: ecs_entity_t,
	pub table: *mut ecs_iter_table_t,
	pub query: *mut ecs_query_t,
	pub table_count: int32_t,
	pub inactive_table_count: int32_t,
	pub column_count: int32_t,
	pub table_columns: *mut libc::c_void,
	pub entities: *mut ecs_entity_t,
	pub param: *mut libc::c_void,
	pub delta_time: libc::c_float,
	pub delta_system_time: libc::c_float,
	pub world_time: libc::c_float,
	pub frame_offset: int32_t,
	pub table_offset: int32_t,
	pub offset: int32_t,
	pub count: int32_t,
	pub total_count: int32_t,
	pub triggered_by: *mut ecs_entities_t,
	pub interrupted_by: ecs_entity_t,
	pub iter: C2RustUnnamed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
	pub parent: ecs_scope_iter_t,
	pub filter: ecs_filter_iter_t,
	pub query: ecs_query_iter_t,
	pub snapshot: ecs_snapshot_iter_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_snapshot_iter_t {
	pub filter: ecs_filter_t,
	pub tables: *mut ecs_vector_t,
	pub index: int32_t,
	pub table: ecs_iter_table_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_iter_table_t {
	pub columns: *mut int32_t,
	pub table: *mut ecs_table_t,
	pub data: *mut ecs_data_t,
	pub components: *mut ecs_entity_t,
	pub types: *mut ecs_type_t,
	pub references: *mut ecs_ref_t,
}
// //////////////////////////////////////////////////////////////////////////////
// // Non-opaque types
// //////////////////////////////////////////////////////////////////////////////
/* * Cached reference. */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_ref_t {
	pub entity: ecs_entity_t,
	pub component: ecs_entity_t,
	pub table: *mut libc::c_void,
	pub row: int32_t,
	pub alloc_count: int32_t,
	pub record: *mut ecs_record_t,
	pub ptr: *const libc::c_void,
}
/* attempt to define endianness */
/* attempt to define endianness */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_record_t {
	pub table: *mut ecs_table_t,
	pub row: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_query_iter_t {
	pub query: *mut ecs_query_t,
	pub page_iter: ecs_page_iter_t,
	pub index: int32_t,
	pub sparse_smallest: int32_t,
	pub sparse_first: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_page_iter_t {
	pub offset: int32_t,
	pub limit: int32_t,
	pub remaining: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_filter_iter_t {
	pub filter: ecs_filter_t,
	pub tables: *mut ecs_sparse_t,
	pub index: int32_t,
	pub table: ecs_iter_table_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_scope_iter_t {
	pub filter: ecs_filter_t,
	pub tables: *mut ecs_vector_t,
	pub index: int32_t,
	pub table: ecs_iter_table_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_entities_t {
	pub array: *mut ecs_entity_t,
	pub count: int32_t,
}
/* * @} */
/* *
 * @defgroup function_types Function Types
 * @{
 */
/* * Action callback for systems and triggers */
pub type ecs_iter_action_t = Option<unsafe extern "C" fn(_: *mut ecs_iter_t) -> ()>;
pub type ecs_iter_next_action_t = Option<unsafe extern "C" fn(_: *mut ecs_iter_t) -> bool>;
/* * Initialization action for modules */
pub type ecs_module_action_t = Option<unsafe extern "C" fn(_: *mut ecs_world_t) -> ()>;
/* * Action callback on world exit */
pub type ecs_fini_action_t =
	Option<unsafe extern "C" fn(_: *mut ecs_world_t, _: *mut libc::c_void) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_page_cursor_t {
	pub first: int32_t,
	pub count: int32_t,
}
pub type EcsMatchFailureReason = libc::c_uint;
pub const EcsMatchNotFromContainer: EcsMatchFailureReason = 17;
pub const EcsMatchNotFromShared: EcsMatchFailureReason = 16;
pub const EcsMatchNotFromOwned: EcsMatchFailureReason = 15;
pub const EcsMatchNotFromSelf: EcsMatchFailureReason = 14;
pub const EcsMatchOrFromContainer: EcsMatchFailureReason = 13;
pub const EcsMatchOrFromShared: EcsMatchFailureReason = 12;
pub const EcsMatchOrFromOwned: EcsMatchFailureReason = 11;
pub const EcsMatchOrFromSelf: EcsMatchFailureReason = 10;
pub const EcsMatchFromEntity: EcsMatchFailureReason = 9;
pub const EcsMatchFromContainer: EcsMatchFailureReason = 8;
pub const EcsMatchFromShared: EcsMatchFailureReason = 7;
pub const EcsMatchFromOwned: EcsMatchFailureReason = 6;
pub const EcsMatchFromSelf: EcsMatchFailureReason = 5;
pub const EcsMatchEntityIsPrefab: EcsMatchFailureReason = 4;
pub const EcsMatchEntityIsDisabled: EcsMatchFailureReason = 3;
pub const EcsMatchSystemIsATask: EcsMatchFailureReason = 2;
pub const EcsMatchNotASystem: EcsMatchFailureReason = 1;
pub const EcsMatchOk: EcsMatchFailureReason = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_match_failure_t {
	pub reason: EcsMatchFailureReason,
	pub column: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
	pub header: C2RustUnnamed_1,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsName {
	pub value: *const libc::c_char,
	pub symbol: *const libc::c_char,
	pub alloc_value: *mut libc::c_char,
}
pub const _ISdigit: C2RustUnnamed_60 = 2048;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_alias_t {
	pub name: *mut libc::c_char,
	pub entity: ecs_entity_t,
}
pub const _ISupper: C2RustUnnamed_60 = 256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_thread_t {
	pub magic: int32_t,
	pub world: *mut ecs_world_t,
	pub stage: *mut ecs_stage_t,
	pub thread: ecs_os_thread_t,
	pub index: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_op_1_t {
	pub entity: ecs_entity_t,
	pub value: *mut libc::c_void,
	pub size: ecs_size_t,
	pub clone_value: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
	pub _1: ecs_op_1_t,
	pub _n: ecs_op_n_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_op_n_t {
	pub entities: *mut ecs_entity_t,
	pub bulk_data: *mut *mut libc::c_void,
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_op_t {
	pub kind: ecs_op_kind_t,
	pub scope: ecs_entity_t,
	pub component: ecs_entity_t,
	pub components: ecs_entities_t,
	pub is: C2RustUnnamed_2,
}
pub type ecs_op_kind_t = libc::c_uint;
pub const EcsOpClear: ecs_op_kind_t = 10;
pub const EcsOpDelete: ecs_op_kind_t = 9;
pub const EcsOpModified: ecs_op_kind_t = 8;
pub const EcsOpMut: ecs_op_kind_t = 7;
pub const EcsOpSet: ecs_op_kind_t = 6;
pub const EcsOpRemove: ecs_op_kind_t = 5;
pub const EcsOpAdd: ecs_op_kind_t = 4;
pub const EcsOpBulkNew: ecs_op_kind_t = 3;
pub const EcsOpClone: ecs_op_kind_t = 2;
pub const EcsOpNew: ecs_op_kind_t = 1;
pub const EcsOpNone: ecs_op_kind_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_entity_info_t {
	pub record: *mut ecs_record_t,
	pub table: *mut ecs_table_t,
	pub data: *mut ecs_data_t,
	pub row: int32_t,
	pub is_watched: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_query_event_t {
	pub kind: ecs_query_eventkind_t,
	pub table: *mut ecs_table_t,
	pub parent_query: *mut ecs_query_t,
}
pub type ecs_query_eventkind_t = libc::c_uint;
pub const EcsQueryTableUnmatch: ecs_query_eventkind_t = 4;
pub const EcsQueryTableRematch: ecs_query_eventkind_t = 3;
pub const EcsQueryTableNonEmpty: ecs_query_eventkind_t = 2;
pub const EcsQueryTableEmpty: ecs_query_eventkind_t = 1;
pub const EcsQueryTableMatch: ecs_query_eventkind_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_table_event_t {
	pub kind: ecs_table_eventkind_t,
	pub query: *mut ecs_query_t,
	pub matched_table_index: int32_t,
	pub component: ecs_entity_t,
}
pub type ecs_table_eventkind_t = libc::c_uint;
pub const EcsTableComponentInfo: ecs_table_eventkind_t = 2;
pub const EcsTableQueryUnmatch: ecs_table_eventkind_t = 1;
pub const EcsTableQueryMatch: ecs_table_eventkind_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_matched_table_t {
	pub data: ecs_iter_table_t,
	pub sparse_columns: *mut ecs_vector_t,
	pub monitor: *mut int32_t,
	pub rank: int32_t,
}
pub const _ISalpha: C2RustUnnamed_60 = 1024;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsType {
	pub type_0: ecs_type_t,
	pub normalized: ecs_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_matched_query_t {
	pub query: *mut ecs_query_t,
	pub matched_table_index: int32_t,
}
pub const EcsOperOptional: ecs_sig_oper_kind_t = 3;
pub type ecs_sig_oper_kind_t = libc::c_uint;
pub const EcsOperLast: ecs_sig_oper_kind_t = 5;
pub const EcsOperAll: ecs_sig_oper_kind_t = 4;
pub const EcsOperNot: ecs_sig_oper_kind_t = 2;
pub const EcsOperOr: ecs_sig_oper_kind_t = 1;
pub const EcsOperAnd: ecs_sig_oper_kind_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_sig_column_t {
	pub from_kind: ecs_sig_from_kind_t,
	pub oper_kind: ecs_sig_oper_kind_t,
	pub inout_kind: ecs_sig_inout_kind_t,
	pub is: C2RustUnnamed_3,
	pub source: ecs_entity_t,
	pub name: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
	pub type_0: *mut ecs_vector_t,
	pub component: ecs_entity_t,
}
pub type ecs_sig_inout_kind_t = libc::c_uint;
pub const EcsOut: ecs_sig_inout_kind_t = 2;
pub const EcsIn: ecs_sig_inout_kind_t = 1;
pub const EcsInOut: ecs_sig_inout_kind_t = 0;
pub type ecs_sig_from_kind_t = libc::c_uint;
pub const EcsCascade: ecs_sig_from_kind_t = 7;
pub const EcsFromEntity: ecs_sig_from_kind_t = 6;
pub const EcsFromEmpty: ecs_sig_from_kind_t = 5;
pub const EcsFromSystem: ecs_sig_from_kind_t = 4;
pub const EcsFromParent: ecs_sig_from_kind_t = 3;
pub const EcsFromShared: ecs_sig_from_kind_t = 2;
pub const EcsFromOwned: ecs_sig_from_kind_t = 1;
pub const EcsFromAny: ecs_sig_from_kind_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsSystem {
	pub action: ecs_iter_action_t,
	pub ctx: *mut libc::c_void,
	pub entity: ecs_entity_t,
	pub query: *mut ecs_query_t,
	pub on_demand: *mut ecs_on_demand_out_t,
	pub status_action: ecs_system_status_action_t,
	pub status_ctx: *mut libc::c_void,
	pub tick_source: ecs_entity_t,
	pub invoke_count: int32_t,
	pub time_spent: libc::c_float,
	pub time_passed: libc::c_float,
}
pub type ecs_system_status_action_t = Option<
	unsafe extern "C" fn(
		_: *mut ecs_world_t,
		_: ecs_entity_t,
		_: ecs_system_status_t,
		_: *mut libc::c_void,
	) -> (),
>;
pub type ecs_system_status_t = libc::c_uint;
pub const EcsSystemDeactivated: ecs_system_status_t = 4;
pub const EcsSystemActivated: ecs_system_status_t = 3;
pub const EcsSystemDisabled: ecs_system_status_t = 2;
pub const EcsSystemEnabled: ecs_system_status_t = 1;
pub const EcsSystemStatusNone: ecs_system_status_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_on_demand_out_t {
	pub system: ecs_entity_t,
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_on_demand_in_t {
	pub count: int32_t,
	pub systems: *mut ecs_vector_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_comp_set_t {
	pub hi_count: int32_t,
	pub hi_array: [ecs_entity_t; 32],
	pub lo_mask: [ecs_entity_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_column_info_t {
	pub id: ecs_entity_t,
	pub ci: *mut ecs_c_info_t,
	pub column: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsTrigger {
	pub kind: ecs_entity_t,
	pub action: ecs_iter_action_t,
	pub component: ecs_entity_t,
	pub self_0: ecs_entity_t,
	pub ctx: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsComponent {
	pub size: ecs_size_t,
	pub alignment: ecs_size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trait_offset_t {
	pub index: int32_t,
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_sparse_column_t {
	pub sw_column: *mut ecs_sw_column_t,
	pub sw_case: ecs_entity_t,
	pub signature_column_index: int32_t,
}
/* * Callback used by the system signature expression parser. */
pub type ecs_parse_action_t = Option<
	unsafe extern "C" fn(
		_: *mut ecs_world_t,
		_: *const libc::c_char,
		_: *const libc::c_char,
		_: int64_t,
		_: ecs_sig_from_kind_t,
		_: ecs_sig_oper_kind_t,
		_: ecs_sig_inout_kind_t,
		_: ecs_entity_t,
		_: *const libc::c_char,
		_: *const libc::c_char,
		_: *const libc::c_char,
		_: *const libc::c_char,
		_: *mut libc::c_void,
	) -> libc::c_int,
>;
pub const _ISspace: C2RustUnnamed_60 = 8192;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sig_element_t {
	pub role: ecs_entity_t,
	pub inout_kind: ecs_sig_inout_kind_t,
	pub from_kind: ecs_sig_from_kind_t,
	pub oper_kind: ecs_sig_oper_kind_t,
	pub trait_0: *mut libc::c_char,
	pub source: *mut libc::c_char,
	pub component: *mut libc::c_char,
	pub name: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsIterAction {
	pub action: ecs_iter_action_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsSignatureExpr {
	pub expr: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
	pub header: C2RustUnnamed_5,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FlecsTimer {
	pub dummy: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsTickSource {
	pub tick: bool,
	pub time_elapsed: libc::c_float,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsRateFilter {
	pub src: ecs_entity_t,
	pub rate: int32_t,
	pub tick_count: int32_t,
	pub time_elapsed: libc::c_float,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsTimer {
	pub timeout: libc::c_float,
	pub time: libc::c_float,
	pub fired_count: int32_t,
	pub active: bool,
	pub single_shot: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
	pub header: C2RustUnnamed_7,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FlecsPipeline {
	pub dummy: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsPipelineQuery {
	pub query: *mut ecs_query_t,
	pub build_query: *mut ecs_query_t,
	pub match_count: int32_t,
	pub ops: *mut ecs_vector_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sort_helper_t {
	pub table: *mut ecs_matched_table_t,
	pub entities: *mut ecs_entity_t,
	pub ptr: *mut libc::c_void,
	pub row: int32_t,
	pub elem_size: int32_t,
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_table_slice_t {
	pub table: *mut ecs_matched_table_t,
	pub start_row: int32_t,
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_pipeline_op_t {
	pub count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct write_state_t {
	pub components: *mut ecs_map_t,
	pub wildcard: bool,
}
pub const WriteToStage: ComponentWriteState = 2;
pub const WriteToMain: ComponentWriteState = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_action_elem_t {
	pub action: ecs_fini_action_t,
	pub ctx: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
	pub header: C2RustUnnamed_9,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
	pub header: C2RustUnnamed_11,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FlecsSystem {
	pub dummy: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsContext {
	pub ctx: *const libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsQuery {
	pub query: *mut ecs_query_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsSignature {
	pub signature: ecs_sig_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
	pub header: C2RustUnnamed_13,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
	pub header: C2RustUnnamed_15,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
	pub header: C2RustUnnamed_17,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_17 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
	pub header: C2RustUnnamed_19,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_19 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
	pub header: C2RustUnnamed_21,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
	pub header: C2RustUnnamed_23,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_23 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
	pub header: C2RustUnnamed_25,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_25 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
	pub header: C2RustUnnamed_27,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_27 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_28 {
	pub header: C2RustUnnamed_29,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_29 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
	pub header: C2RustUnnamed_31,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_31 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_32 {
	pub header: C2RustUnnamed_33,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_33 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_34 {
	pub header: C2RustUnnamed_35,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_35 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_dbg_system_t {
	pub system: ecs_entity_t,
	pub entities_matched_count: int32_t,
	pub active_table_count: int32_t,
	pub inactive_table_count: int32_t,
	pub enabled: bool,
	pub system_data: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_dbg_entity_t {
	pub entity: ecs_entity_t,
	pub table: *mut ecs_table_t,
	pub type_0: ecs_type_t,
	pub row: int32_t,
	pub is_watched: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_memory_stat_t {
	pub allocd_bytes: int32_t,
	pub used_bytes: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsAllocStats {
	pub malloc_count_total: int64_t,
	pub realloc_count_total: int64_t,
	pub calloc_count_total: int64_t,
	pub free_count_total: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsRowSystemMemoryStats {
	pub base_memory_bytes: int32_t,
	pub columns_memory: ecs_memory_stat_t,
	pub components_memory: ecs_memory_stat_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsSystemMemoryStats {
	pub base_memory_bytes: int32_t,
	pub columns_memory: ecs_memory_stat_t,
	pub active_tables_memory: ecs_memory_stat_t,
	pub inactive_tables_memory: ecs_memory_stat_t,
	pub jobs_memory: ecs_memory_stat_t,
	pub other_memory_bytes: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsMemoryStats {
	pub __dummy: int32_t,
	pub total_memory: ecs_memory_stat_t,
	pub entities_memory: ecs_memory_stat_t,
	pub components_memory: ecs_memory_stat_t,
	pub systems_memory: ecs_memory_stat_t,
	pub types_memory: ecs_memory_stat_t,
	pub tables_memory: ecs_memory_stat_t,
	pub stages_memory: ecs_memory_stat_t,
	pub world_memory: ecs_memory_stat_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsComponentStats {
	pub entity: ecs_entity_t,
	pub name: *const libc::c_char,
	pub size_bytes: int32_t,
	pub memory: ecs_memory_stat_t,
	pub entities_count: int32_t,
	pub tables_count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsSystemStats {
	pub entity: ecs_entity_t,
	pub name: *const libc::c_char,
	pub signature: *const libc::c_char,
	pub phase: ecs_entity_t,
	pub period_seconds: libc::c_float,
	pub tables_matched_count: int32_t,
	pub entities_matched_count: int32_t,
	pub invoke_count_total: int64_t,
	pub seconds_total: libc::c_float,
	pub is_enabled: bool,
	pub is_active: bool,
	pub is_hidden: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsTypeStats {
	pub entity: ecs_entity_t,
	pub name: *const libc::c_char,
	pub type_0: ecs_type_t,
	pub normalized_type: ecs_type_t,
	pub entities_count: int32_t,
	pub entities_childof_count: int32_t,
	pub entities_instanceof_count: int32_t,
	pub components_count: int32_t,
	pub col_systems_count: int32_t,
	pub row_systems_count: int32_t,
	pub enabled_systems_count: int32_t,
	pub active_systems_count: int32_t,
	pub instance_count: int32_t,
	pub is_hidden: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsTableStats {
	pub type_0: ecs_type_t,
	pub columns_count: int32_t,
	pub rows_count: int32_t,
	pub systems_matched_count: int32_t,
	pub entity_memory: ecs_memory_stat_t,
	pub component_memory: ecs_memory_stat_t,
	pub other_memory_bytes: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsWorldStats {
	pub target_fps_hz: libc::c_double,
	pub tables_count: int32_t,
	pub components_count: int32_t,
	pub col_systems_count: int32_t,
	pub row_systems_count: int32_t,
	pub inactive_systems_count: int32_t,
	pub entities_count: int32_t,
	pub threads_count: int32_t,
	pub frame_count_total: int32_t,
	pub frame_seconds_total: libc::c_double,
	pub system_seconds_total: libc::c_double,
	pub merge_seconds_total: libc::c_double,
	pub world_seconds_total: libc::c_double,
	pub fps_hz: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FlecsStats {
	pub FLECS__EEcsAllocStats: ecs_entity_t,
	pub FLECS__TEcsAllocStats: ecs_type_t,
	pub FLECS__EEcsWorldStats: ecs_entity_t,
	pub FLECS__TEcsWorldStats: ecs_type_t,
	pub FLECS__EEcsMemoryStats: ecs_entity_t,
	pub FLECS__TEcsMemoryStats: ecs_type_t,
	pub FLECS__EEcsSystemStats: ecs_entity_t,
	pub FLECS__TEcsSystemStats: ecs_type_t,
	pub FLECS__EEcsSystemMemoryStats: ecs_entity_t,
	pub FLECS__TEcsSystemMemoryStats: ecs_type_t,
	pub FLECS__EEcsRowSystemMemoryStats: ecs_entity_t,
	pub FLECS__TEcsRowSystemMemoryStats: ecs_type_t,
	pub FLECS__EEcsComponentStats: ecs_entity_t,
	pub FLECS__TEcsComponentStats: ecs_type_t,
	pub FLECS__EEcsTableStats: ecs_entity_t,
	pub FLECS__TEcsTableStats: ecs_type_t,
	pub FLECS__EEcsTablePtr: ecs_entity_t,
	pub FLECS__TEcsTablePtr: ecs_type_t,
	pub FLECS__EEcsTypeStats: ecs_entity_t,
	pub FLECS__TEcsTypeStats: ecs_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_36 {
	pub header: C2RustUnnamed_37,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_37 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_38 {
	pub header: C2RustUnnamed_39,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_39 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EcsTablePtr {
	pub table: *mut ecs_table_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_40 {
	pub header: C2RustUnnamed_41,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_41 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_42 {
	pub header: C2RustUnnamed_43,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_43 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_44 {
	pub header: C2RustUnnamed_45,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_45 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_46 {
	pub header: C2RustUnnamed_47,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_47 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_48 {
	pub header: C2RustUnnamed_49,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_49 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_50 {
	pub header: C2RustUnnamed_51,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_51 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_52 {
	pub header: C2RustUnnamed_53,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_53 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_54 {
	pub header: C2RustUnnamed_55,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_55 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_56 {
	pub header: C2RustUnnamed_57,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_57 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_58 {
	pub header: C2RustUnnamed_59,
	pub array: [ecs_entity_t; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_59 {
	pub vector: ecs_vector_t,
	pub align: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_dbg_table_t {
	pub table: *mut ecs_table_t,
	pub type_0: ecs_type_t,
	pub shared: ecs_type_t,
	pub container: ecs_type_t,
	pub parent_entities: ecs_type_t,
	pub base_entities: ecs_type_t,
	pub systems_matched: *mut ecs_vector_t,
	pub entities: *mut ecs_entity_t,
	pub entities_count: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_queue_t {
	pub data: *mut ecs_vector_t,
	pub index: int32_t,
}
pub type ecs_blob_header_kind_t = libc::c_uint;
pub const EcsStreamFooter: ecs_blob_header_kind_t = 14;
pub const EcsTableColumnName: ecs_blob_header_kind_t = 13;
pub const EcsTableColumnNameLength: ecs_blob_header_kind_t = 12;
pub const EcsTableColumnNameHeader: ecs_blob_header_kind_t = 11;
pub const EcsTableColumnData: ecs_blob_header_kind_t = 10;
pub const EcsTableColumnSize: ecs_blob_header_kind_t = 9;
pub const EcsTableColumnHeader: ecs_blob_header_kind_t = 8;
pub const EcsTableColumn: ecs_blob_header_kind_t = 7;
pub const EcsTableSize: ecs_blob_header_kind_t = 6;
pub const EcsTableType: ecs_blob_header_kind_t = 5;
pub const EcsTableTypeSize: ecs_blob_header_kind_t = 4;
pub const EcsTableHeader: ecs_blob_header_kind_t = 3;
pub const EcsFooterSegment: ecs_blob_header_kind_t = 2;
pub const EcsTableSegment: ecs_blob_header_kind_t = 1;
pub const EcsStreamHeader: ecs_blob_header_kind_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_table_reader_t {
	pub state: ecs_blob_header_kind_t,
	pub table_index: int32_t,
	pub table: *mut ecs_table_t,
	pub data: *mut ecs_data_t,
	pub type_written: ecs_size_t,
	pub type_0: ecs_type_t,
	pub column_vector: *mut ecs_vector_t,
	pub column_index: int32_t,
	pub total_columns: int32_t,
	pub column_data: *mut libc::c_void,
	pub column_size: int16_t,
	pub column_alignment: int16_t,
	pub column_written: ecs_size_t,
	pub row_index: int32_t,
	pub row_count: int32_t,
	pub name: *const libc::c_char,
	pub name_len: ecs_size_t,
	pub name_written: ecs_size_t,
	pub has_next_table: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_reader_t {
	pub world: *mut ecs_world_t,
	pub state: ecs_blob_header_kind_t,
	pub data_iter: ecs_iter_t,
	pub data_next: ecs_iter_next_action_t,
	pub component_iter: ecs_iter_t,
	pub component_next: ecs_iter_next_action_t,
	pub table: ecs_table_reader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_name_writer_t {
	pub name: *mut libc::c_char,
	pub written: int32_t,
	pub len: int32_t,
	pub max_len: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_table_writer_t {
	pub state: ecs_blob_header_kind_t,
	pub table: *mut ecs_table_t,
	pub column_vector: *mut ecs_vector_t,
	pub type_count: int32_t,
	pub type_max_count: int32_t,
	pub type_written: ecs_size_t,
	pub type_array: *mut ecs_entity_t,
	pub column_index: int32_t,
	pub column_size: int16_t,
	pub column_alignment: int16_t,
	pub column_written: ecs_size_t,
	pub column_data: *mut libc::c_void,
	pub row_count: int32_t,
	pub row_index: int32_t,
	pub name: ecs_name_writer_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_writer_t {
	pub world: *mut ecs_world_t,
	pub state: ecs_blob_header_kind_t,
	pub table: ecs_table_writer_t,
	pub error: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ecs_table_leaf_t {
	pub table: *mut ecs_table_t,
	pub type_0: ecs_type_t,
	pub data: *mut ecs_data_t,
}
pub type C2RustUnnamed_60 = libc::c_uint;
pub const _ISalnum: C2RustUnnamed_60 = 8;
pub const _ISpunct: C2RustUnnamed_60 = 4;
pub const _IScntrl: C2RustUnnamed_60 = 2;
pub const _ISblank: C2RustUnnamed_60 = 1;
pub const _ISgraph: C2RustUnnamed_60 = 32768;
pub const _ISprint: C2RustUnnamed_60 = 16384;
pub const _ISxdigit: C2RustUnnamed_60 = 4096;
pub const _ISlower: C2RustUnnamed_60 = 512;
pub type ComponentWriteState = libc::c_uint;
pub const NotWritten: ComponentWriteState = 0;
unsafe extern "C" fn ecs_vasprintf(
	mut fmt: *const libc::c_char,
	mut args: ::std::ffi::VaList,
) -> *mut libc::c_char {
	let mut size: ecs_size_t = 0 as libc::c_int;
	let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
	let mut tmpa: ::std::ffi::VaListImpl;
	tmpa = args.clone();
	size = vsnprintf(
		result,
		ecs_to_size_t(size as int64_t),
		fmt,
		tmpa.as_va_list(),
	);
	if size < 0 as libc::c_int {
		return 0 as *mut libc::c_char;
	}
	result = ecs_os_api.malloc_.expect("non-null function pointer")(size + 1 as libc::c_int)
		as *mut libc::c_char;
	if result.is_null() {
		return 0 as *mut libc::c_char;
	}
	vsprintf(result, fmt, args.as_va_list());
	return result;
}
unsafe extern "C" fn ecs_colorize(mut msg: *mut libc::c_char) -> *mut libc::c_char {
	let mut buff: ecs_strbuf_t = {
		let mut init = ecs_strbuf_t {
			buf: 0 as *mut libc::c_char,
			max: 0,
			size: 0,
			elementCount: 0,
			firstElement: ecs_strbuf_element_embedded {
				super_0: ecs_strbuf_element {
					buffer_embedded: false,
					pos: 0,
					buf: 0 as *mut libc::c_char,
					next: 0 as *mut ecs_strbuf_element,
				},
				buf: [0; 512],
			},
			current: 0 as *mut ecs_strbuf_element,
			list_stack: [ecs_strbuf_list_elem {
				count: 0,
				separator: 0 as *const libc::c_char,
			}; 32],
			list_sp: 0,
		};
		init
	};
	let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
	let mut ch: libc::c_char = 0;
	let mut prev: libc::c_char = '\u{0}' as i32 as libc::c_char;
	let mut isNum: bool = 0 as libc::c_int != 0;
	let mut isStr: libc::c_char = '\u{0}' as i32 as libc::c_char;
	let mut isVar: bool = 0 as libc::c_int != 0;
	let mut overrideColor: bool = 0 as libc::c_int != 0;
	let mut autoColor: bool = 1 as libc::c_int != 0;
	let mut dontAppend: bool = 0 as libc::c_int != 0;
	let mut use_colors: bool = 1 as libc::c_int != 0;
	ptr = msg;
	loop {
		ch = *ptr;
		if !(ch != 0) {
			break;
		}
		dontAppend = 0 as libc::c_int != 0;
		if !overrideColor {
			if isNum as libc::c_int != 0
				&& *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
					& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
					== 0 && *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
				& _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
				== 0 && ch as libc::c_int != '.' as i32
				&& ch as libc::c_int != '%' as i32
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
				isNum = 0 as libc::c_int != 0
			}
			if isStr as libc::c_int != 0
				&& isStr as libc::c_int == ch as libc::c_int
				&& prev as libc::c_int != '\\' as i32
			{
				isStr = '\u{0}' as i32 as libc::c_char
			} else if (ch as libc::c_int == '\'' as i32 || ch as libc::c_int == '\"' as i32)
				&& isStr == 0 && *(*__ctype_b_loc()).offset(prev as libc::c_int as isize)
				as libc::c_int & _ISalpha as libc::c_int as libc::c_ushort
				as libc::c_int == 0
				&& prev as libc::c_int != '\\' as i32
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;36m\x00" as *const u8 as *const libc::c_char,
					);
				}
				isStr = ch
			}
			if (*(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
				& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
				!= 0 || ch as libc::c_int == '%' as i32
				&& *(*__ctype_b_loc()).offset(prev as libc::c_int as isize) as libc::c_int
					& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
					!= 0 || ch as libc::c_int == '-' as i32
				&& *(*__ctype_b_loc())
					.offset(*ptr.offset(1 as libc::c_int as isize) as libc::c_int as isize)
					as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
					!= 0) && !isNum && isStr == 0
				&& !isVar && *(*__ctype_b_loc()).offset(prev as libc::c_int as isize) as libc::c_int
				& _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
				== 0 && *(*__ctype_b_loc()).offset(prev as libc::c_int as isize) as libc::c_int
				& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
				== 0 && prev as libc::c_int != '_' as i32
				&& prev as libc::c_int != '.' as i32
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;32m\x00" as *const u8 as *const libc::c_char,
					);
				}
				isNum = 1 as libc::c_int != 0
			}
			if isVar as libc::c_int != 0
				&& *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
					& _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
					== 0 && *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
				& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
				== 0 && ch as libc::c_int != '_' as i32
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
				isVar = 0 as libc::c_int != 0
			}
			if isStr == 0
				&& !isVar && ch as libc::c_int == '$' as i32
				&& *(*__ctype_b_loc())
					.offset(*ptr.offset(1 as libc::c_int as isize) as libc::c_int as isize)
					as libc::c_int & _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
					!= 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;36m\x00" as *const u8 as *const libc::c_char,
					);
				}
				isVar = 1 as libc::c_int != 0
			}
		}
		if !isVar
			&& isStr == 0
			&& !isNum && ch as libc::c_int == '#' as i32
			&& *ptr.offset(1 as libc::c_int as isize) as libc::c_int == '[' as i32
		{
			let mut isColor: bool = 1 as libc::c_int != 0;
			overrideColor = 1 as libc::c_int != 0;
			/* Custom colors */
			if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"]\x00" as *const u8 as *const libc::c_char,
				strlen(b"]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				autoColor = 0 as libc::c_int != 0
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"green]\x00" as *const u8 as *const libc::c_char,
				strlen(b"green]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;32m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"red]\x00" as *const u8 as *const libc::c_char,
				strlen(b"red]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;31m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"blue]\x00" as *const u8 as *const libc::c_char,
				strlen(b"red]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;34m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"magenta]\x00" as *const u8 as *const libc::c_char,
				strlen(b"magenta]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;35m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"cyan]\x00" as *const u8 as *const libc::c_char,
				strlen(b"cyan]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;36m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"yellow]\x00" as *const u8 as *const libc::c_char,
				strlen(b"yellow]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;33m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"grey]\x00" as *const u8 as *const libc::c_char,
				strlen(b"grey]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;37m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"white]\x00" as *const u8 as *const libc::c_char,
				strlen(b"white]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"bold]\x00" as *const u8 as *const libc::c_char,
				strlen(b"bold]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[1;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"normal]\x00" as *const u8 as *const libc::c_char,
				strlen(b"normal]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else if strncmp(
				&mut *ptr.offset(2 as libc::c_int as isize),
				b"reset]\x00" as *const u8 as *const libc::c_char,
				strlen(b"reset]\x00" as *const u8 as *const libc::c_char) as ecs_size_t as size_t,
			) == 0
			{
				overrideColor = 0 as libc::c_int != 0;
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
			} else {
				isColor = 0 as libc::c_int != 0;
				overrideColor = 0 as libc::c_int != 0
			}
			if isColor {
				ptr = ptr.offset(2 as libc::c_int as isize);
				loop {
					ch = *ptr;
					if !(ch as libc::c_int != ']' as i32) {
						break;
					}
					ptr = ptr.offset(1)
				}
				dontAppend = 1 as libc::c_int != 0
			}
			if !autoColor {
				overrideColor = 1 as libc::c_int != 0
			}
		}
		if ch as libc::c_int == '\n' as i32 {
			if isNum as libc::c_int != 0
				|| isStr as libc::c_int != 0
				|| isVar as libc::c_int != 0
				|| overrideColor as libc::c_int != 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
				overrideColor = 0 as libc::c_int != 0;
				isNum = 0 as libc::c_int != 0;
				isStr = 0 as libc::c_int as libc::c_char;
				isVar = 0 as libc::c_int != 0
			}
		}
		if !dontAppend {
			ecs_strbuf_appendstrn(&mut buff, ptr, 1 as libc::c_int);
		}
		if !overrideColor {
			if (ch as libc::c_int == '\'' as i32 || ch as libc::c_int == '\"' as i32) && isStr == 0
			{
				if use_colors {
					ecs_strbuf_appendstr(
						&mut buff,
						b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
					);
				}
			}
		}
		prev = ch;
		ptr = ptr.offset(1)
	}
	if isNum as libc::c_int != 0
		|| isStr as libc::c_int != 0
		|| isVar as libc::c_int != 0
		|| overrideColor as libc::c_int != 0
	{
		if use_colors {
			ecs_strbuf_appendstr(
				&mut buff,
				b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			);
		}
	}
	return ecs_strbuf_get(&mut buff);
}
static mut trace_indent: libc::c_int = 0 as libc::c_int;
static mut trace_level: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn ecs_log_print(
	mut level: libc::c_int,
	mut file: *const libc::c_char,
	mut line: int32_t,
	mut fmt: *const libc::c_char,
	mut valist: ::std::ffi::VaList,
) {
	if level > trace_level {
		return;
	}
	/* Massage filename so it doesn't take up too much space */
	let mut filebuff: [libc::c_char; 256] = [0; 256];
	strcpy(filebuff.as_mut_ptr(), file);
	file = filebuff.as_mut_ptr();
	let mut file_ptr: *mut libc::c_char = strrchr(file, '/' as i32);
	if !file_ptr.is_null() {
		file = file_ptr.offset(1 as libc::c_int as isize)
	}
	/* Extension is likely the same for all files */
	file_ptr = strrchr(file, '.' as i32);
	if !file_ptr.is_null() {
		*file_ptr = '\u{0}' as i32 as libc::c_char
	}
	let mut indent: [libc::c_char; 32] = [0; 32];
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < trace_indent {
		indent[(i * 2 as libc::c_int) as usize] = '|' as i32 as libc::c_char;
		indent[(i * 2 as libc::c_int + 1 as libc::c_int) as usize] = ' ' as i32 as libc::c_char;
		i += 1
	}
	indent[(i * 2 as libc::c_int) as usize] = '\u{0}' as i32 as libc::c_char;
	let mut msg: *mut libc::c_char = ecs_vasprintf(fmt, valist.as_va_list());
	let mut color_msg: *mut libc::c_char = ecs_colorize(msg);
	if level >= 0 as libc::c_int {
		ecs_os_log(
			b"%sinfo%s: %s%s%s%s\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;35m\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;37m\x00" as *const u8 as *const libc::c_char,
			indent.as_mut_ptr(),
			b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			color_msg,
		);
	} else if level == -(2 as libc::c_int) {
		ecs_os_warn(
			b"%swarn%s: %s%s%s%s\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;33m\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;37m\x00" as *const u8 as *const libc::c_char,
			indent.as_mut_ptr(),
			b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			color_msg,
		);
	} else if level <= -(2 as libc::c_int) {
		ecs_os_err(
			b"%serr %s: %s%s%s%s\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;31m\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			b"\x1b[0;37m\x00" as *const u8 as *const libc::c_char,
			indent.as_mut_ptr(),
			b"\x1b[0;49m\x00" as *const u8 as *const libc::c_char,
			color_msg,
		);
	}
	ecs_os_api.free_.expect("non-null function pointer")(color_msg as *mut libc::c_void);
	ecs_os_api.free_.expect("non-null function pointer")(msg as *mut libc::c_void);
}
// //////////////////////////////////////////////////////////////////////////////
// // Tracing
// //////////////////////////////////////////////////////////////////////////////
#[no_mangle]
pub unsafe extern "C" fn _ecs_trace(
	mut level: libc::c_int,
	mut file: *const libc::c_char,
	mut line: int32_t,
	mut fmt: *const libc::c_char,
	mut args: ...
) {
	let mut valist: ::std::ffi::VaListImpl;
	valist = args.clone();
	ecs_log_print(level, file, line, fmt, valist.as_va_list());
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_warn(
	mut file: *const libc::c_char,
	mut line: int32_t,
	mut fmt: *const libc::c_char,
	mut args: ...
) {
	let mut valist: ::std::ffi::VaListImpl;
	valist = args.clone();
	ecs_log_print(-(2 as libc::c_int), file, line, fmt, valist.as_va_list());
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_err(
	mut file: *const libc::c_char,
	mut line: int32_t,
	mut fmt: *const libc::c_char,
	mut args: ...
) {
	let mut valist: ::std::ffi::VaListImpl;
	valist = args.clone();
	ecs_log_print(-(3 as libc::c_int), file, line, fmt, valist.as_va_list());
}
#[no_mangle]
pub unsafe extern "C" fn ecs_log_push() {
	trace_indent += 1;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_log_pop() {
	trace_indent -= 1;
}
/* * Enable or disable tracing.
 * This will enable builtin tracing. For tracing to work, it will have to be
 * compiled in which requires defining one of the following macro's:
 *
 * ECS_TRACE_0 - All tracing is disabled
 * ECS_TRACE_1 - Enable tracing level 1
 * ECS_TRACE_2 - Enable tracing level 2 and below
 * ECS_TRACE_3 - Enable tracing level 3 and below
 *
 * If no tracing level is defined and this is a debug build, ECS_TRACE_3 will
 * have been automatically defined.
 *
 * The provided level corresponds with the tracing level. If -1 is provided as
 * value, warnings are disabled. If -2 is provided, errors are disabled as well.
 *
 * @param level Desired tracing level.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_tracing_enable(mut level: libc::c_int) {
	trace_level = level;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_parser_error(
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
	mut column: int64_t,
	mut fmt: *const libc::c_char,
	mut args: ...
) {
	if trace_level >= -(2 as libc::c_int) {
		let mut valist: ::std::ffi::VaListImpl;
		valist = args.clone();
		let mut msg: *mut libc::c_char = ecs_vasprintf(fmt, valist.as_va_list());
		ecs_os_err(
			b"%s:%d: error: %s\x00" as *const u8 as *const libc::c_char,
			name,
			column + 1 as libc::c_int as libc::c_long,
			msg,
		);
		ecs_os_err(b"    %s\x00" as *const u8 as *const libc::c_char, expr);
		ecs_os_err(
			b"    %*s^\x00" as *const u8 as *const libc::c_char,
			column,
			b"\x00" as *const u8 as *const libc::c_char,
		);
		ecs_os_api.free_.expect("non-null function pointer")(msg as *mut libc::c_void);
	}
	ecs_os_api.abort_.expect("non-null function pointer")();
}
/* * Abort */
#[no_mangle]
pub unsafe extern "C" fn _ecs_abort(
	mut error_code: int32_t,
	mut param: *const libc::c_char,
	mut file: *const libc::c_char,
	mut line: int32_t,
) {
	if !param.is_null() {
		_ecs_err(
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			13318 as libc::c_int,
			b"abort %s:%d: %s (%s)\x00" as *const u8 as *const libc::c_char,
			file,
			line,
			ecs_strerror(error_code),
			param,
		);
	} else {
		_ecs_err(
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			13320 as libc::c_int,
			b"abort %s:%d: %s\x00" as *const u8 as *const libc::c_char,
			file,
			line,
			ecs_strerror(error_code),
		);
	}
	ecs_os_api.abort_.expect("non-null function pointer")();
}
/* * Assert */
#[no_mangle]
pub unsafe extern "C" fn _ecs_assert(
	mut condition: bool,
	mut error_code: int32_t,
	mut param: *const libc::c_char,
	mut condition_str: *const libc::c_char,
	mut file: *const libc::c_char,
	mut line: int32_t,
) {
	if !condition {
		if !param.is_null() {
			_ecs_err(
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				13337 as libc::c_int,
				b"assert(%s) %s:%d: %s (%s)\x00" as *const u8 as *const libc::c_char,
				condition_str,
				file,
				line,
				ecs_strerror(error_code),
				param,
			);
		} else {
			_ecs_err(
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				13340 as libc::c_int,
				b"assert(%s) %s:%d: %s\x00" as *const u8 as *const libc::c_char,
				condition_str,
				file,
				line,
				ecs_strerror(error_code),
			);
		}
		ecs_os_api.abort_.expect("non-null function pointer")();
	};
}
/* If in debug mode and no tracing verbosity is defined, compile all tracing */
// //////////////////////////////////////////////////////////////////////////////
// // Exceptions
// //////////////////////////////////////////////////////////////////////////////
/* * Get description for error code */
#[no_mangle]
pub unsafe extern "C" fn ecs_strerror(mut error_code: int32_t) -> *const libc::c_char {
	match error_code {
		1 => {
			return b"invalid handle\x00" as *const u8 as *const libc::c_char
		}
		2 => {
			return b"invalid parameters\x00" as *const u8 as
				*const libc::c_char
		}
		3 => {
			return b"invalid component id\x00" as *const u8 as
				*const libc::c_char
		}
		5 => {
			return b"invalid type expression\x00" as *const u8 as
				*const libc::c_char
		}
		6 => {
			return b"invalid system signature\x00" as *const u8 as
				*const libc::c_char
		}
		4 => {
			return b"invalid type expression/signature\x00" as *const u8 as
				*const libc::c_char
		}
		10 => {
			return b"missing system context\x00" as *const u8 as
				*const libc::c_char
		}
		7 => {
			return b"unknown component id\x00" as *const u8 as
				*const libc::c_char
		}
		8 => {
			return b"unknown type id\x00" as *const u8 as *const libc::c_char
		}
		9 => {
			return b"type contains more than one entity\x00" as *const u8 as
				*const libc::c_char
		}
		11 => {
			return b"handle is not a component\x00" as *const u8 as
				*const libc::c_char
		}
		12 => {
			return b"internal error\x00" as *const u8 as *const libc::c_char
		}
		13 => {
			return b"more than one prefab added to entity\x00" as *const u8 as
				*const libc::c_char
		}
		14 => {
			return b"entity has already been defined\x00" as *const u8 as
				*const libc::c_char
		}
		15 => {
			return b"the specified size does not match the component\x00" as
				*const u8 as *const libc::c_char
		}
		17 => {
			return b"out of memory\x00" as *const u8 as *const libc::c_char
		}
		18 => {
			return b"module is undefined\x00" as *const u8 as
				*const libc::c_char
		}
		19 => {
			return b"column index out of range\x00" as *const u8 as
				*const libc::c_char
		}
		20 => {
			return b"column is not shared\x00" as *const u8 as
				*const libc::c_char
		}
		21 => {
			return b"column is shared\x00" as *const u8 as *const libc::c_char
		}
		22 => {
			return b"column has no data\x00" as *const u8 as
				*const libc::c_char
		}
		23 => {
			return b"column retrieved with mismatching type\x00" as *const u8
				as *const libc::c_char
		}
		24 => {
			return b"operation is invalid while merging\x00" as *const u8 as
				*const libc::c_char
		}
		25 => {
			return b"operation is invalid while iterating\x00" as *const u8 as
				*const libc::c_char
		}
		26 => {
			return b"operation is invalid from worker thread\x00" as *const u8
				as *const libc::c_char
		}
		27 => {
			return b"unresolved identifier\x00" as *const u8 as
				*const libc::c_char
		}
		28 => {
			return b"index is out of range\x00" as *const u8 as
				*const libc::c_char
		}
		29 => {
			return b"column is not set (use ecs_column_test for optional columns)\x00"
				as *const u8 as *const libc::c_char
		}
		30 => {
			return b"unresolved reference for system\x00" as *const u8 as
				*const libc::c_char
		}
		31 => {
			return b"failed to create thread\x00" as *const u8 as
				*const libc::c_char
		}
		32 => {
			return b"missing implementation for OS API function\x00" as
				*const u8 as *const libc::c_char
		}
		33 => {
			return b"type contains too many entities\x00" as *const u8 as
				*const libc::c_char
		}
		34 => {
			return b"a prefab child type must have at least one INSTANCEOF element\x00"
				as *const u8 as *const libc::c_char
		}
		35 => {
			return b"operation is unsupported\x00" as *const u8 as
				*const libc::c_char
		}
		36 => {
			return b"on demand system has no out columns\x00" as *const u8 as
				*const libc::c_char
		}
		37 => {
			return b"invalid access to readonly column (use const)\x00" as
				*const u8 as *const libc::c_char
		}
		38 => {
			return b"serialized data contains conflicting component id\x00" as
				*const u8 as *const libc::c_char
		}
		39 => {
			return b"serialized data contains conflicting component size\x00"
				as *const u8 as *const libc::c_char
		}
		40 => {
			return b"serialized data has invalid format\x00" as *const u8 as
				*const libc::c_char
		}
		41 => {
			return b"signature is not valid for reactive system (must contain at least one ANY column)\x00"
				as *const u8 as *const libc::c_char
		}
		42 => {
			return b"component redefined with a different name\x00" as
				*const u8 as *const libc::c_char
		}
		43 => {
			return b"type constraint violated\x00" as *const u8 as
				*const libc::c_char
		}
		44 => {
			return b"component is not registered\x00" as *const u8 as
				*const libc::c_char
		}
		45 => {
			return b"component redefined with a different id\x00" as *const u8
				as *const libc::c_char
		}
		46 => {
			return b"case not supported for type\x00" as *const u8 as
				*const libc::c_char
		}
		47 => {
			return b"component name is already in use\x00" as *const u8 as
				*const libc::c_char
		}
		48 => {
			return b"entity redefined with different name\x00" as *const u8 as
				*const libc::c_char
		}
		49 => {
			return b"registered mismatching component action\x00" as *const u8
				as *const libc::c_char
		}
		50 => {
			return b"invalid operation\x00" as *const u8 as
				*const libc::c_char
		}
		_ => { }
	}
	return b"unknown error code\x00" as *const u8 as *const libc::c_char;
}
unsafe extern "C" fn init_data(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut result: *mut ecs_data_t,
) -> *mut ecs_data_t {
	let mut type_0: ecs_type_t = (*table).type_0;
	let mut i: int32_t = 0;
	let mut count: int32_t = (*table).column_count;
	let mut sw_count: int32_t = (*table).sw_column_count;
	(*result).entities = 0 as *mut ecs_vector_t;
	(*result).record_ptrs = 0 as *mut ecs_vector_t;
	/* Root tables don't have columns */
	if count == 0 && sw_count == 0 {
		(*result).columns = 0 as *mut ecs_column_t;
		return result;
	}
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	if count != 0 && sw_count == 0 {
		(*result).columns = ecs_os_api.calloc_.expect("non-null function pointer")(
			::std::mem::size_of::<ecs_column_t>() as libc::c_ulong as ecs_size_t * count,
		) as *mut ecs_column_t
	} else if count != 0 || sw_count != 0 {
		/* If a table has switch columns, store vector with the case values
		 * as a regular column, so it's easier to access for systems. To
		 * enable this, we need to allocate more space. */
		let mut type_count: int32_t = ecs_vector_count(type_0);
		(*result).columns = ecs_os_api.calloc_.expect("non-null function pointer")(
			::std::mem::size_of::<ecs_column_t>() as libc::c_ulong as ecs_size_t * type_count,
		) as *mut ecs_column_t
	}
	if count != 0 {
		i = 0 as libc::c_int;
		while i < count {
			let mut e: ecs_entity_t = *entities.offset(i as isize);
			/* Is the column a component? */
			let mut component: *const EcsComponent = ecs_component_from_id(world, e);
			if !component.is_null() {
				/* Is the component associated wit a (non-empty) type? */
				if (*component).size != 0 {
					/* This is a regular component column */
					(*(*result).columns.offset(i as isize)).size =
						ecs_to_i16((*component).size as int64_t);
					(*(*result).columns.offset(i as isize)).alignment =
						ecs_to_i16((*component).alignment as int64_t)
				}
			}
			i += 1
		}
	}
	if sw_count != 0 {
		let mut sw_offset: int32_t = (*table).sw_column_offset;
		(*result).sw_columns = ecs_os_api.calloc_.expect("non-null function pointer")(
			::std::mem::size_of::<ecs_sw_column_t>() as libc::c_ulong as ecs_size_t * sw_count,
		) as *mut ecs_sw_column_t;
		i = 0 as libc::c_int;
		while i < sw_count {
			let mut e_0: ecs_entity_t = *entities.offset((i + sw_offset) as isize);
			e_0 = e_0 & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			let mut type_ptr: *const EcsType =
				ecs_get_w_entity(world, e_0, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
			let mut sw_type: ecs_type_t = (*type_ptr).normalized;
			let mut sw_array: *mut ecs_entity_t = _ecs_vector_first(
				sw_type,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			let mut sw_array_count: int32_t = ecs_vector_count(sw_type);
			let mut sw: *mut ecs_switch_t = ecs_switch_new(
				*sw_array.offset(0 as libc::c_int as isize),
				*sw_array.offset((sw_array_count - 1 as libc::c_int) as isize),
				0 as libc::c_int,
			);
			let ref mut fresh0 = (*(*result).sw_columns.offset(i as isize)).data;
			*fresh0 = sw;
			let ref mut fresh1 = (*(*result).sw_columns.offset(i as isize)).type_0;
			*fresh1 = sw_type;
			let mut column_id: int32_t = i + (*table).sw_column_offset;
			let ref mut fresh2 = (*(*result).columns.offset(column_id as isize)).data;
			*fresh2 = ecs_switch_values(sw);
			(*(*result).columns.offset(column_id as isize)).size =
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as int16_t;
			(*(*result).columns.offset(column_id as isize)).alignment =
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t as int16_t;
			i += 1
		}
	}
	return result;
}
unsafe extern "C" fn get_component_action_flags(mut c_info: *mut ecs_c_info_t) -> ecs_flags32_t {
	let mut flags: ecs_flags32_t = 0 as libc::c_int as ecs_flags32_t;
	if (*c_info).lifecycle.ctor.is_some() {
		flags |= 128 as libc::c_uint
	}
	if (*c_info).lifecycle.dtor.is_some() {
		flags |= 256 as libc::c_uint
	}
	if (*c_info).lifecycle.copy.is_some() {
		flags |= 512 as libc::c_uint
	}
	if (*c_info).lifecycle.move_0.is_some() {
		flags |= 1024 as libc::c_uint
	}
	if !(*c_info).on_add.is_null() {
		flags |= 2048 as libc::c_uint
	}
	if !(*c_info).on_remove.is_null() {
		flags |= 4096 as libc::c_uint
	}
	return flags;
}
/* Check if table has instance of component, including traits */
unsafe extern "C" fn has_component(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut component: ecs_entity_t,
) -> bool {
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	i = 0 as libc::c_int;
	while i < count {
		if component == ecs_component_id_from_id(world, *entities.offset(i as isize)) {
			return 1 as libc::c_int != 0;
		}
		i += 1
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn notify_component_info(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut component: ecs_entity_t,
) {
	let mut table_type: ecs_type_t = (*table).type_0;
	if component == 0 || has_component(world, table_type, component) as libc::c_int != 0 {
		let mut column_count: int32_t = ecs_vector_count(table_type);
		if column_count == 0 {
			return;
		}
		if (*table).c_info.is_null() {
			(*table).c_info = ecs_os_api.calloc_.expect("non-null function pointer")(
				::std::mem::size_of::<*mut ecs_c_info_t>() as libc::c_ulong as ecs_size_t
					* column_count,
			) as *mut *mut ecs_c_info_t
		}
		/* Reset lifecycle flags before recomputing */
		(*table).flags &= !(128 as libc::c_uint | 256 as libc::c_uint);
		/* Recompute lifecycle flags */
		let mut array: *mut ecs_entity_t = _ecs_vector_first(
			table_type,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		let mut i: int32_t = 0;
		i = 0 as libc::c_int;
		while i < column_count {
			let mut c: ecs_entity_t = ecs_component_id_from_id(world, *array.offset(i as isize));
			if !(c == 0) {
				let mut c_info: *mut ecs_c_info_t = ecs_get_c_info(world, c);
				if !c_info.is_null() {
					let mut flags: ecs_flags32_t = get_component_action_flags(c_info);
					(*table).flags |= flags
				}
				/* Store pointer to c_info for fast access */
				let ref mut fresh3 = *(*table).c_info.offset(i as isize);
				*fresh3 = c_info
			}
			i += 1
		}
	};
}
unsafe extern "C" fn run_un_set_handlers(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
) {
	let mut count: int32_t = ecs_vector_count((*data).entities);
	if count != 0 {
		ecs_run_monitors(
			world,
			table,
			(*table).un_set_all,
			0 as libc::c_int,
			count,
			0 as *mut ecs_vector_t,
		);
	};
}
unsafe extern "C" fn compare_matched_query(
	mut ptr1: *const libc::c_void,
	mut ptr2: *const libc::c_void,
) -> libc::c_int {
	let mut m1: *const ecs_matched_query_t = ptr1 as *const ecs_matched_query_t;
	let mut m2: *const ecs_matched_query_t = ptr2 as *const ecs_matched_query_t;
	let mut q1: *mut ecs_query_t = (*m1).query;
	let mut q2: *mut ecs_query_t = (*m2).query;
	let mut s1: ecs_entity_t = (*q1).system;
	let mut s2: ecs_entity_t = (*q2).system;
	return (s1 > s2) as libc::c_int - (s1 < s2) as libc::c_int;
}
unsafe extern "C" fn add_monitor(
	mut array: *mut *mut ecs_vector_t,
	mut query: *mut ecs_query_t,
	mut matched_table_index: int32_t,
) {
	/* Add the system to a list that contains all OnSet systems matched with
	 * this table. This makes it easy to get the list of systems that need to be
	 * executed when all components are set, like when new_w_data is used */
	let mut m: *mut ecs_matched_query_t = _ecs_vector_add(
		array,
		::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_query_t;
	(*m).query = query;
	(*m).matched_table_index = matched_table_index;
	/* Sort the system list so that it is easy to get the difference OnSet
	 * OnSet systems between two tables. */
	qsort(
		_ecs_vector_first(
			*array,
			::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_query_t as *mut libc::c_void,
		ecs_to_size_t(ecs_vector_count(*array) as int64_t),
		::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t as size_t,
		Some(
			compare_matched_query
				as unsafe extern "C" fn(
					_: *const libc::c_void,
					_: *const libc::c_void,
				) -> libc::c_int,
		),
	);
}
/* This function is called when a query is matched with a table. A table keeps
 * a list of tables that match so that they can be notified when the table
 * becomes empty / non-empty. */
unsafe extern "C" fn register_monitor(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
	mut matched_table_index: int32_t,
) {
	/* First check if system is already registered as monitor. It is possible
	 * the query just wants to update the matched_table_index (for example, if
	 * query tables got reordered) */
	let mut m_i: libc::c_int = 0;
	let mut m_count: libc::c_int = ecs_vector_count((*table).monitors);
	let mut m_array: *mut ecs_matched_query_t = _ecs_vector_first(
		(*table).monitors,
		::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_query_t;
	m_i = 0 as libc::c_int;
	while m_i < m_count {
		let mut m: *mut ecs_matched_query_t =
			&mut *m_array.offset(m_i as isize) as *mut ecs_matched_query_t;
		if (*m).query == query {
			(*m).matched_table_index = matched_table_index;
			return;
		}
		m_i += 1
	}
	add_monitor(&mut (*table).monitors, query, matched_table_index);
}
unsafe extern "C" fn is_override(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut comp: ecs_entity_t,
) -> bool {
	if (*table).flags & 4 as libc::c_uint == 0 {
		return 0 as libc::c_int != 0;
	}
	let mut type_0: ecs_type_t = (*table).type_0;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = count - 1 as libc::c_int;
	while i >= 0 as libc::c_int {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			if ecs_has_entity(
				world,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
				comp,
			) {
				return 1 as libc::c_int != 0;
			}
		} else {
			/* ECS_INSTANCEOF will always appear at the end of a type */
			return 0 as libc::c_int != 0;
		}
		i -= 1
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn register_on_set(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
	mut matched_table_index: int32_t,
) {
	if (*table).column_count != 0 {
		if (*table).on_set.is_null() {
			(*table).on_set = ecs_os_api.calloc_.expect("non-null function pointer")(
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					* (*table).column_count,
			) as *mut *mut ecs_vector_t
		}
		/* Get the matched table which holds the list of actual components */
		let mut matched_table: *mut ecs_matched_table_t = _ecs_vector_get(
			(*query).tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
			matched_table_index,
		) as *mut ecs_matched_table_t;
		/* Keep track of whether query matches overrides. When a component is
		 * removed, diffing these arrays between the source and detination
		 * tables gives the list of OnSet systems to run, after exposing the
		 * component that was overridden. */
		let mut match_override: bool = 0 as libc::c_int != 0;
		/* Add system to each matched column. This makes it easy to get the list
		 * of systems when setting a single component. */
		let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
			(*query).sig.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*query).sig.columns);
		i = 0 as libc::c_int;
		while i < count {
			let mut column: *mut ecs_sig_column_t =
				&mut *columns.offset(i as isize) as *mut ecs_sig_column_t;
			let mut oper_kind: ecs_sig_oper_kind_t = (*column).oper_kind;
			let mut from_kind: ecs_sig_from_kind_t = (*column).from_kind;
			if !(from_kind as libc::c_uint != EcsFromAny as libc::c_int as libc::c_uint
				&& from_kind as libc::c_uint != EcsFromOwned as libc::c_int as libc::c_uint
				|| oper_kind as libc::c_uint != EcsOperAnd as libc::c_int as libc::c_uint
					&& oper_kind as libc::c_uint != EcsOperOptional as libc::c_int as libc::c_uint)
			{
				let mut comp: ecs_entity_t = *(*matched_table).data.components.offset(i as isize);
				let mut index: int32_t = ecs_type_index_of((*table).type_0, comp);
				if !(index == -(1 as libc::c_int)) {
					if !(index >= (*table).column_count) {
						let mut set_c: *mut ecs_vector_t = *(*table).on_set.offset(index as isize);
						let mut m: *mut ecs_matched_query_t = _ecs_vector_add(
							&mut set_c,
							::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong
								as ecs_size_t,
							if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long > ::std::mem::align_of::<ecs_matched_query_t>()
								as libc::c_ulong as int64_t
							{
								::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
									as libc::c_long
							} else {
								::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong
									as int64_t
							} as int16_t,
						) as *mut ecs_matched_query_t;
						(*m).query = query;
						(*m).matched_table_index = matched_table_index;
						let ref mut fresh4 = *(*table).on_set.offset(index as isize);
						*fresh4 = set_c;
						match_override |= is_override(world, table, comp);
					}
				}
			}
			i += 1
		}
		if match_override {
			add_monitor(&mut (*table).on_set_override, query, matched_table_index);
		}
	}
	add_monitor(&mut (*table).on_set_all, query, matched_table_index);
}
unsafe extern "C" fn register_un_set(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
	mut matched_table_index: int32_t,
) {
	add_monitor(&mut (*table).un_set_all, query, matched_table_index);
}
/* Activates / deactivates table for systems. A deactivated table will not be
 * evaluated when the system is invoked. Tables automatically get activated /
 * deactivated when they become non-empty / empty.
 *
 * If a query is provided, the table will only be activated / deactivated for
 * that query. */
/* -- Private functions -- */
/* If table goes from 0 to >0 entities or from >0 entities to 0 entities notify
 * queries. This allows systems associated with queries to move inactive tables
 * out of the main loop. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_activate(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
	mut activate: bool,
) {
	if !query.is_null() {
		ecs_query_notify(world, query, &mut {
			let mut init = ecs_query_event_t {
				kind: if activate as libc::c_int != 0 {
					EcsQueryTableNonEmpty as libc::c_int
				} else {
					EcsQueryTableEmpty as libc::c_int
				} as ecs_query_eventkind_t,
				table: table,
				parent_query: 0 as *mut ecs_query_t,
			};
			init
		});
	} else {
		let mut queries: *mut ecs_vector_t = (*table).queries;
		let mut buffer: *mut *mut ecs_query_t = _ecs_vector_first(
			queries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_query_t;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count(queries);
		i = 0 as libc::c_int;
		while i < count {
			ecs_query_notify(world, *buffer.offset(i as isize), &mut {
				let mut init = ecs_query_event_t {
					kind: if activate as libc::c_int != 0 {
						EcsQueryTableNonEmpty as libc::c_int
					} else {
						EcsQueryTableEmpty as libc::c_int
					} as ecs_query_eventkind_t,
					table: table,
					parent_query: 0 as *mut ecs_query_t,
				};
				init
			});
			i += 1
		}
	};
}
/* This function is called when a query is matched with a table. A table keeps
 * a list of tables that match so that they can be notified when the table
 * becomes empty / non-empty. */
unsafe extern "C" fn register_query(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
	mut matched_table_index: int32_t,
) {
	/* Register system with the table */
	if (*query).flags & (2 as libc::c_int | 4 as libc::c_int | 8 as libc::c_int) as libc::c_uint
		== 0
	{
		let mut q: *mut *mut ecs_query_t = _ecs_vector_add(
			&mut (*table).queries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_query_t;
		if !q.is_null() {
			*q = query
		}
		let mut data: *mut ecs_data_t = ecs_table_get_data(table);
		if !data.is_null() && ecs_vector_count((*data).entities) != 0 {
			ecs_table_activate(world, table, query, 1 as libc::c_int != 0);
		}
	}
	/* Register the query as a monitor */
	if (*query).flags & 2 as libc::c_int as libc::c_uint != 0 {
		(*table).flags |= 32768 as libc::c_uint;
		register_monitor(world, table, query, matched_table_index);
	}
	/* Register the query as an on_set system */
	if (*query).flags & 4 as libc::c_int as libc::c_uint != 0 {
		register_on_set(world, table, query, matched_table_index);
	}
	/* Register the query as an un_set system */
	if (*query).flags & 8 as libc::c_int as libc::c_uint != 0 {
		register_un_set(world, table, query, matched_table_index);
	};
}
/* This function is called when a query is unmatched with a table. This can
 * happen for queries that have shared components expressions in their signature
 * and those shared components changed (for example, a base removed a comp). */
unsafe extern "C" fn unregister_query(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
) {
	if (*query).flags & (2 as libc::c_int | 4 as libc::c_int | 8 as libc::c_int) as libc::c_uint
		== 0
	{
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*table).queries);
		i = 0 as libc::c_int;
		while i < count {
			let mut q: *mut *mut ecs_query_t = _ecs_vector_get(
				(*table).queries,
				::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
				} as int16_t,
				i,
			) as *mut *mut ecs_query_t;
			if *q == query {
				break;
			}
			i += 1
		}
		/* Query must have been registered with table */
		/* Remove query */
		_ecs_vector_remove_index(
			(*table).queries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
			i,
		);
	};
}
unsafe extern "C" fn get_data_intern(
	mut table: *mut ecs_table_t,
	mut create: bool,
) -> *mut ecs_data_t {
	let mut data: *mut ecs_data_t = (*table).data;
	if !data.is_null() {
		return data;
	}
	if data.is_null() && !create {
		return 0 as *mut ecs_data_t;
	}
	(*table).data = ecs_os_api.calloc_.expect("non-null function pointer")(::std::mem::size_of::<
		ecs_data_t,
	>() as libc::c_ulong
		as ecs_size_t) as *mut ecs_data_t;
	return (*table).data;
}
/* Get table data */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_get_data(mut table: *mut ecs_table_t) -> *mut ecs_data_t {
	return get_data_intern(table, 0 as libc::c_int != 0);
}
/* Get or create data */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_get_or_create_data(
	mut table: *mut ecs_table_t,
) -> *mut ecs_data_t {
	return get_data_intern(table, 1 as libc::c_int != 0);
}
unsafe extern "C" fn ctor_component(
	mut world: *mut ecs_world_t,
	mut cdata: *mut ecs_c_info_t,
	mut column: *mut ecs_column_t,
	mut entities: *mut ecs_entity_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	/* A new component is constructed */
	let mut ctor: ecs_xtor_t = None;
	if !cdata.is_null() && {
		ctor = (*cdata).lifecycle.ctor;
		ctor.is_some()
	} {
		let mut ctx: *mut libc::c_void = (*cdata).lifecycle.ctx;
		let mut size: int16_t = (*column).size;
		let mut alignment: int16_t = (*column).alignment;
		let mut ptr: *mut libc::c_void = _ecs_vector_get(
			(*column).data,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
			row,
		);
		ctor.expect("non-null function pointer")(
			world,
			(*cdata).component,
			entities,
			ptr,
			ecs_to_size_t(size as int64_t),
			count,
			ctx,
		);
	};
}
unsafe extern "C" fn dtor_component(
	mut world: *mut ecs_world_t,
	mut cdata: *mut ecs_c_info_t,
	mut column: *mut ecs_column_t,
	mut entities: *mut ecs_entity_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	/* An old component is destructed */
	let mut dtor: ecs_xtor_t = None;
	if !cdata.is_null() && {
		dtor = (*cdata).lifecycle.dtor;
		dtor.is_some()
	} {
		let mut ctx: *mut libc::c_void = (*cdata).lifecycle.ctx;
		let mut size: int16_t = (*column).size;
		let mut alignment: int16_t = (*column).alignment;
		let mut ptr: *mut libc::c_void = _ecs_vector_get(
			(*column).data,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
			row,
		);
		dtor.expect("non-null function pointer")(
			world,
			(*cdata).component,
			entities,
			ptr,
			ecs_to_size_t(size as int64_t),
			count,
			ctx,
		);
	};
}
unsafe extern "C" fn dtor_all_components(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut column_count: int32_t = (*table).column_count;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t =
			&mut *(*data).columns.offset(i as isize) as *mut ecs_column_t;
		dtor_component(
			world,
			*(*table).c_info.offset(i as isize),
			column,
			entities,
			row,
			count,
		);
		i += 1
	}
}
unsafe extern "C" fn run_remove_actions(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut dtor_only: bool,
) {
	if count != 0 {
		if !dtor_only {
			ecs_run_monitors(
				world,
				table,
				0 as *mut ecs_vector_t,
				row,
				count,
				(*table).un_set_all,
			);
		}
		dtor_all_components(world, table, data, row, count);
	};
}
/* Destruct columns */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_destruct(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	if (*table).flags & 256 as libc::c_uint != 0 {
		run_remove_actions(world, table, data, row, count, 1 as libc::c_int != 0);
	};
}
/* Clear table data. Don't call OnRemove handlers. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_clear_data(
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
) {
	if data.is_null() {
		return;
	}
	let mut columns: *mut ecs_column_t = (*data).columns;
	if !columns.is_null() {
		let mut c: int32_t = 0;
		let mut column_count: int32_t = (*table).column_count;
		c = 0 as libc::c_int;
		while c < column_count {
			ecs_vector_free((*columns.offset(c as isize)).data);
			c += 1
		}
		ecs_os_api.free_.expect("non-null function pointer")(columns as *mut libc::c_void);
		(*data).columns = 0 as *mut ecs_column_t
	}
	let mut sw_columns: *mut ecs_sw_column_t = (*data).sw_columns;
	if !sw_columns.is_null() {
		let mut c_0: int32_t = 0;
		let mut column_count_0: int32_t = (*table).sw_column_count;
		c_0 = 0 as libc::c_int;
		while c_0 < column_count_0 {
			ecs_switch_free((*sw_columns.offset(c_0 as isize)).data);
			c_0 += 1
		}
		ecs_os_api.free_.expect("non-null function pointer")(sw_columns as *mut libc::c_void);
		(*data).sw_columns = 0 as *mut ecs_sw_column_t
	}
	ecs_vector_free((*data).entities);
	ecs_vector_free((*data).record_ptrs);
	(*data).entities = 0 as *mut ecs_vector_t;
	(*data).record_ptrs = 0 as *mut ecs_vector_t;
}
/* Clear all entities from the table. Do not invoke OnRemove systems */
/* Clear columns. Deactivate table in systems if necessary, but do not invoke
 * OnRemove handlers. This is typically used when restoring a table to a
 * previous state. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_clear_silent(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
) {
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if data.is_null() {
		return;
	}
	let mut count: int32_t = ecs_vector_count((*data).entities);
	ecs_table_clear_data(table, (*table).data);
	if count != 0 {
		ecs_table_activate(world, table, 0 as *mut ecs_query_t, 0 as libc::c_int != 0);
	};
}
/* Clear all entities from a table. */
/* Delete all entities in table, invoke OnRemove handlers. This function is used
 * when an application invokes delete_w_filter. Use ecs_table_clear_silent, as
 * the table may have to be deactivated with systems. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_clear(mut world: *mut ecs_world_t, mut table: *mut ecs_table_t) {
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if !data.is_null() {
		run_remove_actions(
			world,
			table,
			data,
			0 as libc::c_int,
			ecs_table_data_count(data),
			0 as libc::c_int != 0,
		);
		let mut entities: *mut ecs_entity_t = _ecs_vector_first(
			(*data).entities,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*data).entities);
		i = 0 as libc::c_int;
		while i < count {
			ecs_sparse_remove((*world).store.entity_index, *entities.offset(i as isize));
			i += 1
		}
	}
	ecs_table_clear_silent(world, table);
}
/* Unset components in table */
/* Unset all components in table. This function is called before a table is
 * deleted, and invokes all UnSet handlers, if any */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_unset(mut world: *mut ecs_world_t, mut table: *mut ecs_table_t) {
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if !data.is_null() {
		run_un_set_handlers(world, table, data);
	};
}
/* Free table */
/* Free table resources. Do not invoke handlers and do not activate/deactivate
 * table with systems. This function is used when the world is freed. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_free(mut world: *mut ecs_world_t, mut table: *mut ecs_table_t) {
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if !data.is_null() {
		run_remove_actions(
			world,
			table,
			data,
			0 as libc::c_int,
			ecs_table_data_count(data),
			0 as libc::c_int != 0,
		);
	}
	ecs_table_clear_data(table, (*table).data);
	ecs_table_clear_edges(table);
	ecs_os_api.free_.expect("non-null function pointer")((*table).lo_edges as *mut libc::c_void);
	ecs_map_free((*table).hi_edges);
	ecs_vector_free((*table).queries);
	ecs_vector_free((*table).type_0 as *mut ecs_vector_t);
	ecs_os_api.free_.expect("non-null function pointer")((*table).dirty_state as *mut libc::c_void);
	ecs_vector_free((*table).monitors);
	ecs_vector_free((*table).on_set_all);
	ecs_vector_free((*table).on_set_override);
	ecs_vector_free((*table).un_set_all);
	if !(*table).c_info.is_null() {
		ecs_os_api.free_.expect("non-null function pointer")((*table).c_info as *mut libc::c_void);
	}
	if !(*table).on_set.is_null() {
		let mut i: int32_t = 0;
		i = 0 as libc::c_int;
		while i < (*table).column_count {
			ecs_vector_free(*(*table).on_set.offset(i as isize));
			i += 1
		}
		ecs_os_api.free_.expect("non-null function pointer")((*table).on_set as *mut libc::c_void);
	}
	(*table).id = 0 as libc::c_int as uint32_t;
	ecs_os_api.free_.expect("non-null function pointer")((*table).data as *mut libc::c_void);
}
/* Reset a table to its initial state */
/* Reset a table to its initial state. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_reset(mut world: *mut ecs_world_t, mut table: *mut ecs_table_t) {
	if !(*table).lo_edges.is_null() {
		memset(
			(*table).lo_edges as *mut libc::c_void,
			0 as libc::c_int,
			(::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t
				* 256 as libc::c_int) as libc::c_ulong,
		);
		ecs_map_clear((*table).hi_edges);
	};
}
unsafe extern "C" fn mark_table_dirty(mut table: *mut ecs_table_t, mut index: int32_t) {
	if !(*table).dirty_state.is_null() {
		let ref mut fresh5 = *(*table).dirty_state.offset(index as isize);
		*fresh5 += 1
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_mark_dirty_w_index(
	mut table: *mut ecs_table_t,
	mut index: int32_t,
) {
	mark_table_dirty(table, index);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_mark_dirty(
	mut table: *mut ecs_table_t,
	mut component: ecs_entity_t,
) {
	if !(*table).dirty_state.is_null() {
		let mut index: int32_t = ecs_type_index_of((*table).type_0, component);
		let ref mut fresh6 = *(*table).dirty_state.offset(index as isize);
		*fresh6 += 1
	};
}
unsafe extern "C" fn move_switch_columns(
	mut new_table: *mut ecs_table_t,
	mut new_data: *mut ecs_data_t,
	mut new_index_0: int32_t,
	mut old_table: *mut ecs_table_t,
	mut old_data: *mut ecs_data_t,
	mut old_index: int32_t,
	mut count: int32_t,
) {
	let mut i_old: int32_t = 0 as libc::c_int;
	let mut old_column_count: int32_t = (*old_table).sw_column_count;
	let mut i_new: int32_t = 0 as libc::c_int;
	let mut new_column_count: int32_t = (*new_table).sw_column_count;
	if old_column_count == 0 || new_column_count == 0 {
		return;
	}
	let mut old_columns: *mut ecs_sw_column_t = (*old_data).sw_columns;
	let mut new_columns: *mut ecs_sw_column_t = (*new_data).sw_columns;
	let mut new_type: ecs_type_t = (*new_table).type_0;
	let mut old_type: ecs_type_t = (*old_table).type_0;
	let mut offset_new: int32_t = (*new_table).sw_column_offset;
	let mut offset_old: int32_t = (*old_table).sw_column_offset;
	let mut new_components: *mut ecs_entity_t = _ecs_vector_first(
		new_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_components: *mut ecs_entity_t = _ecs_vector_first(
		old_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	while i_new < new_column_count && i_old < old_column_count {
		let mut new_component: ecs_entity_t = *new_components.offset((i_new + offset_new) as isize);
		let mut old_component: ecs_entity_t = *old_components.offset((i_old + offset_old) as isize);
		if new_component == old_component {
			let mut old_switch: *mut ecs_switch_t = (*old_columns.offset(i_old as isize)).data;
			let mut new_switch: *mut ecs_switch_t = (*new_columns.offset(i_new as isize)).data;
			ecs_switch_set_min_count(new_switch, new_index_0 + count);
			let mut i: libc::c_int = 0;
			i = 0 as libc::c_int;
			while i < count {
				let mut value: uint64_t = ecs_switch_get(old_switch, old_index + i);
				ecs_switch_set(new_switch, new_index_0 + i, value);
				i += 1
			}
		}
		i_new += (new_component <= old_component) as libc::c_int;
		i_old += (new_component >= old_component) as libc::c_int
	}
}
unsafe extern "C" fn ensure_data(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut column_count_out: *mut int32_t,
	mut sw_column_count_out: *mut int32_t,
	mut columns_out: *mut *mut ecs_column_t,
	mut sw_columns_out: *mut *mut ecs_sw_column_t,
) {
	let mut column_count: int32_t = (*table).column_count;
	let mut sw_column_count: int32_t = (*table).sw_column_count;
	let mut columns: *mut ecs_column_t = 0 as *mut ecs_column_t;
	let mut sw_columns: *mut ecs_sw_column_t = 0 as *mut ecs_sw_column_t;
	/* It is possible that the table data was created without content.
	 * Now that data is going to be written to the table, initialize */
	if column_count | sw_column_count != 0 {
		columns = (*data).columns;
		sw_columns = (*data).sw_columns;
		if columns.is_null() && sw_columns.is_null() {
			init_data(world, table, data);
			columns = (*data).columns;
			sw_columns = (*data).sw_columns
		}
		*column_count_out = column_count;
		*sw_column_count_out = sw_column_count;
		*columns_out = columns;
		*sw_columns_out = sw_columns
	};
}
unsafe extern "C" fn grow_column(
	mut world: *mut ecs_world_t,
	mut entities: *mut ecs_entity_t,
	mut column: *mut ecs_column_t,
	mut c_info: *mut ecs_c_info_t,
	mut to_add: int32_t,
	mut new_size: int32_t,
	mut construct: bool,
) {
	let mut vec: *mut ecs_vector_t = (*column).data;
	let mut alignment: int16_t = (*column).alignment;
	let mut size: int32_t = (*column).size as int32_t;
	let mut count: int32_t = ecs_vector_count(vec);
	let mut old_size: int32_t = ecs_vector_size(vec);
	let mut new_count: int32_t = count + to_add;
	let mut can_realloc: bool = new_size != old_size;
	/* If the array could possibly realloc and the component has a move action
	 * defined, move old elements manually */
	let mut move_0: ecs_move_t = None;
	if !c_info.is_null() && count != 0 && can_realloc as libc::c_int != 0 && {
		move_0 = (*c_info).lifecycle.move_0;
		move_0.is_some()
	} {
		let mut ctor: ecs_xtor_t = (*c_info).lifecycle.ctor;
		/* Create new vector */
		let mut new_vec: *mut ecs_vector_t = _ecs_vector_new(
			size,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
			new_size,
		);
		_ecs_vector_set_count(
			&mut new_vec,
			size,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
			new_count,
		);
		let mut old_buffer: *mut libc::c_void = _ecs_vector_first(
			vec,
			size,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
		);
		let mut new_buffer: *mut libc::c_void = _ecs_vector_first(
			new_vec,
			size,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
		);
		/* First construct elements (old and new) in new buffer */
		ctor.expect("non-null function pointer")(
			world,
			(*c_info).component,
			entities,
			new_buffer,
			ecs_to_size_t(size as int64_t),
			if construct as libc::c_int != 0 {
				new_count
			} else {
				count
			},
			(*c_info).lifecycle.ctx,
		);
		/* Move old elements */
		move_0.expect("non-null function pointer")(
			world,
			(*c_info).component,
			entities,
			entities,
			new_buffer,
			old_buffer,
			ecs_to_size_t(size as int64_t),
			count,
			(*c_info).lifecycle.ctx,
		);
		/* Free old vector */
		ecs_vector_free(vec);
		(*column).data = new_vec
	} else {
		/* If array won't realloc or has no move, simply add new elements */
		if can_realloc {
			_ecs_vector_set_size(
				&mut vec,
				size,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> alignment as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					alignment as libc::c_int
				} as int16_t,
				new_size,
			);
		}
		let mut elem: *mut libc::c_void = _ecs_vector_addn(
			&mut vec,
			size,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
			to_add,
		);
		let mut ctor_0: ecs_xtor_t = None;
		if construct as libc::c_int != 0 && !c_info.is_null() && {
			ctor_0 = (*c_info).lifecycle.ctor;
			ctor_0.is_some()
		} {
			/* If new elements need to be constructed and component has a
			 * constructor, construct */
			ctor_0.expect("non-null function pointer")(
				world,
				(*c_info).component,
				&mut *entities.offset(count as isize),
				elem,
				ecs_to_size_t(size as int64_t),
				to_add,
				(*c_info).lifecycle.ctx,
			);
		}
		(*column).data = vec
	};
}
unsafe extern "C" fn grow_data(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut to_add: int32_t,
	mut size: int32_t,
	mut ids: *const ecs_entity_t,
) -> int32_t {
	let mut cur_count: int32_t = ecs_table_data_count(data);
	let mut column_count: int32_t = (*table).column_count;
	let mut sw_column_count: int32_t = (*table).sw_column_count;
	let mut columns: *mut ecs_column_t = 0 as *mut ecs_column_t;
	let mut sw_columns: *mut ecs_sw_column_t = 0 as *mut ecs_sw_column_t;
	ensure_data(
		world,
		table,
		data,
		&mut column_count,
		&mut sw_column_count,
		&mut columns,
		&mut sw_columns,
	);
	/* Add record to record ptr array */
	_ecs_vector_set_size(
		&mut (*data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
		size,
	);
	let mut r: *mut *mut ecs_record_t = _ecs_vector_addn(
		&mut (*data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
		to_add,
	) as *mut *mut ecs_record_t;
	if ecs_vector_size((*data).record_ptrs) > size {
		size = ecs_vector_size((*data).record_ptrs)
	}
	/* Add entity to column with entity ids */
	_ecs_vector_set_size(
		&mut (*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		size,
	);
	let mut e: *mut ecs_entity_t = _ecs_vector_addn(
		&mut (*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		to_add,
	) as *mut ecs_entity_t;
	/* Initialize entity ids and record ptrs */
	let mut i: int32_t = 0;
	if !ids.is_null() {
		i = 0 as libc::c_int;
		while i < to_add {
			*e.offset(i as isize) = *ids.offset(i as isize);
			i += 1
		}
	} else {
		memset(
			e as *mut libc::c_void,
			0 as libc::c_int,
			(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * to_add)
				as size_t,
		);
	}
	memset(
		r as *mut libc::c_void,
		0 as libc::c_int,
		(::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t * to_add)
			as size_t,
	);
	/* Add elements to each column array */
	let mut c_info_array: *mut *mut ecs_c_info_t = (*table).c_info;
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(i as isize) as *mut ecs_column_t;
		if !((*column).size == 0) {
			let mut c_info: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
			if !c_info_array.is_null() {
				c_info = *c_info_array.offset(i as isize)
			}
			grow_column(
				world,
				entities,
				column,
				c_info,
				to_add,
				size,
				1 as libc::c_int != 0,
			);
		}
		i += 1
	}
	/* Add elements to each switch column */
	i = 0 as libc::c_int;
	while i < sw_column_count {
		let mut sw: *mut ecs_switch_t = (*sw_columns.offset(i as isize)).data;
		ecs_switch_addn(sw, to_add);
		i += 1
	}
	/* If the table is monitored indicate that there has been a change */
	mark_table_dirty(table, 0 as libc::c_int);
	if !(*world).in_progress && cur_count == 0 {
		ecs_table_activate(world, table, 0 as *mut ecs_query_t, 1 as libc::c_int != 0);
	}
	(*table).alloc_count += 1;
	/* Return index of first added entity */
	return cur_count;
}
unsafe extern "C" fn fast_append(mut columns: *mut ecs_column_t, mut column_count: int32_t) {
	/* Add elements to each column array */
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(i as isize) as *mut ecs_column_t;
		let mut size: int16_t = (*column).size;
		if size != 0 {
			let mut alignment: int16_t = (*column).alignment;
			_ecs_vector_add(
				&mut (*column).data,
				size as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> alignment as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					alignment as libc::c_int
				} as int16_t,
			);
		}
		i += 1
	}
}
/* Add a new entry to the table for the specified entity */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_append(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut entity: ecs_entity_t,
	mut record: *mut ecs_record_t,
	mut construct: bool,
) -> int32_t {
	/* Get count & size before growing entities array. This tells us whether the
	 * arrays will realloc */
	let mut count: int32_t = ecs_vector_count((*data).entities);
	let mut size: int32_t = ecs_vector_size((*data).entities);
	let mut column_count: int32_t = (*table).column_count;
	let mut sw_column_count: int32_t = (*table).sw_column_count;
	let mut columns: *mut ecs_column_t = 0 as *mut ecs_column_t;
	let mut sw_columns: *mut ecs_sw_column_t = 0 as *mut ecs_sw_column_t;
	ensure_data(
		world,
		table,
		data,
		&mut column_count,
		&mut sw_column_count,
		&mut columns,
		&mut sw_columns,
	);
	/* Grow buffer with entity ids, set new element to new entity */
	let mut e: *mut ecs_entity_t = _ecs_vector_add(
		&mut (*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	*e = entity;
	/* Keep track of alloc count. This allows references to check if cached
	 * pointers need to be updated. */
	(*table).alloc_count += (count == size) as libc::c_int;
	/* Add record ptr to array with record ptrs */
	let mut r: *mut *mut ecs_record_t = _ecs_vector_add(
		&mut (*data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_record_t;
	*r = record;
	/* If the table is monitored indicate that there has been a change */
	mark_table_dirty(table, 0 as libc::c_int);
	/* If this is the first entity in this table, signal queries so that the
	 * table moves from an inactive table to an active table. */
	if !(*world).in_progress && count == 0 {
		ecs_table_activate(world, table, 0 as *mut ecs_query_t, 1 as libc::c_int != 0);
	}
	/* Fast path: no switch columns, no lifecycle actions */
	if (*table).flags & (128 as libc::c_uint | 256 as libc::c_uint | 65536 as libc::c_uint) == 0 {
		fast_append(columns, column_count);
		return count;
	}
	let mut c_info_array: *mut *mut ecs_c_info_t = (*table).c_info;
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	/* Reobtain size to ensure that the columns have the same size as the
	 * entities and record vectors. This keeps reasoning about when allocations
	 * occur easier. */
	size = ecs_vector_size((*data).entities);
	/* Grow component arrays with 1 element */
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(i as isize) as *mut ecs_column_t;
		if !((*column).size == 0) {
			let mut c_info: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
			if !c_info_array.is_null() {
				c_info = *c_info_array.offset(i as isize)
			}
			grow_column(
				world,
				entities,
				column,
				c_info,
				1 as libc::c_int,
				size,
				construct,
			);
		}
		i += 1
	}
	/* Add element to each switch column */
	i = 0 as libc::c_int;
	while i < sw_column_count {
		let mut sw: *mut ecs_switch_t = (*sw_columns.offset(i as isize)).data;
		ecs_switch_add(sw);
		let ref mut fresh7 = (*columns.offset((i + (*table).sw_column_offset) as isize)).data;
		*fresh7 = ecs_switch_values(sw);
		i += 1
	}
	return count;
}
unsafe extern "C" fn fast_delete_last(mut columns: *mut ecs_column_t, mut column_count: int32_t) {
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(i as isize) as *mut ecs_column_t;
		ecs_vector_remove_last((*column).data);
		i += 1
	}
}
unsafe extern "C" fn fast_delete(
	mut columns: *mut ecs_column_t,
	mut column_count: int32_t,
	mut index: int32_t,
) {
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(i as isize) as *mut ecs_column_t;
		let mut size: int16_t = (*column).size;
		if size != 0 {
			let mut alignment: int16_t = (*column).alignment;
			_ecs_vector_remove_index(
				(*column).data,
				size as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> alignment as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					alignment as libc::c_int
				} as int16_t,
				index,
			);
		}
		i += 1
	}
}
/* Delete an entity from the table. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_delete(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut index: int32_t,
	mut destruct: bool,
) {
	let mut entity_column: *mut ecs_vector_t = (*data).entities;
	let mut count: int32_t = ecs_vector_count(entity_column);
	count -= 1;
	let mut c_info_array: *mut *mut ecs_c_info_t = (*table).c_info;
	let mut column_count: int32_t = (*table).column_count;
	let mut i: int32_t = 0;
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		entity_column,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut entity_to_move: ecs_entity_t = *entities.offset(count as isize);
	/* Move last entity id to index */
	*entities.offset(index as isize) = entity_to_move;
	ecs_vector_remove_last(entity_column);
	/* Move last record ptr to index */
	let mut record_column: *mut ecs_vector_t = (*data).record_ptrs;
	let mut records: *mut *mut ecs_record_t = _ecs_vector_first(
		record_column,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_record_t;
	let mut record_to_move: *mut ecs_record_t = *records.offset(count as isize);
	let ref mut fresh8 = *records.offset(index as isize);
	*fresh8 = record_to_move;
	ecs_vector_remove_last(record_column);
	/* Update record of moved entity in entity index */
	if index != count {
		if !record_to_move.is_null() {
			if (*record_to_move).row >= 0 as libc::c_int {
				(*record_to_move).row = index + 1 as libc::c_int
			} else {
				(*record_to_move).row = -(index + 1 as libc::c_int)
			}
		}
	}
	/* If the table is monitored indicate that there has been a change */
	mark_table_dirty(table, 0 as libc::c_int);
	if count == 0 {
		ecs_table_activate(world, table, 0 as *mut ecs_query_t, 0 as libc::c_int != 0);
	}
	/* Move each component value in array to index */
	let mut columns: *mut ecs_column_t = (*data).columns;
	if (*table).flags & (128 as libc::c_uint | 256 as libc::c_uint | 65536 as libc::c_uint) == 0 {
		if index == count {
			fast_delete_last(columns, column_count);
		} else {
			fast_delete(columns, column_count, index);
		}
		return;
	}
	i = 0 as libc::c_int;
	while i < column_count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(i as isize) as *mut ecs_column_t;
		let mut size: int16_t = (*column).size;
		let mut alignment: int16_t = (*column).alignment;
		if size != 0 {
			let mut c_info: *mut ecs_c_info_t = if !c_info_array.is_null() {
				*c_info_array.offset(i as isize)
			} else {
				0 as *mut ecs_c_info_t
			};
			let mut dtor: ecs_xtor_t = None;
			let mut dst: *mut libc::c_void = _ecs_vector_get(
				(*column).data,
				size as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> alignment as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					alignment as libc::c_int
				} as int16_t,
				index,
			);
			let mut move_0: ecs_move_t = None;
			if !c_info.is_null() && count != index && {
				move_0 = (*c_info).lifecycle.move_0;
				move_0.is_some()
			} {
				let mut ctx: *mut libc::c_void = (*c_info).lifecycle.ctx;
				let mut src: *mut libc::c_void = _ecs_vector_get(
					(*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					count,
				);
				let mut component: ecs_entity_t = (*c_info).component;
				/* If the delete is not destructing the component, the component
				 * was already deleted, most likely by a move. In that case we
				 * still need to move, but we need to make sure we're moving
				 * into an element that is initialized with valid memory, so
				 * call the constructor. */
				if !destruct {
					let mut ctor: ecs_xtor_t = (*c_info).lifecycle.ctor;
					ctor.expect("non-null function pointer")(
						world,
						(*c_info).component,
						&mut entity_to_move,
						dst,
						ecs_to_size_t(size as int64_t),
						1 as libc::c_int,
						(*c_info).lifecycle.ctx,
					);
				}
				/* Move last element into deleted element */
				move_0.expect("non-null function pointer")(
					world,
					component,
					&mut entity_to_move,
					&mut entity_to_move,
					dst,
					src,
					ecs_to_size_t(size as int64_t),
					1 as libc::c_int,
					ctx,
				);
				/* Memory has been copied, we can now simply remove last */
				ecs_vector_remove_last((*column).data);
			} else {
				if destruct as libc::c_int != 0 && !c_info.is_null() && {
					dtor = (*c_info).lifecycle.dtor;
					dtor.is_some()
				} {
					dtor.expect("non-null function pointer")(
						world,
						(*c_info).component,
						&mut *entities.offset(index as isize),
						dst,
						ecs_to_size_t(size as int64_t),
						1 as libc::c_int,
						(*c_info).lifecycle.ctx,
					);
				}
				_ecs_vector_remove_index(
					(*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					index,
				);
			}
		}
		i += 1
	}
	/* Remove elements from switch columns */
	let mut sw_columns: *mut ecs_sw_column_t = (*data).sw_columns;
	let mut sw_column_count: int32_t = (*table).sw_column_count;
	i = 0 as libc::c_int;
	while i < sw_column_count {
		ecs_switch_remove((*sw_columns.offset(i as isize)).data, index);
		i += 1
	}
}
unsafe extern "C" fn fast_move(
	mut new_table: *mut ecs_table_t,
	mut new_data: *mut ecs_data_t,
	mut new_index_0: int32_t,
	mut old_table: *mut ecs_table_t,
	mut old_data: *mut ecs_data_t,
	mut old_index: int32_t,
) {
	let mut new_type: ecs_type_t = (*new_table).type_0;
	let mut old_type: ecs_type_t = (*old_table).type_0;
	let mut i_new: int32_t = 0 as libc::c_int;
	let mut new_column_count: int32_t = (*new_table).column_count;
	let mut i_old: int32_t = 0 as libc::c_int;
	let mut old_column_count: int32_t = (*old_table).column_count;
	let mut new_components: *mut ecs_entity_t = _ecs_vector_first(
		new_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_components: *mut ecs_entity_t = _ecs_vector_first(
		old_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_columns: *mut ecs_column_t = (*old_data).columns;
	let mut new_columns: *mut ecs_column_t = (*new_data).columns;
	while i_new < new_column_count && i_old < old_column_count {
		let mut new_component: ecs_entity_t = *new_components.offset(i_new as isize);
		let mut old_component: ecs_entity_t = *old_components.offset(i_old as isize);
		if new_component == old_component {
			let mut new_column: *mut ecs_column_t =
				&mut *new_columns.offset(i_new as isize) as *mut ecs_column_t;
			let mut old_column: *mut ecs_column_t =
				&mut *old_columns.offset(i_old as isize) as *mut ecs_column_t;
			let mut size: int16_t = (*new_column).size;
			if size != 0 {
				let mut alignment: int16_t = (*new_column).alignment;
				let mut dst: *mut libc::c_void = _ecs_vector_get(
					(*new_column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					new_index_0,
				);
				let mut src: *mut libc::c_void = _ecs_vector_get(
					(*old_column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					old_index,
				);
				memcpy(dst, src, size as size_t);
			}
		}
		i_new += (new_component <= old_component) as libc::c_int;
		i_old += (new_component >= old_component) as libc::c_int
	}
}
/* Move a row from one table to another */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_move(
	mut world: *mut ecs_world_t,
	mut dst_entity: ecs_entity_t,
	mut src_entity: ecs_entity_t,
	mut new_table: *mut ecs_table_t,
	mut new_data: *mut ecs_data_t,
	mut new_index_0: int32_t,
	mut old_table: *mut ecs_table_t,
	mut old_data: *mut ecs_data_t,
	mut old_index: int32_t,
) {
	if ((*new_table).flags | (*old_table).flags)
		& (128 as libc::c_uint | 256 as libc::c_uint | 65536 as libc::c_uint)
		== 0
	{
		fast_move(
			new_table,
			new_data,
			new_index_0,
			old_table,
			old_data,
			old_index,
		);
		return;
	}
	move_switch_columns(
		new_table,
		new_data,
		new_index_0,
		old_table,
		old_data,
		old_index,
		1 as libc::c_int,
	);
	let mut same_entity: bool = dst_entity == src_entity;
	let mut new_type: ecs_type_t = (*new_table).type_0;
	let mut old_type: ecs_type_t = (*old_table).type_0;
	let mut i_new: int32_t = 0 as libc::c_int;
	let mut new_column_count: int32_t = (*new_table).column_count;
	let mut i_old: int32_t = 0 as libc::c_int;
	let mut old_column_count: int32_t = (*old_table).column_count;
	let mut new_components: *mut ecs_entity_t = _ecs_vector_first(
		new_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_components: *mut ecs_entity_t = _ecs_vector_first(
		old_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_columns: *mut ecs_column_t = (*old_data).columns;
	let mut new_columns: *mut ecs_column_t = (*new_data).columns;
	while i_new < new_column_count && i_old < old_column_count {
		let mut new_component: ecs_entity_t = *new_components.offset(i_new as isize);
		let mut old_component: ecs_entity_t = *old_components.offset(i_old as isize);
		if new_component == old_component {
			let mut new_column: *mut ecs_column_t =
				&mut *new_columns.offset(i_new as isize) as *mut ecs_column_t;
			let mut old_column: *mut ecs_column_t =
				&mut *old_columns.offset(i_old as isize) as *mut ecs_column_t;
			let mut size: int16_t = (*new_column).size;
			let mut alignment: int16_t = (*new_column).alignment;
			if size != 0 {
				let mut dst: *mut libc::c_void = _ecs_vector_get(
					(*new_column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					new_index_0,
				);
				let mut src: *mut libc::c_void = _ecs_vector_get(
					(*old_column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					old_index,
				);
				let mut cdata: *mut ecs_c_info_t = *(*new_table).c_info.offset(i_new as isize);
				if same_entity {
					let mut move_0: ecs_move_t = None;
					if !cdata.is_null() && {
						move_0 = (*cdata).lifecycle.move_0;
						move_0.is_some()
					} {
						let mut ctx: *mut libc::c_void = (*cdata).lifecycle.ctx;
						let mut ctor: ecs_xtor_t = (*cdata).lifecycle.ctor;
						/* Ctor should always be set if copy is set */
						/* Construct a new value, move the value to it */
						ctor.expect("non-null function pointer")(
							world,
							new_component,
							&mut dst_entity,
							dst,
							ecs_to_size_t(size as int64_t),
							1 as libc::c_int,
							ctx,
						);
						move_0.expect("non-null function pointer")(
							world,
							new_component,
							&mut dst_entity,
							&mut src_entity,
							dst,
							src,
							ecs_to_size_t(size as int64_t),
							1 as libc::c_int,
							ctx,
						);
					} else {
						memcpy(dst, src, size as size_t);
					}
				} else {
					let mut copy: ecs_copy_t = None;
					if !cdata.is_null() && {
						copy = (*cdata).lifecycle.copy;
						copy.is_some()
					} {
						let mut ctx_0: *mut libc::c_void = (*cdata).lifecycle.ctx;
						let mut ctor_0: ecs_xtor_t = (*cdata).lifecycle.ctor;
						/* Ctor should always be set if copy is set */
						ctor_0.expect("non-null function pointer")(
							world,
							new_component,
							&mut dst_entity,
							dst,
							ecs_to_size_t(size as int64_t),
							1 as libc::c_int,
							ctx_0,
						);
						copy.expect("non-null function pointer")(
							world,
							new_component,
							&mut dst_entity,
							&mut src_entity,
							dst,
							src,
							ecs_to_size_t(size as int64_t),
							1 as libc::c_int,
							ctx_0,
						);
					} else {
						memcpy(dst, src, size as size_t);
					}
				}
			}
		} else if new_component < old_component {
			ctor_component(
				world,
				*(*new_table).c_info.offset(i_new as isize),
				&mut *new_columns.offset(i_new as isize),
				&mut dst_entity,
				new_index_0,
				1 as libc::c_int,
			);
		} else {
			dtor_component(
				world,
				*(*old_table).c_info.offset(i_old as isize),
				&mut *old_columns.offset(i_old as isize),
				&mut src_entity,
				old_index,
				1 as libc::c_int,
			);
		}
		i_new += (new_component <= old_component) as libc::c_int;
		i_old += (new_component >= old_component) as libc::c_int
	}
	while i_new < new_column_count {
		ctor_component(
			world,
			*(*new_table).c_info.offset(i_new as isize),
			&mut *new_columns.offset(i_new as isize),
			&mut dst_entity,
			new_index_0,
			1 as libc::c_int,
		);
		i_new += 1
	}
	while i_old < old_column_count {
		dtor_component(
			world,
			*(*old_table).c_info.offset(i_old as isize),
			&mut *old_columns.offset(i_old as isize),
			&mut src_entity,
			old_index,
			1 as libc::c_int,
		);
		i_old += 1
	}
}
/* Grow table with specified number of records. Populate table with entities,
 * starting from specified entity id. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_appendn(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut to_add: int32_t,
	mut ids: *const ecs_entity_t,
) -> int32_t {
	let mut cur_count: int32_t = ecs_table_data_count(data);
	return grow_data(world, table, data, to_add, cur_count + to_add, ids);
}
/* Set table to a fixed size. Useful for preallocating memory in advance. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_set_size(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut size: int32_t,
) {
	let mut cur_count: int32_t = ecs_table_data_count(data);
	if cur_count < size {
		grow_data(
			world,
			table,
			data,
			0 as libc::c_int,
			size,
			0 as *const ecs_entity_t,
		);
	} else if size == 0 {
		/* Initialize columns if 0 is passed. This is a shortcut to initialize
		 * columns when, for example, an API call is inserting bulk data. */
		let mut column_count: int32_t = (*table).column_count;
		let mut sw_column_count: int32_t = (*table).sw_column_count;
		let mut columns: *mut ecs_column_t = 0 as *mut ecs_column_t;
		let mut sw_columns: *mut ecs_sw_column_t = 0 as *mut ecs_sw_column_t;
		ensure_data(
			world,
			table,
			data,
			&mut column_count,
			&mut sw_column_count,
			&mut columns,
			&mut sw_columns,
		);
	};
}
/* Set table to a fixed count. Useful for copying data in bulk. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_set_count(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut count: int32_t,
) {
	let mut cur_count: int32_t = ecs_table_data_count(data);
	if cur_count < count {
		grow_data(
			world,
			table,
			data,
			count - cur_count,
			count,
			0 as *const ecs_entity_t,
		);
	};
}
/* Return number of entities in data */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_data_count(mut data: *mut ecs_data_t) -> int32_t {
	return if !data.is_null() {
		ecs_vector_count((*data).entities)
	} else {
		0 as libc::c_int
	};
}
/* Return number of entities in table. */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_count(mut table: *mut ecs_table_t) -> int32_t {
	let mut data: *mut ecs_data_t = (*table).data;
	if data.is_null() {
		return 0 as libc::c_int;
	}
	return ecs_table_data_count(data);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_swap(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row_1: int32_t,
	mut row_2: int32_t,
) {
	let mut columns: *mut ecs_column_t = (*data).columns;
	if row_1 == row_2 {
		return;
	}
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut e1: ecs_entity_t = *entities.offset(row_1 as isize);
	let mut e2: ecs_entity_t = *entities.offset(row_2 as isize);
	let mut record_ptrs: *mut *mut ecs_record_t = _ecs_vector_first(
		(*data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_record_t;
	let mut record_ptr_1: *mut ecs_record_t = *record_ptrs.offset(row_1 as isize);
	let mut record_ptr_2: *mut ecs_record_t = *record_ptrs.offset(row_2 as isize);
	/* Get pointers to records in entity index */
	if record_ptr_1.is_null() {
		record_ptr_1 = _ecs_sparse_get_sparse(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			e1,
		) as *mut ecs_record_t
	}
	if record_ptr_2.is_null() {
		record_ptr_2 = _ecs_sparse_get_sparse(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			e2,
		) as *mut ecs_record_t
	}
	/* Swap entities */
	*entities.offset(row_1 as isize) = e2;
	*entities.offset(row_2 as isize) = e1;
	(*record_ptr_1).row = row_2;
	(*record_ptr_2).row = row_1;
	let ref mut fresh9 = *record_ptrs.offset(row_1 as isize);
	*fresh9 = record_ptr_2;
	let ref mut fresh10 = *record_ptrs.offset(row_2 as isize);
	*fresh10 = record_ptr_1;
	if row_2 < 0 as libc::c_int {
		(*record_ptr_1).row -= 1
	} else {
		(*record_ptr_1).row += 1
	}
	if row_1 < 0 as libc::c_int {
		(*record_ptr_2).row -= 1
	} else {
		(*record_ptr_2).row += 1
	}
	/* Swap columns */
	let mut i: int32_t = 0;
	let mut column_count: int32_t = (*table).column_count;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut size: int16_t = (*columns.offset(i as isize)).size;
		let mut alignment: int16_t = (*columns.offset(i as isize)).alignment;
		let mut ptr: *mut libc::c_void = _ecs_vector_first(
			(*columns.offset(i as isize)).data,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
		);
		if size != 0 {
			let mut fresh11 = ::std::vec::from_elem(0, size as size_t as usize);
			let mut tmp: *mut libc::c_void = fresh11.as_mut_ptr() as *mut libc::c_void;
			let mut el_1: *mut libc::c_void = (ptr as uintptr_t)
				.wrapping_add((size as libc::c_int * row_1) as uintptr_t)
				as *mut libc::c_void;
			let mut el_2: *mut libc::c_void = (ptr as uintptr_t)
				.wrapping_add((size as libc::c_int * row_2) as uintptr_t)
				as *mut libc::c_void;
			memcpy(tmp, el_1, size as size_t);
			memcpy(el_1, el_2, size as size_t);
			memcpy(el_2, tmp, size as size_t);
		}
		i += 1
	}
	/* If the table is monitored indicate that there has been a change */
	mark_table_dirty(table, 0 as libc::c_int);
}
unsafe extern "C" fn merge_vector(
	mut dst_out: *mut *mut ecs_vector_t,
	mut src: *mut ecs_vector_t,
	mut size: int16_t,
	mut alignment: int16_t,
) {
	let mut dst: *mut ecs_vector_t = *dst_out;
	let mut dst_count: int32_t = ecs_vector_count(dst);
	if dst_count == 0 {
		if !dst.is_null() {
			ecs_vector_free(dst);
		}
		*dst_out = src
	/* If the new table is not empty, copy the contents from the
	 * src into the dst. */
	} else {
		let mut src_count: int32_t = ecs_vector_count(src);
		_ecs_vector_set_count(
			&mut dst,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
			dst_count + src_count,
		);
		let mut dst_ptr: *mut libc::c_void = _ecs_vector_first(
			dst,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
		);
		let mut src_ptr: *mut libc::c_void = _ecs_vector_first(
			src,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				alignment as libc::c_int
			} as int16_t,
		);
		dst_ptr = (dst_ptr as uintptr_t)
			.wrapping_add((size as libc::c_int * dst_count) as uintptr_t)
			as *mut libc::c_void;
		memcpy(
			dst_ptr,
			src_ptr,
			(size as libc::c_int * src_count) as size_t,
		);
		ecs_vector_free(src);
		*dst_out = dst
	};
}
unsafe extern "C" fn merge_table_data(
	mut world: *mut ecs_world_t,
	mut new_table: *mut ecs_table_t,
	mut old_table: *mut ecs_table_t,
	mut old_count: int32_t,
	mut new_count: int32_t,
	mut old_data: *mut ecs_data_t,
	mut new_data: *mut ecs_data_t,
) {
	let mut i_new: int32_t = 0;
	let mut new_component_count: int32_t = (*new_table).column_count;
	let mut i_old: int32_t = 0 as libc::c_int;
	let mut old_component_count: int32_t = (*old_table).column_count;
	let mut new_components: *mut ecs_entity_t = _ecs_vector_first(
		(*new_table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_components: *mut ecs_entity_t = _ecs_vector_first(
		(*old_table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_columns: *mut ecs_column_t = (*old_data).columns;
	let mut new_columns: *mut ecs_column_t = (*new_data).columns;
	if new_columns.is_null() && (*new_data).entities.is_null() {
		init_data(world, new_table, new_data);
		new_columns = (*new_data).columns
	}
	if old_count == 0 {
		return;
	}
	/* Merge entities */
	merge_vector(
		&mut (*new_data).entities,
		(*old_data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t as int16_t,
		::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t as int16_t,
	);
	(*old_data).entities = 0 as *mut ecs_vector_t;
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*new_data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	/* Merge entity index record pointers */
	merge_vector(
		&mut (*new_data).record_ptrs,
		(*old_data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t as int16_t,
		::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t as int16_t,
	);
	(*old_data).record_ptrs = 0 as *mut ecs_vector_t;
	i_new = 0 as libc::c_int;
	while i_new < new_component_count && i_old < old_component_count {
		let mut new_component: ecs_entity_t = *new_components.offset(i_new as isize);
		let mut old_component: ecs_entity_t = *old_components.offset(i_old as isize);
		let mut size: int16_t = (*new_columns.offset(i_new as isize)).size;
		let mut alignment: int16_t = (*new_columns.offset(i_new as isize)).alignment;
		if new_component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int != 0
			|| old_component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int != 0
		{
			break;
		}
		if new_component == old_component {
			merge_vector(
				&mut (*new_columns.offset(i_new as isize)).data,
				(*old_columns.offset(i_old as isize)).data,
				size,
				alignment,
			);
			let ref mut fresh12 = (*old_columns.offset(i_old as isize)).data;
			*fresh12 = 0 as *mut ecs_vector_t;
			/* Mark component column as dirty */
			mark_table_dirty(new_table, i_new + 1 as libc::c_int);
			i_new += 1;
			i_old += 1
		} else if new_component < old_component {
			/* New column does not occur in old table, make sure vector is large
			 * enough. */
			if size != 0 {
				let mut column: *mut ecs_column_t =
					&mut *new_columns.offset(i_new as isize) as *mut ecs_column_t;
				_ecs_vector_set_count(
					&mut (*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					old_count + new_count,
				);
				/* Construct new values */
				let mut c_info: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
				let mut ctor: ecs_xtor_t = None;
				c_info = *(*new_table).c_info.offset(i_new as isize);
				if !c_info.is_null() && {
					ctor = (*c_info).lifecycle.ctor;
					ctor.is_some()
				} {
					ctor_component(
						world,
						c_info,
						column,
						entities,
						0 as libc::c_int,
						old_count + new_count,
					);
				}
			}
			i_new += 1
		} else if new_component > old_component {
			if size != 0 {
				let mut column_0: *mut ecs_column_t =
					&mut *old_columns.offset(i_old as isize) as *mut ecs_column_t;
				/* Destruct old values */
				let mut c_info_0: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
				let mut dtor: ecs_xtor_t = None;
				c_info_0 = *(*old_table).c_info.offset(i_old as isize);
				if !c_info_0.is_null() && {
					dtor = (*c_info_0).lifecycle.dtor;
					dtor.is_some()
				} {
					dtor_component(
						world,
						c_info_0,
						column_0,
						entities,
						0 as libc::c_int,
						old_count,
					);
				}
				/* Old column does not occur in new table, remove */
				ecs_vector_free((*column_0).data);
				(*column_0).data = 0 as *mut ecs_vector_t;
				i_old += 1
			}
		}
	}
	move_switch_columns(
		new_table,
		new_data,
		new_count,
		old_table,
		old_data,
		0 as libc::c_int,
		old_count,
	);
	/* Initialize remaining columns */
	while i_new < new_component_count {
		let mut column_1: *mut ecs_column_t =
			&mut *new_columns.offset(i_new as isize) as *mut ecs_column_t;
		let mut size_0: int16_t = (*column_1).size;
		let mut alignment_0: int16_t = (*column_1).alignment;
		if size_0 != 0 {
			_ecs_vector_set_count(
				&mut (*column_1).data,
				size_0 as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> alignment_0 as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					alignment_0 as libc::c_int
				} as int16_t,
				old_count + new_count,
			);
			/* Construct new values */
			let mut c_info_1: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
			let mut ctor_0: ecs_xtor_t = None;
			c_info_1 = *(*new_table).c_info.offset(i_new as isize);
			if !c_info_1.is_null() && {
				ctor_0 = (*c_info_1).lifecycle.ctor;
				ctor_0.is_some()
			} {
				ctor_component(
					world,
					c_info_1,
					column_1,
					entities,
					0 as libc::c_int,
					old_count + new_count,
				);
			}
		}
		i_new += 1
	}
	/* Destroy remaining columns */
	while i_old < old_component_count {
		let mut column_2: *mut ecs_column_t =
			&mut *old_columns.offset(i_old as isize) as *mut ecs_column_t;
		/* Destruct old values */
		let mut c_info_2: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
		let mut dtor_0: ecs_xtor_t = None;
		c_info_2 = *(*old_table).c_info.offset(i_old as isize);
		if !c_info_2.is_null() && {
			dtor_0 = (*c_info_2).lifecycle.dtor;
			dtor_0.is_some()
		} {
			dtor_component(
				world,
				c_info_2,
				column_2,
				entities,
				0 as libc::c_int,
				old_count,
			);
		}
		/* Old column does not occur in new table, remove */
		ecs_vector_free((*column_2).data);
		(*column_2).data = 0 as *mut ecs_vector_t;
		i_old += 1
	}
	/* Mark entity column as dirty */
	mark_table_dirty(new_table, 0 as libc::c_int);
}
/* Merge data of one table into another table */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_merge(
	mut world: *mut ecs_world_t,
	mut new_table: *mut ecs_table_t,
	mut old_table: *mut ecs_table_t,
	mut new_data: *mut ecs_data_t,
	mut old_data: *mut ecs_data_t,
) -> *mut ecs_data_t {
	let mut move_data: bool = 0 as libc::c_int != 0;
	/* If there is nothing to merge to, just clear the old table */
	if new_table.is_null() {
		ecs_table_clear_data(old_table, old_data);
		return 0 as *mut ecs_data_t;
	}
	/* If there is no data to merge, drop out */
	if old_data.is_null() {
		return 0 as *mut ecs_data_t;
	}
	if new_data.is_null() {
		new_data = ecs_table_get_or_create_data(new_table);
		if new_table == old_table {
			move_data = 1 as libc::c_int != 0
		}
	}
	let mut old_entities: *mut ecs_entity_t = _ecs_vector_first(
		(*old_data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut old_count: int32_t = ecs_vector_count((*old_data).entities);
	let mut new_count: int32_t = ecs_vector_count((*new_data).entities);
	let mut old_records: *mut *mut ecs_record_t = _ecs_vector_first(
		(*old_data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_record_t;
	/* First, update entity index so old entities point to new type */
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < old_count {
		let mut record: *mut ecs_record_t = 0 as *mut ecs_record_t;
		if new_table != old_table {
			record = *old_records.offset(i as isize);
			if record.is_null() {
				record = _ecs_sparse_get_sparse(
					(*world).store.entity_index,
					::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
					*old_entities.offset(i as isize),
				) as *mut ecs_record_t
			}
		} else {
			record = _ecs_sparse_get_or_create(
				(*world).store.entity_index,
				::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
				*old_entities.offset(i as isize),
			) as *mut ecs_record_t
		}
		let mut is_monitored: bool = (*record).row < 0 as libc::c_int;
		(*record).row = ecs_row_to_record(new_count + i, is_monitored);
		(*record).table = new_table;
		i += 1
	}
	/* Merge table columns */
	if move_data {
		*new_data = *old_data
	} else {
		merge_table_data(
			world, new_table, old_table, old_count, new_count, old_data, new_data,
		);
	}
	(*new_table).alloc_count += 1;
	if new_count == 0 && old_count != 0 {
		ecs_table_activate(
			world,
			new_table,
			0 as *mut ecs_query_t,
			1 as libc::c_int != 0,
		);
	}
	return new_data;
}
/* Replace data */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_replace_data(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
) {
	let mut prev_count: int32_t = 0 as libc::c_int;
	let mut table_data: *mut ecs_data_t = (*table).data;
	if !table_data.is_null() {
		prev_count = ecs_vector_count((*table_data).entities);
		run_remove_actions(
			world,
			table,
			table_data,
			0 as libc::c_int,
			ecs_table_data_count(table_data),
			0 as libc::c_int != 0,
		);
		ecs_table_clear_data(table, table_data);
	}
	if !data.is_null() {
		table_data = ecs_table_get_or_create_data(table);
		*table_data = *data
	} else {
		return;
	}
	let mut count: int32_t = ecs_table_count(table);
	if prev_count == 0 && count != 0 {
		ecs_table_activate(world, table, 0 as *mut ecs_query_t, 1 as libc::c_int != 0);
	} else if prev_count != 0 && count == 0 {
		ecs_table_activate(world, table, 0 as *mut ecs_query_t, 0 as libc::c_int != 0);
	};
}
/* Match table with filter */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_match_filter(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut filter: *const ecs_filter_t,
) -> bool {
	if filter.is_null() {
		return 1 as libc::c_int != 0;
	}
	let mut type_0: ecs_type_t = (*table).type_0;
	if !(*filter).include.is_null() {
		/* If filter kind is exact, types must be the same */
		if (*filter).include_kind as libc::c_uint == EcsMatchExact as libc::c_int as libc::c_uint {
			if type_0 != (*filter).include {
				return 0 as libc::c_int != 0;
			}
		/* Default for include_kind is MatchAll */
		} else if ecs_type_contains(
			world,
			type_0,
			(*filter).include,
			(*filter).include_kind as libc::c_uint != EcsMatchAny as libc::c_int as libc::c_uint,
			1 as libc::c_int != 0,
		) == 0
		{
			return 0 as libc::c_int != 0;
		}
	}
	if !(*filter).exclude.is_null() {
		/* If filter kind is exact, types must be the same */
		if (*filter).exclude_kind as libc::c_uint == EcsMatchExact as libc::c_int as libc::c_uint {
			if type_0 == (*filter).exclude {
				return 0 as libc::c_int != 0;
			}
		/* Default for exclude_kind is MatchAny */
		} else if ecs_type_contains(
			world,
			type_0,
			(*filter).exclude,
			(*filter).exclude_kind as libc::c_uint == EcsMatchAll as libc::c_int as libc::c_uint,
			1 as libc::c_int != 0,
		) != 0
		{
			return 0 as libc::c_int != 0;
		}
	}
	return 1 as libc::c_int != 0;
}
/* Get dirty state for table columns */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_get_dirty_state(mut table: *mut ecs_table_t) -> *mut int32_t {
	if (*table).dirty_state.is_null() {
		(*table).dirty_state = ecs_os_api.calloc_.expect("non-null function pointer")(
			::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t
				* ((*table).column_count + 1 as libc::c_int),
		) as *mut int32_t
	}
	return (*table).dirty_state;
}
/* Get monitor for monitoring table changes */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_get_monitor(mut table: *mut ecs_table_t) -> *mut int32_t {
	let mut dirty_state: *mut int32_t = ecs_table_get_dirty_state(table);
	let mut column_count: int32_t = (*table).column_count;
	return ecs_os_memdup(
		dirty_state as *const libc::c_void,
		(column_count + 1 as libc::c_int)
			* ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t,
	) as *mut int32_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_notify(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut event: *mut ecs_table_event_t,
) {
	match (*event).kind as libc::c_uint {
		0 => {
			register_query(world, table, (*event).query, (*event).matched_table_index);
		}
		1 => {
			unregister_query(world, table, (*event).query);
		}
		2 => {
			notify_component_info(world, table, (*event).component);
		}
		_ => {}
	};
}
unsafe extern "C" fn comp_mask_index(mut value: int32_t) -> int32_t {
	return value >> 6 as libc::c_int;
}
unsafe extern "C" fn comp_mask_set(mut set: *mut ecs_comp_set_t, mut value: ecs_entity_t) {
	if value < 256 as libc::c_int as libc::c_ulong {
		let mut index: int32_t = comp_mask_index(value as int32_t);
		(*set).lo_mask[index as usize] |=
			(1 as libc::c_int as ecs_entity_t) << (value & 0x3f as libc::c_int as libc::c_ulong)
	} else {
		let fresh13 = (*set).hi_count;
		(*set).hi_count = (*set).hi_count + 1;
		let mut count: int32_t = fresh13;
		(*set).hi_array[count as usize] = value
	};
}
unsafe extern "C" fn comp_mask_is_set(
	mut set: *mut ecs_comp_set_t,
	mut value: ecs_entity_t,
) -> bool {
	if value < 256 as libc::c_int as libc::c_ulong {
		let mut index: int32_t = comp_mask_index(value as int32_t);
		return (*set).lo_mask[index as usize]
			& (1 as libc::c_int as ecs_entity_t) << (value & 0x3f as libc::c_int as libc::c_ulong)
			!= 0 as libc::c_int as libc::c_ulong;
	} else {
		let mut i: int32_t = 0;
		let mut count: int32_t = (*set).hi_count;
		i = 0 as libc::c_int;
		while i < count {
			if (*set).hi_array[i as usize] == value {
				return 1 as libc::c_int != 0;
			}
			i += 1
		}
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn get_component_w_index(
	mut info: *mut ecs_entity_info_t,
	mut index: int32_t,
) -> *mut libc::c_void {
	let mut data: *mut ecs_data_t = (*info).data;
	let mut columns: *mut ecs_column_t = 0 as *mut ecs_column_t;
	if data.is_null() || {
		columns = (*data).columns;
		columns.is_null()
	} {
		return 0 as *mut libc::c_void;
	}
	let mut column: *mut ecs_column_t = &mut *columns.offset(index as isize) as *mut ecs_column_t;
	let mut data_vec: *mut ecs_vector_t = (*column).data;
	let mut size: int16_t = (*column).size;
	if size != 0 {
		let mut ptr: *mut libc::c_void = _ecs_vector_first(
			data_vec,
			size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> (*column).alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				(*column).alignment as libc::c_int
			} as int16_t,
		);
		return (ptr as uintptr_t).wrapping_add(((*info).row * size as libc::c_int) as uintptr_t)
			as *mut libc::c_void;
	}
	return 0 as *mut libc::c_void;
}
/* Get pointer to single component value */
unsafe extern "C" fn get_component(
	mut info: *mut ecs_entity_info_t,
	mut component: ecs_entity_t,
) -> *mut libc::c_void {
	let mut table: *mut ecs_table_t = (*info).table;
	if table.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut type_0: ecs_type_t = (*table).type_0;
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count(type_0);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		if *c_ptr == component {
			return get_component_w_index(info, c_ptr_i);
		}
		c_ptr_i += 1
	}
	return 0 as *mut libc::c_void;
}
/* Utility to compute actual row from row in record */
unsafe extern "C" fn set_row_info(mut info: *mut ecs_entity_info_t, mut row: int32_t) -> int32_t {
	(*info).row = ecs_record_to_row(row, &mut (*info).is_watched);
	return (*info).row;
}
/* Utility to set info from main stage record */
unsafe extern "C" fn set_info_from_record(
	mut e: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut record: *mut ecs_record_t,
) {
	(*info).record = record;
	let mut table: *mut ecs_table_t = (*record).table;
	set_row_info(info, (*record).row);
	(*info).table = table;
	if (*info).table.is_null() {
		return;
	}
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	(*info).data = data;
}
/* Obtain entity info */
/* Get info from main stage */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_info(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
) -> bool {
	let mut record: *mut ecs_record_t = _ecs_sparse_get_sparse(
		(*world).store.entity_index,
		::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
		entity,
	) as *mut ecs_record_t;
	if record.is_null() {
		(*info).table = 0 as *mut ecs_table_t;
		(*info).is_watched = 0 as libc::c_int != 0;
		(*info).record = 0 as *mut ecs_record_t;
		return 0 as libc::c_int != 0;
	}
	set_info_from_record(entity, info, record);
	return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_c_info(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
) -> *mut ecs_c_info_t {
	let mut real_id: ecs_entity_t = ecs_component_id_from_id(world, component);
	if real_id != 0 {
		return ecs_get_c_info(world, real_id);
	} else {
		return 0 as *mut ecs_c_info_t;
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_get_column_info(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut components: *mut ecs_entities_t,
	mut cinfo: *mut ecs_column_info_t,
	mut get_all: bool,
) {
	let mut column_count: int32_t = (*table).column_count;
	let mut type_array: *mut ecs_entity_t = _ecs_vector_first(
		(*table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	if get_all {
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*table).type_0);
		i = 0 as libc::c_int;
		while i < count {
			let mut id: ecs_entity_t = *type_array.offset(i as isize);
			(*cinfo.offset(i as isize)).id = id;
			let ref mut fresh14 = (*cinfo.offset(i as isize)).ci;
			*fresh14 = get_c_info(world, id);
			(*cinfo.offset(i as isize)).column = i;
			i += 1
		}
	} else {
		let mut array: *mut ecs_entity_t = (*components).array;
		let mut i_0: int32_t = 0;
		let mut cur: int32_t = 0;
		let mut count_0: int32_t = (*components).count;
		i_0 = 0 as libc::c_int;
		while i_0 < count_0 {
			let mut id_0: ecs_entity_t = *array.offset(i_0 as isize);
			(*cinfo.offset(i_0 as isize)).id = id_0;
			let ref mut fresh15 = (*cinfo.offset(i_0 as isize)).ci;
			*fresh15 = get_c_info(world, id_0);
			(*cinfo.offset(i_0 as isize)).column = -(1 as libc::c_int);
			cur = 0 as libc::c_int;
			while cur < column_count {
				if *type_array.offset(cur as isize) == id_0 {
					(*cinfo.offset(i_0 as isize)).column = cur;
					break;
				} else {
					cur += 1
				}
			}
			i_0 += 1
		}
	};
}
unsafe extern "C" fn run_component_trigger_for_entities(
	mut world: *mut ecs_world_t,
	mut trigger_vec: *mut ecs_vector_t,
	mut component: ecs_entity_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut entities: *mut ecs_entity_t,
) {
	let mut i: int32_t = 0;
	let mut trigger_count: int32_t = ecs_vector_count(trigger_vec);
	if trigger_count != 0 {
		let mut triggers: *mut EcsTrigger = _ecs_vector_first(
			trigger_vec,
			::std::mem::size_of::<EcsTrigger>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut EcsTrigger;
		let mut index: int32_t = ecs_type_index_of((*table).type_0, component);
		index += 1;
		let mut components: [ecs_entity_t; 1] = [component];
		let mut types: [ecs_type_t; 1] = [ecs_type_from_entity(world, component)];
		let mut columns: [int32_t; 1] = [index];
		/* If this is a tag, don't try to retrieve data */
		if (*table).column_count < index {
			columns[0 as libc::c_int as usize] = 0 as libc::c_int
		} else {
			let mut column: *mut ecs_column_t =
				&mut *(*data).columns.offset((index - 1 as libc::c_int) as isize)
					as *mut ecs_column_t;
			if (*column).size == 0 {
				columns[0 as libc::c_int as usize] = 0 as libc::c_int
			}
		}
		let mut table_data: ecs_iter_table_t = {
			let mut init = ecs_iter_table_t {
				columns: columns.as_mut_ptr(),
				table: table,
				data: 0 as *mut ecs_data_t,
				components: components.as_mut_ptr(),
				types: types.as_mut_ptr(),
				references: 0 as *mut ecs_ref_t,
			};
			init
		};
		let mut it: ecs_iter_t = {
			let mut init = ecs_iter_t {
				world: world,
				system: 0,
				table: &mut table_data,
				query: 0 as *mut ecs_query_t,
				table_count: 1 as libc::c_int,
				inactive_table_count: 1 as libc::c_int,
				column_count: 1 as libc::c_int,
				table_columns: (*data).columns as *mut libc::c_void,
				entities: entities,
				param: 0 as *mut libc::c_void,
				delta_time: 0.,
				delta_system_time: 0.,
				world_time: 0.,
				frame_offset: 0,
				table_offset: 0,
				offset: row,
				count: count,
				total_count: 0,
				triggered_by: 0 as *mut ecs_entities_t,
				interrupted_by: 0,
				iter: C2RustUnnamed {
					parent: ecs_scope_iter_t {
						filter: ecs_filter_t {
							include: 0 as *const ecs_vector_t,
							exclude: 0 as *const ecs_vector_t,
							include_kind: EcsMatchDefault,
							exclude_kind: EcsMatchDefault,
						},
						tables: 0 as *mut ecs_vector_t,
						index: 0,
						table: ecs_iter_table_t {
							columns: 0 as *mut int32_t,
							table: 0 as *mut ecs_table_t,
							data: 0 as *mut ecs_data_t,
							components: 0 as *mut ecs_entity_t,
							types: 0 as *mut ecs_type_t,
							references: 0 as *mut ecs_ref_t,
						},
					},
				},
			};
			init
		};
		i = 0 as libc::c_int;
		while i < trigger_count {
			it.system = (*triggers.offset(i as isize)).self_0;
			it.param = (*triggers.offset(i as isize)).ctx;
			(*triggers.offset(i as isize))
				.action
				.expect("non-null function pointer")(&mut it);
			i += 1
		}
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_run_component_trigger(
	mut world: *mut ecs_world_t,
	mut trigger_vec: *mut ecs_vector_t,
	mut component: ecs_entity_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	if (*table).flags & 2 as libc::c_uint != 0 {
		return;
	}
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	entities = (entities as uintptr_t).wrapping_add(
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * row) as uintptr_t,
	) as *mut libc::c_void as *mut ecs_entity_t;
	run_component_trigger_for_entities(
		world,
		trigger_vec,
		component,
		table,
		data,
		row,
		count,
		entities,
	);
}
unsafe extern "C" fn run_set_systems_for_entities(
	mut world: *mut ecs_world_t,
	mut components: *mut ecs_entities_t,
	mut table: *mut ecs_table_t,
	mut row: int32_t,
	mut count: int32_t,
	mut entities: *mut ecs_entity_t,
	mut set_all: bool,
) {
	/* Run OnSet systems */
	if set_all {
		let mut queries: *mut ecs_vector_t = (*table).on_set_all;
		let mut m_i: libc::c_int = 0;
		let mut m_count: libc::c_int = ecs_vector_count(queries);
		let mut m_array: *mut ecs_matched_query_t = _ecs_vector_first(
			queries,
			::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_query_t;
		m_i = 0 as libc::c_int;
		while m_i < m_count {
			let mut m: *mut ecs_matched_query_t =
				&mut *m_array.offset(m_i as isize) as *mut ecs_matched_query_t;
			ecs_run_monitor(world, m, components, row, count, entities);
			m_i += 1
		}
	} else {
		let mut on_set_systems: *mut *mut ecs_vector_t = (*table).on_set;
		if !on_set_systems.is_null() {
			let mut index: int32_t = ecs_type_index_of(
				(*table).type_0,
				*(*components).array.offset(0 as libc::c_int as isize),
			);
			let mut queries_0: *mut ecs_vector_t = *on_set_systems.offset(index as isize);
			let mut m_i_0: libc::c_int = 0;
			let mut m_count_0: libc::c_int = ecs_vector_count(queries_0);
			let mut m_array_0: *mut ecs_matched_query_t = _ecs_vector_first(
				queries_0,
				::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_matched_query_t;
			m_i_0 = 0 as libc::c_int;
			while m_i_0 < m_count_0 {
				let mut m_0: *mut ecs_matched_query_t =
					&mut *m_array_0.offset(m_i_0 as isize) as *mut ecs_matched_query_t;
				ecs_run_monitor(world, m_0, components, row, count, entities);
				m_i_0 += 1
			}
		}
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_run_set_systems(
	mut world: *mut ecs_world_t,
	mut components: *mut ecs_entities_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut set_all: bool,
) {
	if count == 0 || data.is_null() {
		return;
	}
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	entities = (entities as uintptr_t).wrapping_add(
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * row) as uintptr_t,
	) as *mut libc::c_void as *mut ecs_entity_t;
	run_set_systems_for_entities(world, components, table, row, count, entities, set_all);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_run_monitors(
	mut world: *mut ecs_world_t,
	mut dst_table: *mut ecs_table_t,
	mut v_dst_monitors: *mut ecs_vector_t,
	mut dst_row: int32_t,
	mut count: int32_t,
	mut v_src_monitors: *mut ecs_vector_t,
) {
	if v_dst_monitors == v_src_monitors {
		return;
	}
	if v_dst_monitors.is_null() {
		return;
	}
	if (*dst_table).flags & 2 as libc::c_uint != 0 {
		return;
	}
	if v_src_monitors.is_null() {
		let mut monitor_i: libc::c_int = 0;
		let mut monitor_count: libc::c_int = ecs_vector_count(v_dst_monitors);
		let mut monitor_array: *mut ecs_matched_query_t = _ecs_vector_first(
			v_dst_monitors,
			::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_query_t;
		monitor_i = 0 as libc::c_int;
		while monitor_i < monitor_count {
			let mut monitor: *mut ecs_matched_query_t =
				&mut *monitor_array.offset(monitor_i as isize) as *mut ecs_matched_query_t;
			ecs_run_monitor(
				world,
				monitor,
				0 as *mut ecs_entities_t,
				dst_row,
				count,
				0 as *mut ecs_entity_t,
			);
			monitor_i += 1
		}
	} else {
		/* If both tables have monitors, run the ones that dst_table has and
		 * src_table doesn't have */
		let mut i: int32_t = 0;
		let mut m_count: int32_t = ecs_vector_count(v_dst_monitors);
		let mut j: int32_t = 0 as libc::c_int;
		let mut src_count: int32_t = ecs_vector_count(v_src_monitors);
		let mut dst_monitors: *mut ecs_matched_query_t = _ecs_vector_first(
			v_dst_monitors,
			::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_query_t;
		let mut src_monitors: *mut ecs_matched_query_t = _ecs_vector_first(
			v_src_monitors,
			::std::mem::size_of::<ecs_matched_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_query_t;
		i = 0 as libc::c_int;
		while i < m_count {
			let mut dst: *mut ecs_matched_query_t =
				&mut *dst_monitors.offset(i as isize) as *mut ecs_matched_query_t;
			let mut system: ecs_entity_t = (*(*dst).query).system;
			let mut src: *mut ecs_matched_query_t = 0 as *mut ecs_matched_query_t;
			while j < src_count {
				src = &mut *src_monitors.offset(j as isize) as *mut ecs_matched_query_t;
				if !((*(*src).query).system < system) {
					break;
				}
				j += 1
			}
			if !((*(*src).query).system == system) {
				ecs_run_monitor(
					world,
					dst,
					0 as *mut ecs_entities_t,
					dst_row,
					count,
					0 as *mut ecs_entity_t,
				);
			}
			i += 1
		}
	};
}
unsafe extern "C" fn find_prefab(mut type_0: ecs_type_t, mut n: int32_t) -> int32_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut buffer: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = n + 1 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *buffer.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			return i;
		}
		i += 1
	}
	return -(1 as libc::c_int);
}
unsafe extern "C" fn instantiate_children(
	mut world: *mut ecs_world_t,
	mut base: ecs_entity_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut child_table: *mut ecs_table_t,
) {
	let mut type_0: ecs_type_t = (*child_table).type_0;
	let mut child_data: *mut ecs_data_t = ecs_table_get_data(child_table);
	let mut column_count: int32_t = (*child_table).column_count;
	let mut type_array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut type_count: int32_t = ecs_vector_count(type_0);
	/* Instantiate child table for each instance */
	/* Create component array for creating the table */
	let mut components: ecs_entities_t = ecs_entities_t {
		array: 0 as *mut ecs_entity_t,
		count: 0,
	};
	let mut fresh16 = ::std::vec::from_elem(
		0,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * type_count
			+ 1 as libc::c_int) as size_t as usize,
	);
	components.array = fresh16.as_mut_ptr() as *mut ecs_entity_t;
	components.count = 0 as libc::c_int;
	let mut c_info: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
	if !child_data.is_null() {
		let mut fresh17 = ::std::vec::from_elem(
			0,
			(::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as ecs_size_t
				* column_count) as size_t as usize,
		);
		c_info = fresh17.as_mut_ptr() as *mut *mut libc::c_void
	} else {
		return;
	}
	/* Copy in component identifiers. Find the base index in the component
	 * array, since we'll need this to replace the base with the instance id */
	let mut i: libc::c_int = 0;
	let mut base_index: libc::c_int = -(1 as libc::c_int);
	let mut pos: libc::c_int = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < type_count {
		let mut c: ecs_entity_t = *type_array.offset(i as isize);
		/* Make sure instances don't have EcsPrefab */
		if !(c == (256 as libc::c_int + 1 as libc::c_int) as libc::c_ulong) {
			/* Keep track of the element that creates the CHILDOF relationship with
			 * the prefab parent. We need to replace this element to make sure the
			 * created children point to the instance and not the prefab */
			if c & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				&& c & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int) == base
			{
				base_index = pos
			}
			/* Store pointer to component array. We'll use this component array to
			 * create our new entities in bulk with new_w_data */
			if i < column_count {
				let mut column: *mut ecs_column_t =
					&mut *(*child_data).columns.offset(i as isize) as *mut ecs_column_t;
				let ref mut fresh18 = *c_info.offset(pos as isize);
				*fresh18 = _ecs_vector_first(
					(*column).data,
					(*column).size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> (*column).alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						(*column).alignment as libc::c_int
					} as int16_t,
				)
			}
			*components.array.offset(pos as isize) = c;
			pos += 1
		}
		i += 1
	}
	/* If children are added to a prefab, make sure they are prefabs too */
	if (*table).flags & 2 as libc::c_uint != 0 {
		*components.array.offset(pos as isize) =
			(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t;
		pos += 1
	}
	components.count = pos;
	/* Instantiate the prefab child table for each new instance */
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut child_count: int32_t = ecs_vector_count((*child_data).entities);
	i = row;
	while i < count + row {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		/* Replace CHILDOF element in the component array with instance id */
		*components.array.offset(base_index as isize) = (1 as libc::c_int as uint64_t)
			<< 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| e;
		/* Find or create table */
		let mut i_table: *mut ecs_table_t = ecs_table_find_or_create(world, &mut components);
		/* Create children */
		let mut child_row: int32_t = 0;
		new_w_data(
			world,
			i_table,
			0 as *mut ecs_entities_t,
			child_count,
			c_info,
			&mut child_row,
		);
		/* If prefab child table has children itself, recursively instantiate */
		let mut i_data: *mut ecs_data_t = ecs_table_get_data(i_table);
		let mut children: *mut ecs_entity_t = _ecs_vector_first(
			(*child_data).entities,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		let mut j: libc::c_int = 0;
		j = 0 as libc::c_int;
		while j < child_count {
			let mut child: ecs_entity_t = *children.offset(j as isize);
			instantiate(
				world,
				child,
				i_table,
				i_data,
				child_row + j,
				1 as libc::c_int,
			);
			j += 1
		}
		i += 1
	}
}
unsafe extern "C" fn instantiate(
	mut world: *mut ecs_world_t,
	mut base: ecs_entity_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	/* If base is a parent, instantiate children of base for instances */
	let mut child_tables: *mut ecs_vector_t =
		_ecs_map_get_ptr((*world).child_tables, base) as *mut ecs_vector_t;
	if !child_tables.is_null() {
		let mut child_table_ptr_i: libc::c_int = 0;
		let mut child_table_ptr_count: libc::c_int = ecs_vector_count(child_tables);
		let mut child_table_ptr_array: *mut *mut ecs_table_t = _ecs_vector_first(
			child_tables,
			::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_table_t;
		child_table_ptr_i = 0 as libc::c_int;
		while child_table_ptr_i < child_table_ptr_count {
			let mut child_table_ptr: *mut *mut ecs_table_t = &mut *child_table_ptr_array
				.offset(child_table_ptr_i as isize)
				as *mut *mut ecs_table_t;
			let mut child_table: *mut ecs_table_t = *child_table_ptr;
			if !(ecs_table_count(child_table) == 0) {
				instantiate_children(world, base, table, data, row, count, child_table);
			}
			child_table_ptr_i += 1
		}
	};
}
unsafe extern "C" fn override_from_base(
	mut world: *mut ecs_world_t,
	mut base: ecs_entity_t,
	mut component: ecs_entity_t,
	mut data: *mut ecs_data_t,
	mut column: *mut ecs_column_t,
	mut row: int32_t,
	mut count: int32_t,
) -> bool {
	let mut base_info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	if !ecs_get_info(world, base, &mut base_info) {
		return 0 as libc::c_int != 0;
	}
	let mut base_ptr: *mut libc::c_void = get_component(&mut base_info, component);
	if !base_ptr.is_null() {
		let mut data_size: int16_t = (*column).size;
		let mut data_array: *mut libc::c_void = _ecs_vector_first(
			(*column).data,
			(*column).size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> (*column).alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				(*column).alignment as libc::c_int
			} as int16_t,
		);
		let mut data_ptr: *mut libc::c_void = (data_array as uintptr_t)
			.wrapping_add((data_size as libc::c_int * row) as uintptr_t)
			as *mut libc::c_void;
		component = ecs_component_id_from_id(world, component);
		let mut cdata: *mut ecs_c_info_t = ecs_get_c_info(world, component);
		let mut index: int32_t = 0;
		let mut copy: ecs_copy_t = if !cdata.is_null() {
			(*cdata).lifecycle.copy
		} else {
			None
		};
		if copy.is_some() {
			let mut entities: *mut ecs_entity_t = _ecs_vector_first(
				(*data).entities,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			let mut ctx: *mut libc::c_void = (*cdata).lifecycle.ctx;
			index = 0 as libc::c_int;
			while index < count {
				copy.expect("non-null function pointer")(
					world,
					component,
					&mut *entities.offset(row as isize),
					&mut base,
					data_ptr,
					base_ptr,
					ecs_to_size_t(data_size as int64_t),
					1 as libc::c_int,
					ctx,
				);
				data_ptr = (data_ptr as uintptr_t).wrapping_add(data_size as uintptr_t)
					as *mut libc::c_void;
				index += 1
			}
		} else {
			index = 0 as libc::c_int;
			while index < count {
				memcpy(data_ptr, base_ptr, data_size as size_t);
				data_ptr = (data_ptr as uintptr_t).wrapping_add(data_size as uintptr_t)
					as *mut libc::c_void;
				index += 1
			}
		}
		return 1 as libc::c_int != 0;
	} else {
		/* If component not found on base, check if base itself inherits */
		let mut base_type: ecs_type_t = (*base_info.table).type_0;
		return override_component(world, component, base_type, data, column, row, count);
	};
}
unsafe extern "C" fn override_component(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut type_0: ecs_type_t,
	mut data: *mut ecs_data_t,
	mut column: *mut ecs_column_t,
	mut row: int32_t,
	mut count: int32_t,
) -> bool {
	let mut type_array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut type_count: int32_t = ecs_vector_count(type_0);
	/* Walk prefabs */
	i = type_count - 1 as libc::c_int;
	loop {
		let mut e: ecs_entity_t = *type_array.offset(i as isize);
		if e < (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			break;
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			return override_from_base(
				world,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
				component,
				data,
				column,
				row,
				count,
			);
		}
		i -= 1;
		if !(i >= 0 as libc::c_int) {
			break;
		}
	}
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_components_override(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut component_info: *mut ecs_column_info_t,
	mut component_count: int32_t,
	mut set_mask: *mut ecs_comp_set_t,
	mut run_on_set: bool,
) {
	if component_count == 0 {
		return;
	}
	let mut table_without_base: *mut ecs_table_t = table;
	let mut columns: *mut ecs_column_t = (*data).columns;
	let mut type_0: ecs_type_t = (*table).type_0;
	let mut column_count: int32_t = (*table).column_count;
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < component_count {
		let mut component: ecs_entity_t = (*component_info.offset(i as isize)).id;
		if component >= 256 as libc::c_int as libc::c_ulong {
			if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			{
				let mut base: ecs_entity_t =
					component & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
				instantiate(world, base, table, data, row, count);
				/* If table has on_set systems, get table without the base
				 * entity that was just added. This is needed to determine the
				 * diff between the on_set systems of the current table and the
				 * table without the base, as these are the systems that need to
				 * be invoked */
				let mut to_remove: ecs_entities_t = {
					let mut init = ecs_entities_t {
						array: &mut component,
						count: 1 as libc::c_int,
					};
					init
				};
				table_without_base = ecs_table_traverse_remove(
					world,
					table_without_base,
					&mut to_remove,
					0 as *mut ecs_entities_t,
				)
			}
		}
		let mut column_index: int32_t = (*component_info.offset(i as isize)).column;
		if !(column_index == -(1 as libc::c_int) || column_index >= column_count) {
			if !comp_mask_is_set(set_mask, component) {
				let mut column: *mut ecs_column_t =
					&mut *columns.offset(column_index as isize) as *mut ecs_column_t;
				if override_component(world, component, type_0, data, column, row, count) {
					let mut to_remove_0: ecs_entities_t = {
						let mut init = ecs_entities_t {
							array: &mut component,
							count: 1 as libc::c_int,
						};
						init
					};
					table_without_base = ecs_table_traverse_remove(
						world,
						table_without_base,
						&mut to_remove_0,
						0 as *mut ecs_entities_t,
					)
				}
			}
		}
		i += 1
	}
	/* Run OnSet actions when a base entity is added to the entity for
	 * components not overridden by the entity. */
	if run_on_set as libc::c_int != 0 && table_without_base != table {
		ecs_run_monitors(
			world,
			table,
			(*table).on_set_all,
			row,
			count,
			(*table_without_base).on_set_all,
		);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_components_switch(
	mut world: *mut ecs_world_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut added: *mut ecs_entities_t,
) {
	let mut array: *mut ecs_entity_t = (*added).array;
	let mut i: int32_t = 0;
	let mut add_count: int32_t = (*added).count;
	i = 0 as libc::c_int;
	while i < add_count {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			e = e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			let mut sw_case: ecs_entity_t = e as uint32_t as ecs_entity_t;
			let mut sw_index: ecs_entity_t = (e >> 32 as libc::c_int) as uint32_t as ecs_entity_t;
			let mut sw: *mut ecs_switch_t = (*(*data).sw_columns.offset(sw_index as isize)).data;
			let mut r: int32_t = 0;
			r = 0 as libc::c_int;
			while r < count {
				ecs_switch_set(sw, row + r, sw_case);
				r += 1
			}
		}
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn ecs_components_on_add(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut component_info: *mut ecs_column_info_t,
	mut component_count: int32_t,
) {
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < component_count {
		let mut c_info: *mut ecs_c_info_t = (*component_info.offset(i as isize)).ci;
		let mut triggers: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
		if !(c_info.is_null() || {
			triggers = (*c_info).on_add;
			triggers.is_null()
		}) {
			let mut component: ecs_entity_t = (*component_info.offset(i as isize)).id;
			ecs_run_component_trigger(world, triggers, component, table, data, row, count);
		}
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn ecs_components_on_remove(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut component_info: *mut ecs_column_info_t,
	mut component_count: int32_t,
) {
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < component_count {
		let mut c_info: *mut ecs_c_info_t = (*component_info.offset(i as isize)).ci;
		let mut triggers: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
		if !(c_info.is_null() || {
			triggers = (*c_info).on_remove;
			triggers.is_null()
		}) {
			let mut component: ecs_entity_t = (*component_info.offset(i as isize)).id;
			ecs_run_component_trigger(world, triggers, component, table, data, row, count);
		}
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn ecs_run_add_actions(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut added: *mut ecs_entities_t,
	mut set_mask: *mut ecs_comp_set_t,
	mut get_all: bool,
	mut run_on_set: bool,
) {
	let mut cinfo: [ecs_column_info_t; 32] = [ecs_column_info_t {
		id: 0,
		ci: 0 as *mut ecs_c_info_t,
		column: 0,
	}; 32];
	ecs_get_column_info(world, table, added, cinfo.as_mut_ptr(), get_all);
	let mut added_count: libc::c_int = (*added).count;
	if (*table).flags & 4 as libc::c_uint != 0 {
		ecs_components_override(
			world,
			table,
			data,
			row,
			count,
			cinfo.as_mut_ptr(),
			added_count,
			set_mask,
			run_on_set,
		);
	}
	if (*table).flags & 65536 as libc::c_uint != 0 {
		ecs_components_switch(world, data, row, count, added);
	}
	if (*table).flags & 2048 as libc::c_uint != 0 {
		ecs_components_on_add(
			world,
			table,
			data,
			row,
			count,
			cinfo.as_mut_ptr(),
			added_count,
		);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_run_remove_actions(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut row: int32_t,
	mut count: int32_t,
	mut removed: *mut ecs_entities_t,
	mut get_all: bool,
) {
	let mut cinfo: [ecs_column_info_t; 32] = [ecs_column_info_t {
		id: 0,
		ci: 0 as *mut ecs_c_info_t,
		column: 0,
	}; 32];
	ecs_get_column_info(world, table, removed, cinfo.as_mut_ptr(), get_all);
	let mut removed_count: libc::c_int = (*removed).count;
	if (*table).flags & 4096 as libc::c_uint != 0 {
		ecs_components_on_remove(
			world,
			table,
			data,
			row,
			count,
			cinfo.as_mut_ptr(),
			removed_count,
		);
	};
}
unsafe extern "C" fn new_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut new_table: *mut ecs_table_t,
	mut added: *mut ecs_entities_t,
) -> int32_t {
	let mut record: *mut ecs_record_t = (*info).record;
	let mut new_data: *mut ecs_data_t = ecs_table_get_or_create_data(new_table);
	let mut new_row: int32_t = 0;
	if record.is_null() {
		record = _ecs_sparse_get_or_create(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			entity,
		) as *mut ecs_record_t
	}
	new_row = ecs_table_append(
		world,
		new_table,
		new_data,
		entity,
		record,
		1 as libc::c_int != 0,
	);
	(*record).table = new_table;
	(*record).row = ecs_row_to_record(new_row, (*info).is_watched);
	if (*new_table).flags
		& (4 as libc::c_uint
			| 65536 as libc::c_uint
			| 128 as libc::c_uint
			| 2048 as libc::c_uint
			| 8192 as libc::c_uint
			| 32768 as libc::c_uint)
		!= 0
	{
		let mut set_mask: ecs_comp_set_t = {
			let mut init = ecs_comp_set_t {
				hi_count: 0 as libc::c_int,
				hi_array: [0; 32],
				lo_mask: [0; 4],
			};
			init
		};
		ecs_run_add_actions(
			world,
			new_table,
			new_data,
			new_row,
			1 as libc::c_int,
			added,
			&mut set_mask,
			1 as libc::c_int != 0,
			1 as libc::c_int != 0,
		);
		if (*new_table).flags & 32768 as libc::c_uint != 0 {
			ecs_run_monitors(
				world,
				new_table,
				(*new_table).monitors,
				new_row,
				1 as libc::c_int,
				0 as *mut ecs_vector_t,
			);
		}
	}
	(*info).data = new_data;
	return new_row;
}
unsafe extern "C" fn move_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut src_table: *mut ecs_table_t,
	mut src_data: *mut ecs_data_t,
	mut src_row: int32_t,
	mut dst_table: *mut ecs_table_t,
	mut added: *mut ecs_entities_t,
	mut removed: *mut ecs_entities_t,
) -> int32_t {
	let mut dst_data: *mut ecs_data_t = ecs_table_get_or_create_data(dst_table);
	if src_data == dst_data {
		return src_row;
	}
	let mut record: *mut ecs_record_t = (*info).record;
	let mut dst_row: int32_t = ecs_table_append(
		world,
		dst_table,
		dst_data,
		entity,
		record,
		0 as libc::c_int != 0,
	);
	(*record).table = dst_table;
	(*record).row = ecs_row_to_record(dst_row, (*info).is_watched);
	/* Copy entity & components from src_table to dst_table */
	if !(*src_table).type_0.is_null() {
		ecs_table_move(
			world, entity, entity, dst_table, dst_data, dst_row, src_table, src_data, src_row,
		);
		/* If components were removed, invoke remove actions before deleting */
		if !removed.is_null()
			&& (*src_table).flags
				& (4 as libc::c_uint
					| 256 as libc::c_uint
					| 4096 as libc::c_uint
					| 16384 as libc::c_uint
					| 32768 as libc::c_uint)
				!= 0
		{
			/* If entity was moved, invoke UnSet monitors for each component that
			 * the entity no longer has */
			ecs_run_monitors(
				world,
				dst_table,
				(*src_table).un_set_all,
				dst_row,
				1 as libc::c_int,
				(*dst_table).un_set_all,
			);
			ecs_run_remove_actions(
				world,
				src_table,
				src_data,
				src_row,
				1 as libc::c_int,
				removed,
				0 as libc::c_int != 0,
			);
		}
	}
	ecs_table_delete(world, src_table, src_data, src_row, 0 as libc::c_int != 0);
	/* If components were added, invoke add actions */
	if src_table != dst_table || !added.is_null() && (*added).count != 0 {
		if !added.is_null()
			&& (*dst_table).flags
				& (4 as libc::c_uint
					| 65536 as libc::c_uint
					| 128 as libc::c_uint
					| 2048 as libc::c_uint
					| 8192 as libc::c_uint
					| 32768 as libc::c_uint)
				!= 0
		{
			let mut set_mask: ecs_comp_set_t = {
				let mut init = ecs_comp_set_t {
					hi_count: 0 as libc::c_int,
					hi_array: [0; 32],
					lo_mask: [0; 4],
				};
				init
			};
			ecs_run_add_actions(
				world,
				dst_table,
				dst_data,
				dst_row,
				1 as libc::c_int,
				added,
				&mut set_mask,
				0 as libc::c_int != 0,
				1 as libc::c_int != 0,
			);
		}
		/* Run monitors */
		if (*dst_table).flags & 32768 as libc::c_uint != 0 {
			ecs_run_monitors(
				world,
				dst_table,
				(*dst_table).monitors,
				dst_row,
				1 as libc::c_int,
				(*src_table).monitors,
			);
		}
		/* If removed components were overrides, run OnSet systems for those, as
		 * the value of those components changed from the removed component to
		 * the value of component on the base entity */
		if !removed.is_null() && (*dst_table).flags & 4 as libc::c_uint != 0 {
			ecs_run_monitors(
				world,
				dst_table,
				(*src_table).on_set_override,
				dst_row,
				1 as libc::c_int,
				(*dst_table).on_set_override,
			);
		}
	}
	(*info).data = dst_data;
	return dst_row;
}
unsafe extern "C" fn delete_entity(
	mut world: *mut ecs_world_t,
	mut src_table: *mut ecs_table_t,
	mut src_data: *mut ecs_data_t,
	mut src_row: int32_t,
	mut removed: *mut ecs_entities_t,
) {
	if !removed.is_null() {
		ecs_run_monitors(
			world,
			src_table,
			(*src_table).un_set_all,
			src_row,
			1 as libc::c_int,
			0 as *mut ecs_vector_t,
		);
		/* Invoke remove actions before deleting */
		if (*src_table).flags
			& (4 as libc::c_uint
				| 256 as libc::c_uint
				| 4096 as libc::c_uint
				| 16384 as libc::c_uint
				| 32768 as libc::c_uint)
			!= 0
		{
			ecs_run_remove_actions(
				world,
				src_table,
				src_data,
				src_row,
				1 as libc::c_int,
				removed,
				1 as libc::c_int != 0,
			);
		}
	}
	ecs_table_delete(world, src_table, src_data, src_row, 1 as libc::c_int != 0);
}
/* Updating component monitors is a relatively expensive operation that only
 * happens for entities that are monitored. The approach balances the amount of
 * processing between the operation on the entity vs the amount of work that
 * needs to be done to rematch queries, as a simple brute force approach does
 * not scale when there are many tables / queries. Therefore we need to do a bit
 * of bookkeeping that is more intelligent than simply flipping a flag */
unsafe extern "C" fn update_component_monitor_w_array(
	mut mon: *mut ecs_component_monitor_t,
	mut entities: *mut ecs_entities_t,
) -> bool {
	let mut childof_changed: bool = 0 as libc::c_int != 0;
	if entities.is_null() {
		return 0 as libc::c_int != 0;
	}
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < (*entities).count {
		let mut component: ecs_entity_t = *(*entities).array.offset(i as isize);
		if component < 256 as libc::c_int as libc::c_ulong {
			ecs_component_monitor_mark(mon, component);
		} else if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			childof_changed = 1 as libc::c_int != 0
		}
		i += 1
	}
	return childof_changed;
}
unsafe extern "C" fn update_component_monitors(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut added: *mut ecs_entities_t,
	mut removed: *mut ecs_entities_t,
) {
	let mut childof_changed: bool =
		update_component_monitor_w_array(&mut (*world).component_monitors, added);
	childof_changed |= update_component_monitor_w_array(&mut (*world).component_monitors, removed);
	/* If this entity is a parent, check if anything changed that could impact
	 * its place in the hierarchy. If so, we need to mark all of the parent's
	 * entities as dirty. */
	if childof_changed as libc::c_int != 0
		&& !(_ecs_map_get(
			(*world).child_tables,
			::std::mem::size_of::<*mut ecs_vector_t>() as libc::c_ulong as ecs_size_t,
			entity,
		) as *mut *mut ecs_vector_t)
			.is_null()
	{
		let mut type_0: ecs_type_t = ecs_get_type(world, entity);
		let mut entities: ecs_entities_t = ecs_type_to_entities(type_0);
		update_component_monitor_w_array(&mut (*world).parent_monitors, &mut entities);
	};
}
unsafe extern "C" fn commit(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut dst_table: *mut ecs_table_t,
	mut added: *mut ecs_entities_t,
	mut removed: *mut ecs_entities_t,
) {
	let mut src_table: *mut ecs_table_t = (*info).table;
	if src_table == dst_table {
		/* If source and destination table are the same no action is needed */
		/* However, if a component was added in the process of traversing a
		 * table, this suggests that a case switch could have occured. */
		if !added.is_null()
			&& (*added).count != 0
			&& !src_table.is_null()
			&& (*src_table).flags & 65536 as libc::c_uint != 0
		{
			ecs_components_switch(world, (*info).data, (*info).row, 1 as libc::c_int, added);
		}
		return;
	}
	if !src_table.is_null() {
		let mut src_data: *mut ecs_data_t = (*info).data;
		if !(*dst_table).type_0.is_null() {
			(*info).row = move_entity(
				world,
				entity,
				info,
				src_table,
				src_data,
				(*info).row,
				dst_table,
				added,
				removed,
			);
			(*info).table = dst_table
		} else {
			delete_entity(world, src_table, src_data, (*info).row, removed);
			_ecs_sparse_set(
				(*world).store.entity_index,
				::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
				entity,
				&mut {
					let mut init = ecs_record_t {
						table: 0 as *mut ecs_table_t,
						row: ((*info).is_watched as libc::c_int == 1 as libc::c_int) as libc::c_int
							* -(1 as libc::c_int),
					};
					init
				} as *mut ecs_record_t as *mut libc::c_void,
			);
		}
	} else if !(*dst_table).type_0.is_null() {
		(*info).row = new_entity(world, entity, info, dst_table, added);
		(*info).table = dst_table
	}
	/* If the entity is being watched, it is being monitored for changes and
	 * requires rematching systems when components are added or removed. This
	 * ensures that systems that rely on components from containers or prefabs
	 * update the matched tables when the application adds or removes a
	 * component from, for example, a container. */
	if (*info).is_watched {
		update_component_monitors(world, entity, added, removed);
	}
}
unsafe extern "C" fn get_base_component(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut previous: ecs_entity_t,
	mut component: ecs_entity_t,
) -> *mut libc::c_void {
	let mut type_0: ecs_type_t = (*(*info).table).type_0;
	let mut type_buffer: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut p: int32_t = -(1 as libc::c_int);
	let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
	while ptr.is_null() && {
		p = find_prefab(type_0, p);
		(p) != -(1 as libc::c_int)
	} {
		let mut prefab: ecs_entity_t = *type_buffer.offset(p as isize)
			& !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
		/* Detect cycles with two entities */
		if prefab == previous {
			continue;
		}
		let mut prefab_info: ecs_entity_info_t = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		if ecs_get_info(world, prefab, &mut prefab_info) as libc::c_int != 0
			&& !prefab_info.table.is_null()
		{
			ptr = get_component(&mut prefab_info, component);
			if ptr.is_null() {
				ptr = get_base_component(world, stage, prefab, &mut prefab_info, entity, component)
			}
		}
	}
	return ptr;
}
unsafe extern "C" fn new(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut to_add: *mut ecs_entities_t,
) {
	let mut info: ecs_entity_info_t = {
		let mut init = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		init
	};
	let mut table: *mut ecs_table_t = ecs_table_traverse_add(
		world,
		(*world).stage.scope_table,
		to_add,
		0 as *mut ecs_entities_t,
	);
	new_entity(world, entity, &mut info, table, to_add);
}
unsafe extern "C" fn new_w_data(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut component_ids: *mut ecs_entities_t,
	mut count: int32_t,
	mut component_data: *mut *mut libc::c_void,
	mut row_out: *mut int32_t,
) -> *const ecs_entity_t {
	let mut sparse_count: int32_t = ecs_sparse_count((*world).store.entity_index);
	let mut ids: *const ecs_entity_t = ecs_sparse_new_ids((*world).store.entity_index, count);
	let mut type_0: ecs_type_t = (*table).type_0;
	if type_0.is_null() {
		return ids;
	}
	let mut component_array: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: 0 as *mut ecs_entity_t,
			count: 0,
		};
		init
	};
	if component_ids.is_null() {
		component_ids = &mut component_array;
		component_array.array = _ecs_vector_first(
			type_0,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		component_array.count = ecs_vector_count(type_0)
	}
	let mut data: *mut ecs_data_t = ecs_table_get_or_create_data(table);
	let mut row: int32_t = ecs_table_appendn(world, table, data, count, ids);
	let mut added: ecs_entities_t = ecs_type_to_entities(type_0);
	/* Update entity index. */
	let mut i: libc::c_int = 0;
	let mut record_ptrs: *mut *mut ecs_record_t = _ecs_vector_first(
		(*data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_record_t;
	i = 0 as libc::c_int;
	while i < count {
		let ref mut fresh19 = *record_ptrs.offset((row + i) as isize);
		*fresh19 = _ecs_sparse_set(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			*ids.offset(i as isize),
			&mut {
				let mut init = ecs_record_t {
					table: table,
					row: row + i + 1 as libc::c_int,
				};
				init
			} as *mut ecs_record_t as *mut libc::c_void,
		) as *mut ecs_record_t;
		i += 1
	}
	ecs_defer_none(world, &mut (*world).stage);
	let mut set_mask: ecs_comp_set_t = {
		let mut init = ecs_comp_set_t {
			hi_count: 0 as libc::c_int,
			hi_array: [0; 32],
			lo_mask: [0; 4],
		};
		init
	};
	ecs_run_add_actions(
		world,
		table,
		data,
		row,
		count,
		&mut added,
		&mut set_mask,
		1 as libc::c_int != 0,
		component_data.is_null(),
	);
	if !component_data.is_null() {
		/* Set components that we're setting in the component mask so the init
		 * actions won't call OnSet triggers for them. This ensures we won't
		 * call OnSet triggers multiple times for the same component */
		let mut c_i: int32_t = 0;
		c_i = 0 as libc::c_int;
		while c_i < (*component_ids).count {
			let mut c: ecs_entity_t = *(*component_ids).array.offset(c_i as isize);
			if c >= 256 as libc::c_int as libc::c_ulong {
				break;
			}
			comp_mask_set(&mut set_mask, c);
			/* Copy component data */
			let mut src_ptr: *mut libc::c_void = *component_data.offset(c_i as isize);
			if !src_ptr.is_null() {
				/* Bulk copy column data into new table */
				let mut table_index: int32_t = ecs_type_index_of(type_0, c);
				let mut column: *mut ecs_column_t =
					&mut *(*data).columns.offset(table_index as isize) as *mut ecs_column_t;
				let mut size: int16_t = (*column).size;
				let mut alignment: int16_t = (*column).alignment;
				let mut ptr: *mut libc::c_void = _ecs_vector_first(
					(*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
				);
				ptr = (ptr as uintptr_t).wrapping_add((size as libc::c_int * row) as uintptr_t)
					as *mut libc::c_void;
				let mut cdata: *mut ecs_c_info_t = ecs_get_c_info(world, c);
				let mut copy: ecs_copy_t = None;
				if !cdata.is_null() && {
					copy = (*cdata).lifecycle.copy;
					copy.is_some()
				} {
					let mut entities: *mut ecs_entity_t = _ecs_vector_first(
						(*data).entities,
						::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
							as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
						} as int16_t,
					) as *mut ecs_entity_t;
					copy.expect("non-null function pointer")(
						world,
						c,
						entities,
						entities,
						ptr,
						src_ptr,
						ecs_to_size_t(size as int64_t),
						count,
						(*cdata).lifecycle.ctx,
					);
				} else {
					memcpy(ptr, src_ptr, (size as libc::c_int * count) as size_t);
				}
			}
			c_i += 1
		}
		ecs_run_set_systems(
			world,
			&mut added,
			table,
			data,
			row,
			count,
			1 as libc::c_int != 0,
		);
	}
	ecs_run_monitors(
		world,
		table,
		(*table).monitors,
		row,
		count,
		0 as *mut ecs_vector_t,
	);
	ecs_defer_flush(world, &mut (*world).stage);
	if !row_out.is_null() {
		*row_out = row
	}
	ids = ecs_sparse_ids((*world).store.entity_index);
	return &*ids.offset(sparse_count as isize) as *const ecs_entity_t;
}
unsafe extern "C" fn has_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut type_0: ecs_type_t,
	mut match_any: bool,
	mut match_prefabs: bool,
) -> bool {
	if entity == 0 {
		return 0 as libc::c_int != 0;
	}
	if type_0.is_null() {
		return 1 as libc::c_int != 0;
	}
	let mut world_arg: *mut ecs_world_t = world;
	let mut entity_type: ecs_type_t = ecs_get_type(world_arg, entity);
	return ecs_type_contains(world, entity_type, type_0, match_any, match_prefabs)
		!= 0 as libc::c_int as libc::c_ulong;
}
unsafe extern "C" fn add_remove(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut to_add: *mut ecs_entities_t,
	mut to_remove: *mut ecs_entities_t,
) {
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	ecs_get_info(world, entity, &mut info);
	let mut add_buffer: [ecs_entity_t; 32] = [0; 32];
	let mut remove_buffer: [ecs_entity_t; 32] = [0; 32];
	let mut added: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: add_buffer.as_mut_ptr(),
			count: 0,
		};
		init
	};
	let mut removed: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: remove_buffer.as_mut_ptr(),
			count: 0,
		};
		init
	};
	let mut src_table: *mut ecs_table_t = info.table;
	let mut dst_table: *mut ecs_table_t =
		ecs_table_traverse_remove(world, src_table, to_remove, &mut removed);
	dst_table = ecs_table_traverse_add(world, dst_table, to_add, &mut added);
	commit(
		world,
		entity,
		&mut info,
		dst_table,
		&mut added,
		&mut removed,
	);
}
unsafe extern "C" fn add_entities_w_info(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut components: *mut ecs_entities_t,
) {
	let mut buffer: [ecs_entity_t; 32] = [0; 32];
	let mut added: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: buffer.as_mut_ptr(),
			count: 0,
		};
		init
	};
	let mut src_table: *mut ecs_table_t = (*info).table;
	let mut dst_table: *mut ecs_table_t =
		ecs_table_traverse_add(world, src_table, components, &mut added);
	commit(
		world,
		entity,
		info,
		dst_table,
		&mut added,
		0 as *mut ecs_entities_t,
	);
}
unsafe extern "C" fn remove_entities_w_info(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut components: *mut ecs_entities_t,
) {
	let mut buffer: [ecs_entity_t; 32] = [0; 32];
	let mut removed: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: buffer.as_mut_ptr(),
			count: 0,
		};
		init
	};
	let mut src_table: *mut ecs_table_t = (*info).table;
	let mut dst_table: *mut ecs_table_t =
		ecs_table_traverse_remove(world, src_table, components, &mut removed);
	commit(
		world,
		entity,
		info,
		dst_table,
		0 as *mut ecs_entities_t,
		&mut removed,
	);
}
unsafe extern "C" fn add_entities(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut components: *mut ecs_entities_t,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if ecs_defer_add(world, stage, entity, components) {
		return;
	}
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	ecs_get_info(world, entity, &mut info);
	let mut buffer: [ecs_entity_t; 32] = [0; 32];
	let mut added: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: buffer.as_mut_ptr(),
			count: 0,
		};
		init
	};
	let mut src_table: *mut ecs_table_t = info.table;
	let mut dst_table: *mut ecs_table_t =
		ecs_table_traverse_add(world, src_table, components, &mut added);
	commit(
		world,
		entity,
		&mut info,
		dst_table,
		&mut added,
		0 as *mut ecs_entities_t,
	);
	ecs_defer_flush(world, stage);
}
unsafe extern "C" fn remove_entities(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut components: *mut ecs_entities_t,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if ecs_defer_remove(world, stage, entity, components) {
		return;
	}
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	ecs_get_info(world, entity, &mut info);
	let mut buffer: [ecs_entity_t; 32] = [0; 32];
	let mut removed: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: buffer.as_mut_ptr(),
			count: 0,
		};
		init
	};
	let mut src_table: *mut ecs_table_t = info.table;
	let mut dst_table: *mut ecs_table_t =
		ecs_table_traverse_remove(world, src_table, components, &mut removed);
	commit(
		world,
		entity,
		&mut info,
		dst_table,
		0 as *mut ecs_entities_t,
		&mut removed,
	);
	ecs_defer_flush(world, stage);
}
unsafe extern "C" fn get_mutable(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
	mut info: *mut ecs_entity_info_t,
	mut is_added: *mut bool,
) -> *mut libc::c_void {
	let mut dst: *mut libc::c_void = 0 as *mut libc::c_void;
	if ecs_get_info(world, entity, info) {
		dst = get_component(info, component)
	}
	let mut table: *mut ecs_table_t = (*info).table;
	if dst.is_null() {
		let mut to_add: ecs_entities_t = {
			let mut init = ecs_entities_t {
				array: &mut component,
				count: 1 as libc::c_int,
			};
			init
		};
		add_entities_w_info(world, entity, info, &mut to_add);
		/* Reobtain info, as triggers could have changed the entity */
		ecs_get_info(world, entity, info);
		dst = get_component(info, component);
		if !is_added.is_null() {
			*is_added = table != (*info).table
		}
		return dst;
	} else {
		if !is_added.is_null() {
			*is_added = 0 as libc::c_int != 0
		}
		return dst;
	};
}
/* Get actual row from record row */
/* -- Private functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_record_to_row(
	mut row: int32_t,
	mut is_watched_out: *mut bool,
) -> int32_t {
	let mut is_watched: bool = row < 0 as libc::c_int;
	row = row * -(is_watched as libc::c_int * 2 as libc::c_int - 1 as libc::c_int)
		- 1 as libc::c_int * (row != 0 as libc::c_int) as libc::c_int;
	*is_watched_out = is_watched;
	return row;
}
/* Convert actual row to record row */
#[no_mangle]
pub unsafe extern "C" fn ecs_row_to_record(mut row: int32_t, mut is_watched: bool) -> int32_t {
	return (row + 1 as libc::c_int)
		* -(is_watched as libc::c_int * 2 as libc::c_int - 1 as libc::c_int);
}
/* Convert type to entity array */
#[no_mangle]
pub unsafe extern "C" fn ecs_type_to_entities(mut type_0: ecs_type_t) -> ecs_entities_t {
	return {
		let mut init = ecs_entities_t {
			array: _ecs_vector_first(
				type_0,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t,
			count: ecs_vector_count(type_0),
		};
		init
	};
}
// //////////////////////////////////////////////////////////////////////////////
// // Entity API
// //////////////////////////////////////////////////////////////////////////////
/* Mark an entity as being watched. This is used to trigger automatic rematching
 * when entities used in system expressions change their components. */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_watch(mut world: *mut ecs_world_t, mut entity: ecs_entity_t) {
	let mut record: *mut ecs_record_t = _ecs_sparse_get_sparse(
		(*world).store.entity_index,
		::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
		entity,
	) as *mut ecs_record_t;
	if record.is_null() {
		let mut new_record: ecs_record_t = {
			let mut init = ecs_record_t {
				table: 0 as *mut ecs_table_t,
				row: -(1 as libc::c_int),
			};
			init
		};
		_ecs_sparse_set(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			entity,
			&mut new_record as *mut ecs_record_t as *mut libc::c_void,
		);
	} else if (*record).row > 0 as libc::c_int {
		(*record).row *= -(1 as libc::c_int)
	} else if (*record).row == 0 as libc::c_int {
		/* If entity is empty, there is no index to change the sign of. In
		 * this case, set the index to -1, and assign an empty type. */
		(*record).row = -(1 as libc::c_int);
		(*record).table = 0 as *mut ecs_table_t
	};
}
/* Does one of the entity containers has specified component */
#[no_mangle]
pub unsafe extern "C" fn ecs_find_in_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut component: ecs_entity_t,
	mut flags: ecs_entity_t,
) -> ecs_entity_t {
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count(type_0);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut current_block_1: u64;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		let mut c: ecs_entity_t = *c_ptr;
		if flags != 0 {
			if c & flags != flags {
				current_block_1 = 4988723283678924448;
			} else {
				current_block_1 = 17216689946888361452;
			}
		} else {
			current_block_1 = 17216689946888361452;
		}
		match current_block_1 {
			17216689946888361452 => {
				let mut e: ecs_entity_t =
					c & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
				if component != 0 {
					let mut component_type: ecs_type_t = ecs_get_type(world, e);
					if !ecs_type_has_entity(world, component_type, component) {
						current_block_1 = 4988723283678924448;
					} else {
						current_block_1 = 11050875288958768710;
					}
				} else {
					current_block_1 = 11050875288958768710;
				}
				match current_block_1 {
					4988723283678924448 => {}
					_ => return e,
				}
			}
			_ => {}
		}
		c_ptr_i += 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
/* * @} */
/* *
 * @defgroup creating_entities Creating Entities
 * @{
 */
/* * Create new entity id.
 * This operation returns an unused entity id.
 *
 * @param world The world.
 * @return The new entity id.
 */
/* -- Public functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_new_id(mut world: *mut ecs_world_t) -> ecs_entity_t {
	let mut entity: ecs_entity_t = 0;
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	if thread_count >= 1 as libc::c_int {
		/* Can't atomically increase number above max int */
		entity = ecs_os_api.ainc_.expect("non-null function pointer")(
			&mut (*world).stats.last_id as *mut ecs_entity_t as *mut int32_t,
		) as ecs_entity_t
	} else {
		entity = ecs_sparse_new_id((*world).store.entity_index)
	}
	return entity;
}
/* * Create new component id.
 * This operation returns a new component id. Component ids are the same as
 * entity ids, but can make use of the [1 .. ECS_HI_COMPONENT_ID] range.
 *
 * This operation does not recycle ids.
 *
 * @param world The world.
 * @return The new component id.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_new_component_id(mut world: *mut ecs_world_t) -> ecs_entity_t {
	(*world).in_progress;
	if (*world).stats.last_component_id >= 256 as libc::c_int as libc::c_ulong {
		/* If the low component ids are depleted, return a regular entity id */
		return ecs_new_id(world);
	} else {
		let fresh20 = (*world).stats.last_component_id;
		(*world).stats.last_component_id = (*world).stats.last_component_id.wrapping_add(1);
		return fresh20;
	};
}
/* * Create new entity.
 * This operation creates a new entity initialized with a type. This operation
 * recycles ids.
 *
 * @param world The world.
 * @param type The type to initialize the new entity with.
 * @return The new entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_new_w_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut entity: ecs_entity_t = ecs_new_id(world);
	if !type_0.is_null() || (*world).stage.scope != 0 {
		let mut to_add: ecs_entities_t = ecs_type_to_entities(type_0);
		if ecs_defer_new(world, stage, entity, &mut to_add) {
			return entity;
		}
		new(world, entity, &mut to_add);
		ecs_defer_flush(world, stage);
	} else {
		_ecs_sparse_set(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			entity,
			&mut {
				let mut init = ecs_record_t {
					table: 0 as *mut ecs_table_t,
					row: 0,
				};
				init
			} as *mut ecs_record_t as *mut libc::c_void,
		);
	}
	return entity;
}
/* * Create new entity.
 * This operation creates a new entity with a single entity in its type. The
 * entity may contain type roles. This operation recycles ids.
 *
 * @param world The world.
 * @param entity The entity to initialize the new entity with.
 * @return The new entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_new_w_entity(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut entity: ecs_entity_t = ecs_new_id(world);
	if component != 0 || (*stage).scope != 0 {
		let mut to_add: ecs_entities_t = {
			let mut init = ecs_entities_t {
				array: &mut component,
				count: 1 as libc::c_int,
			};
			init
		};
		if ecs_defer_new(world, stage, entity, &mut to_add) {
			return entity;
		}
		let mut old_scope: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
		if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			old_scope = ecs_set_scope(world, 0 as libc::c_int as ecs_entity_t)
		}
		new(world, entity, &mut to_add);
		if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			ecs_set_scope(world, old_scope);
		}
		ecs_defer_flush(world, stage);
	} else {
		_ecs_sparse_set(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			entity,
			&mut {
				let mut init = ecs_record_t {
					table: 0 as *mut ecs_table_t,
					row: 0,
				};
				init
			} as *mut ecs_record_t as *mut libc::c_void,
		);
	}
	return entity;
}
/* * Create N new entities and initialize components.
 * This operation is the same as ecs_bulk_new_w_type, but initializes components
 * with the provided component array. Instead of a type the operation accepts an
 * array of component identifiers (entities). The component arrays need to be
 * provided in the same order as the component identifiers.
 *
 * @param world The world.
 * @param components Array with component identifiers.
 * @param count The number of entities to create.
 * @param data The data arrays to initialize the components with.
 * @return The first entity id of the newly created entities.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_bulk_new_w_data(
	mut world: *mut ecs_world_t,
	mut count: int32_t,
	mut components: *mut ecs_entities_t,
	mut data: *mut libc::c_void,
) -> *const ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut ids: *const ecs_entity_t = 0 as *const ecs_entity_t;
	if ecs_defer_bulk_new(
		world,
		stage,
		count,
		components,
		data as *mut *mut libc::c_void,
		&mut ids,
	) {
		return ids;
	}
	let mut type_0: ecs_type_t = ecs_type_find(world, (*components).array, (*components).count);
	let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
	ids = new_w_data(
		world,
		table,
		0 as *mut ecs_entities_t,
		count,
		data as *mut *mut libc::c_void,
		0 as *mut int32_t,
	);
	ecs_defer_flush(world, stage);
	return ids;
}
/* * Create N new entities.
 * This operation is the same as ecs_new_w_type, but creates N entities
 * instead of one and does not recycle ids.
 *
 * @param world The world.
 * @param type The type.
 * @param count The number of entities to create.
 * @return The first entity id of the newly created entities.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_bulk_new_w_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut count: int32_t,
) -> *const ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut ids: *const ecs_entity_t = 0 as *const ecs_entity_t;
	let mut components: ecs_entities_t = ecs_type_to_entities(type_0);
	if ecs_defer_bulk_new(
		world,
		stage,
		count,
		&mut components,
		0 as *mut *mut libc::c_void,
		&mut ids,
	) {
		return ids;
	}
	let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
	ids = new_w_data(
		world,
		table,
		0 as *mut ecs_entities_t,
		count,
		0 as *mut *mut libc::c_void,
		0 as *mut int32_t,
	);
	ecs_defer_flush(world, stage);
	return ids;
}
/* * Create N new entities.
 * This operation is the same as ecs_new_w_entity, but creates N entities
 * instead of one and does not recycle ids.
 *
 * @param world The world.
 * @param entity The entity.
 * @param count The number of entities to create.
 * @return The first entity id of the newly created entities.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_bulk_new_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut count: int32_t,
) -> *const ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut components: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut entity,
			count: 1 as libc::c_int,
		};
		init
	};
	let mut ids: *const ecs_entity_t = 0 as *const ecs_entity_t;
	if ecs_defer_bulk_new(
		world,
		stage,
		count,
		&mut components,
		0 as *mut *mut libc::c_void,
		&mut ids,
	) {
		return ids;
	}
	let mut table: *mut ecs_table_t = ecs_table_find_or_create(world, &mut components);
	ids = new_w_data(
		world,
		table,
		0 as *mut ecs_entities_t,
		count,
		0 as *mut *mut libc::c_void,
		0 as *mut int32_t,
	);
	ecs_defer_flush(world, stage);
	return ids;
}
/* * @} */
/* *
 * @defgroup deleting Deleting Entities and components
 * @{
 */
/* * Clear all components.
 * This operation will clear all components from an entity but will not delete
 * the entity itself. This effectively prevents the entity id from being
 * recycled.
 *
 * @param world The world.
 * @param entity The entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_clear(mut world: *mut ecs_world_t, mut entity: ecs_entity_t) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if ecs_defer_clear(world, stage, entity) {
		return;
	}
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	info.table = 0 as *mut ecs_table_t;
	ecs_get_info(world, entity, &mut info);
	let mut table: *mut ecs_table_t = info.table;
	if !table.is_null() {
		let mut type_0: ecs_type_t = (*table).type_0;
		/* Remove all components */
		let mut to_remove: ecs_entities_t = ecs_type_to_entities(type_0);
		remove_entities_w_info(world, entity, &mut info, &mut to_remove);
	}
	ecs_defer_flush(world, stage);
}
/* * Delete children of an entity.
 * This operation deletes all children of a parent entity. If a parent has no
 * children this operation has no effect.
 *
 * @param world The world.
 * @param parent The parent entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_delete_children(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
) {
	let mut child_tables: *mut ecs_vector_t =
		_ecs_map_get_ptr((*world).child_tables, parent) as *mut ecs_vector_t;
	if !child_tables.is_null() {
		let mut tables: *mut *mut ecs_table_t = _ecs_vector_first(
			child_tables,
			::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_table_t;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count(child_tables);
		i = 0 as libc::c_int;
		while i < count {
			let mut table: *mut ecs_table_t = *tables.offset(i as isize);
			/* Recursively delete entities of children */
			let mut data: *mut ecs_data_t = ecs_table_get_data(table);
			if !data.is_null() {
				let mut entities: *mut ecs_entity_t = _ecs_vector_first(
					(*data).entities,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				let mut child: int32_t = 0;
				let mut child_count: int32_t = ecs_vector_count((*data).entities);
				child = 0 as libc::c_int;
				while child < child_count {
					ecs_delete_children(world, *entities.offset(child as isize));
					child += 1
				}
			}
			/* Clear components from table (invokes destructors, OnRemove) */
			ecs_table_clear(world, table);
			/* Delete table */
			ecs_delete_table(world, table);
			i += 1
		}
		ecs_vector_free(child_tables);
	}
	ecs_map_remove((*world).child_tables, parent);
}
/* * Delete an entity.
 * This operation will delete an entity and all of its components. The entity id
 * will be recycled. Repeatedly calling ecs_delete without ecs_new,
 * ecs_new_w_entity or ecs_new_w_type will cause a memory leak as it will cause
 * the list with ids that can be recycled to grow unbounded.
 *
 * @param world The world.
 * @param entity The entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_delete(mut world: *mut ecs_world_t, mut entity: ecs_entity_t) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if ecs_defer_delete(world, stage, entity) {
		return;
	}
	let mut r: *mut ecs_record_t = _ecs_sparse_remove_get(
		(*world).store.entity_index,
		::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
		entity,
	) as *mut ecs_record_t;
	if !r.is_null() {
		let mut info: ecs_entity_info_t = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		set_info_from_record(entity, &mut info, r);
		if info.is_watched {
			ecs_delete_children(world, entity);
		}
		/* If entity has components, remove them */
		let mut table: *mut ecs_table_t = info.table;
		if !table.is_null() {
			let mut type_0: ecs_type_t = (*table).type_0;
			let mut to_remove: ecs_entities_t = ecs_type_to_entities(type_0);
			delete_entity(world, table, info.data, info.row, &mut to_remove);
			(*r).table = 0 as *mut ecs_table_t
		}
		(*r).row = 0 as libc::c_int
	}
	ecs_defer_flush(world, stage);
}
/* * Add a type to an entity.
 * This operation adds a type to an entity. The resulting type of the entity
 * will be the union of the previous type and the provided type. If the added
 * type did not have new components, this operation will have no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The type to add.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_add_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut type_0: ecs_type_t,
) {
	let mut components: ecs_entities_t = ecs_type_to_entities(type_0);
	add_entities(world, entity, &mut components);
}
/* * @} */
/* *
 * @defgroup adding_removing Adding & Removing
 * @{
 */
/* * Add an entity to an entity.
 * This operation adds a single entity to the type of an entity. Type roles may
 * be used in combination with the added entity. If the entity already has the
 * entity, this operation will have no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param entity_add The entity to add.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_add_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut to_add: ecs_entity_t,
) {
	let mut components: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut to_add,
			count: 1 as libc::c_int,
		};
		init
	};
	add_entities(world, entity, &mut components);
}
/* * Remove a type from an entity.
 * This operation removes a type to an entity. The resulting type of the entity
 * will be the difference of the previous type and the provided type. If the
 * type did not overlap with the entity type, this operation has no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The type to remove.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_remove_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut type_0: ecs_type_t,
) {
	let mut components: ecs_entities_t = ecs_type_to_entities(type_0);
	remove_entities(world, entity, &mut components);
}
/* * Add a component, type or tag to an entity.
 * This operation adds a type to an entity. The resulting type of the entity
 * will be the union of the previous type and the provided type. If the added
 * type did not have new components, this operation will have no side effects.
 *
 * This operation accepts variables declared by ECS_COMPONENT, ECS_TYPE and
 * ECS_TAG.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component, type or tag to add.
 */
/* * Remove an entity from an entity.
 * This operation removes a single entity from the type of an entity. Type roles
 * may be used in combination with the added entity. If the entity does not have
 * the entity, this operation will have no side effects.
 *
 * @param world The world.
 * @param entity The entity.
 * @param entity_remove The entity to remove.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_remove_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut to_remove: ecs_entity_t,
) {
	let mut components: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut to_remove,
			count: 1 as libc::c_int,
		};
		init
	};
	remove_entities(world, entity, &mut components);
}
/* * Remove a component, type or tag from an entity.
 * This operation removes a type to an entity. The resulting type of the entity
 * will be the difference of the previous type and the provided type. If the
 * type did not overlap with the entity type, this operation has no side effects.
 *
 * This operation accepts variables declared by ECS_COMPONENT, ECS_TYPE and
 * ECS_TAG.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component, type or tag to remove.
 */
/* * Add / remove entity from entities matching a filter.
 * Combination of ecs_add_entity and ecs_remove_entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_add The entity to add.
 * @param to_remove The entity to remove.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_add_remove_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut to_add: ecs_entity_t,
	mut to_remove: ecs_entity_t,
) {
	let mut components_add: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut to_add,
			count: 1 as libc::c_int,
		};
		init
	};
	let mut components_remove: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut to_remove,
			count: 1 as libc::c_int,
		};
		init
	};
	add_remove(world, entity, &mut components_add, &mut components_remove);
}
/* * Add / remove type from entities matching a filter.
 * Combination of ecs_add_type and ecs_remove_type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_add The type to add.
 * @param to_remove The type to remove.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_add_remove_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut to_add: ecs_type_t,
	mut to_remove: ecs_type_t,
) {
	let mut components_add: ecs_entities_t = ecs_type_to_entities(to_add);
	let mut components_remove: ecs_entities_t = ecs_type_to_entities(to_remove);
	add_remove(world, entity, &mut components_add, &mut components_remove);
}
/* * Create N new entities.
 * This operation is the same as ecs_new, but creates N entities
 * instead of one and does not recycle ids.
 *
 * @param world The world.
 * @param component The component type.
 * @param count The number of entities to create.
 * @return The first entity id of the newly created entities.
 */
/* * Clone an entity
 * This operation clones the components of one entity into another entity. If
 * no destination entity is provided, a new entity will be created. Component
 * values are not copied unless copy_value is true.
 *
 * @param world The world.
 * @param dst The entity to copy the components to.
 * @param src The entity to copy the components from.
 * @param copy_value If true, the value of components will be copied to dst.
 * @return The destination entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_clone(
	mut world: *mut ecs_world_t,
	mut dst: ecs_entity_t,
	mut src: ecs_entity_t,
	mut copy_value: bool,
) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if dst == 0 {
		dst = ecs_new_id(world)
	}
	if ecs_defer_clone(world, stage, dst, src, copy_value) {
		return dst;
	}
	let mut src_info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	let mut found: bool = ecs_get_info(world, src, &mut src_info);
	let mut src_table: *mut ecs_table_t = src_info.table;
	if !found || src_table.is_null() {
		return dst;
	}
	let mut src_type: ecs_type_t = (*src_table).type_0;
	let mut to_add: ecs_entities_t = ecs_type_to_entities(src_type);
	let mut dst_info: ecs_entity_info_t = {
		let mut init = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		init
	};
	dst_info.row = new_entity(world, dst, &mut dst_info, src_table, &mut to_add);
	if copy_value {
		ecs_table_move(
			world,
			dst,
			src,
			src_table,
			dst_info.data,
			dst_info.row,
			src_table,
			src_info.data,
			src_info.row,
		);
		let mut i: libc::c_int = 0;
		i = 0 as libc::c_int;
		while i < to_add.count {
			ecs_run_set_systems(
				world,
				&mut to_add,
				src_table,
				src_info.data,
				dst_info.row,
				1 as libc::c_int,
				1 as libc::c_int != 0,
			);
			i += 1
		}
	}
	ecs_defer_flush(world, stage);
	return dst;
}
/* * @} */
/* *
 * @defgroup getting Getting Components
 * @{
 */
/* * Get an immutable pointer to a component.
 * This operation obtains a const pointer to the requested component. The
 * operation accepts the component entity id.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
) -> *const libc::c_void {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
	let mut found: bool = ecs_get_info(world, entity, &mut info);
	if found {
		if info.table.is_null() {
			return 0 as *const libc::c_void;
		}
		ptr = get_component(&mut info, component);
		if ptr.is_null() {
			if component != 6 as libc::c_int as libc::c_ulong
				&& component != (256 as libc::c_int + 1 as libc::c_int) as libc::c_ulong
			{
				ptr = get_base_component(
					world,
					stage,
					entity,
					&mut info,
					0 as libc::c_int as ecs_entity_t,
					component,
				)
			}
		}
	}
	return ptr;
}
/* -- Get cached pointer -- */
/* * Get an immutable reference to a component.
 * This operation is similar to ecs_get_w_entity but it stores temporary
 * information in a `ecs_ref_t` value which allows subsequent lookups to be
 * faster.
 *
 * @param world The world.
 * @param ref Pointer to a ecs_ref_t value. Must be initialized.
 * @param entity The entity.
 * @param component The entity id of the component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_ref_w_entity(
	mut world: *mut ecs_world_t,
	mut ref_0: *mut ecs_ref_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
) -> *const libc::c_void {
	let mut record: *mut ecs_record_t = (*ref_0).record;
	entity |= (*ref_0).entity;
	if record.is_null() {
		record = _ecs_sparse_get_sparse(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			entity,
		) as *mut ecs_record_t
	}
	if record.is_null() || (*record).table.is_null() {
		return 0 as *const libc::c_void;
	}
	let mut table: *mut ecs_table_t = (*record).table;
	if (*ref_0).record == record
		&& (*ref_0).table == table as *mut libc::c_void
		&& (*ref_0).row == (*record).row
		&& (*ref_0).alloc_count == (*table).alloc_count
	{
		return (*ref_0).ptr;
	}
	component |= (*ref_0).component;
	(*ref_0).entity = entity;
	(*ref_0).component = component;
	(*ref_0).table = table as *mut libc::c_void;
	(*ref_0).row = (*record).row;
	(*ref_0).alloc_count = (*table).alloc_count;
	let mut info: ecs_entity_info_t = {
		let mut init = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		init
	};
	set_info_from_record(entity, &mut info, record);
	(*ref_0).ptr = get_component(&mut info, component);
	(*ref_0).record = record;
	return (*ref_0).ptr;
}
/* * Get an immutable reference to a component.
 * Same as ecs_get_ref_w_entity, but accepts the typename of a component.
 *
 * @param world The world.
 * @param ref Pointer to a ecs_ref_t value. Must be initialized.
 * @param entity The entity.
 * @param component The component to obtain.
 * @return The component pointer, NULL if the entity does not have the component.
 */
/* * Get a mutable pointer to a component.
 * This operation is similar to ecs_get_w_entity but it returns a mutable
 * pointer. If this operation is invoked from inside a system, the entity will
 * be staged and a pointer to the staged component will be returned.
 *
 * If the entity did not yet have the component, the component will be added by
 * this operation. In this case the is_added out parameter will be set to true.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component to obtain.
 * @param is_added Out parameter that returns true if the component was added.
 * @return The component pointer.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_mut_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
	mut is_added: *mut bool,
) -> *mut libc::c_void {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut result: *mut libc::c_void = 0 as *mut libc::c_void;
	if ecs_defer_set(
		world,
		stage,
		EcsOpMut,
		entity,
		component,
		0 as libc::c_int,
		0 as *const libc::c_void,
		&mut result,
		is_added,
	) {
		return result;
	}
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	result = get_mutable(world, entity, component, &mut info, is_added);
	ecs_defer_flush(world, stage);
	return result;
}
/* * Signal that a component has been modified.
 * This operation allows an application to signal to Flecs that a component has
 * been modified. As a result, OnSet systems will be invoked.
 *
 * This operation is commonly used together with ecs_get_mut.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component that was modified.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_modified_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if ecs_defer_modified(world, stage, entity, component) {
		return;
	}
	let mut info: ecs_entity_info_t = {
		let mut init = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		init
	};
	if ecs_get_info(world, entity, &mut info) {
		let mut added: ecs_entities_t = {
			let mut init = ecs_entities_t {
				array: &mut component,
				count: 1 as libc::c_int,
			};
			init
		};
		ecs_run_set_systems(
			world,
			&mut added,
			info.table,
			info.data,
			info.row,
			1 as libc::c_int,
			0 as libc::c_int != 0,
		);
	}
	ecs_defer_flush(world, stage);
}
unsafe extern "C" fn assign_ptr_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
	mut size: size_t,
	mut ptr: *mut libc::c_void,
	mut is_move: bool,
	mut notify: bool,
) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut added: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut component,
			count: 1 as libc::c_int,
		};
		init
	};
	if entity == 0 {
		entity = ecs_new_id(world);
		let mut scope: ecs_entity_t = (*stage).scope;
		if scope != 0 {
			ecs_add_entity(
				world,
				entity,
				(1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					| scope,
			);
		}
	}
	if ecs_defer_set(
		world,
		stage,
		EcsOpSet,
		entity,
		component,
		ecs_from_size_t(size),
		ptr,
		0 as *mut *mut libc::c_void,
		0 as *mut bool,
	) {
		return entity;
	}
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	let mut dst: *mut libc::c_void =
		get_mutable(world, entity, component, &mut info, 0 as *mut bool);
	/* This can no longer happen since we defer operations */
	if !ptr.is_null() {
		let mut real_id: ecs_entity_t = ecs_component_id_from_id(world, component);
		let mut cdata: *mut ecs_c_info_t = get_c_info(world, real_id);
		if !cdata.is_null() {
			if is_move {
				let mut move_0: ecs_move_t = (*cdata).lifecycle.move_0;
				if move_0.is_some() {
					move_0.expect("non-null function pointer")(
						world,
						real_id,
						&mut entity,
						&mut entity,
						dst,
						ptr,
						size,
						1 as libc::c_int,
						(*cdata).lifecycle.ctx,
					);
				} else {
					memcpy(dst, ptr, ecs_from_size_t(size) as size_t);
				}
			} else {
				let mut copy: ecs_copy_t = (*cdata).lifecycle.copy;
				if copy.is_some() {
					copy.expect("non-null function pointer")(
						world,
						real_id,
						&mut entity,
						&mut entity,
						dst,
						ptr,
						size,
						1 as libc::c_int,
						(*cdata).lifecycle.ctx,
					);
				} else {
					memcpy(dst, ptr, ecs_from_size_t(size) as size_t);
				}
			}
		} else {
			memcpy(dst, ptr, ecs_from_size_t(size) as size_t);
		}
	} else {
		memset(dst, 0 as libc::c_int, size);
	}
	ecs_table_mark_dirty(info.table, component);
	if notify {
		ecs_run_set_systems(
			world,
			&mut added,
			info.table,
			info.data,
			info.row,
			1 as libc::c_int,
			0 as libc::c_int != 0,
		);
	}
	ecs_defer_flush(world, stage);
	return entity;
}
/* * Signal that a component has been modified.
 * Same as ecs_modified_w_entity but accepts a component typename.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The component that was modified.
 */
/* * @} */
/* *
 * @defgroup setting Setting Components
 * @{
 */
/* * Set the value of a component.
 * This operation allows an application to set the value of a component. The
 * operation is equivalent to calling ecs_get_mut and ecs_modified.
 *
 * If the provided entity is 0, a new entity will be created.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of the component to set.
 * @param size The size of the pointer to the value.
 * @param ptr The pointer to the value.
 * @return The entity. A new entity if no entity was provided.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_ptr_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
	mut size: size_t,
	mut ptr: *const libc::c_void,
) -> ecs_entity_t {
	/* Safe to cast away const: function won't modify if move arg is false */
	return assign_ptr_w_entity(
		world,
		entity,
		component,
		size,
		ptr as *mut libc::c_void,
		0 as libc::c_int != 0,
		1 as libc::c_int != 0,
	);
}
/* * Add / remove component, type or tag from entity.
 * Combination of ecs_add and ecs_remove.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_add The component, type or tag to add.
 * @param to_remove The component, type or tag to remove.
 */
/* * @} */
/* *
 * @defgroup traits Traits
 * @{
 */
/* * Add a trait
 * This operation adds a trait from an entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity for which to remove the trait.
 * @param trait The trait to remove.
 */
/* * Remove a trait
 * This operation removes a trait from an entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity for which to remove the trait.
 * @param trait The trait to remove.
 */
/* * Test if an entity has a trait.
 * This operation returns true if the entity has the provided trait for the
 * specified component in its type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity.
 * @param trait The entity.
 * @return True if the entity has the trait, false if not.
 */
/* * Set trait for component.
 * This operation adds a trait for an entity and component. Traits can be added
 * multiple times to the same entity, as long as it is for different components.
 *
 * Traits can be matched with systems by providing the TRAIT role to the
 * trait component in the system signature. A system will match multiple times
 * with the same entity if the trait is added for multiple components.
 *
 * * This operation can only be used with traits that are components.
 *
 * @param world The world.
 * @param e The entity.
 * @param component The component for which to add the trait.
 * @param trait The trait to add.
 */
/* * Set tag trait for component.
 * This operation is similar to ecs_set_trait, but is used for trait tags. When
 * a trait tag is set on an entity, the trait type is not used (tags have no
 * type) and instead the component type is used.
 *
 * This operation can only be used with traits that are not components.
 *
 * @param world The world.
 * @param e The entity.
 * @param component The component for which to add the trait.
 * @param trait The trait to add.
 */
/* * Get trait for component.
 * This operation obtains the value of a trait for a componetn that has been
 * added by ecs_set_trait.
 *
 * @param world The world.
 * @param e The entity.
 * @param component The component to which the trait was added.
 * @param trait The trait that was added.
 */
/* * Get trait tag for component.
 * This operation obtains the value of a trait for a componetn that has been
 * added by ecs_set_trait.
 *
 * @param world The world.
 * @param e The entity.
 * @param trait The trait that was added.
 * @param component The component to which the trait was added.
 */
/* * Get case for switch.
 * This operation gets the current case for the specified switch. If the current
 * switch is not set for the entity, the operation will return 0.
 *
 * @param world The world.
 * @param e The entity.
 * @param sw The switch for which to obtain the case.
 * @return The current case for the specified switch.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_case(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut sw_id: ecs_entity_t,
) -> ecs_entity_t {
	let mut info: ecs_entity_info_t = ecs_entity_info_t {
		record: 0 as *mut ecs_record_t,
		table: 0 as *mut ecs_table_t,
		data: 0 as *mut ecs_data_t,
		row: 0,
		is_watched: false,
	};
	if !ecs_get_info(world, entity, &mut info) || info.table.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	sw_id = sw_id
		| ((1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
	let mut table: *mut ecs_table_t = info.table;
	let mut data: *mut ecs_data_t = info.data;
	if data.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut type_0: ecs_type_t = (*table).type_0;
	let mut index: int32_t = ecs_type_index_of(type_0, sw_id);
	if index == -(1 as libc::c_int) {
		return 0 as libc::c_int as ecs_entity_t;
	}
	index -= (*table).sw_column_offset;
	let mut sw: *mut ecs_switch_t = (*(*data).sw_columns.offset(index as isize)).data;
	return ecs_switch_get(sw, info.row);
}
/* * @} */
/* *
 * @defgroup singleton Singleton components
 * @{
 */
/* *
 * @defgroup testing Testing Components
 * @{
 */
/* * Test if an entity has an entity.
 * This operation returns true if the entity has the provided entity in its
 * type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param to_check The entity to test for.
 * @return True if the entity has the entity, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_has_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
) -> bool {
	if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		let mut info: ecs_entity_info_t = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		if !ecs_get_info(world, entity, &mut info) {
			return 0 as libc::c_int != 0;
		}
		let mut table: *mut ecs_table_t = info.table;
		let mut index: int32_t = ecs_table_switch_from_case(world, table, component);
		let mut data: *mut ecs_data_t = info.data;
		let mut sw: *mut ecs_switch_t = (*(*data).sw_columns.offset(index as isize)).data;
		let mut value: ecs_entity_t = ecs_switch_get(sw, info.row);
		return value == component & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
	} else {
		let mut type_0: ecs_type_t = ecs_get_type(world, entity);
		return ecs_type_has_entity(world, type_0, component);
	};
}
/* * Test if an entity has a type.
 * This operation returns true if the entity has the provided type in its
 * type.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The type to test for.
 * @return True if the entity has the type, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_has_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut type_0: ecs_type_t,
) -> bool {
	return has_type(
		world,
		entity,
		type_0,
		1 as libc::c_int != 0,
		1 as libc::c_int != 0,
	);
}
/* * Get the parent of an entity.
 * This will return a parent of the entity that has the specified component. If
 * the component is 0, the operation will return the first parent that it finds
 * in the entity type (an entity with a CHILDOF role).
 *
 * @param world The world.
 * @param entity The entity.
 * @param component The entity id of a component that the parent must have.
 * @return The parent of the entity, 0 if no parent was found.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_parent_w_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
) -> ecs_entity_t {
	let mut type_0: ecs_type_t = ecs_get_type(world, entity);
	let mut parent: ecs_entity_t = ecs_find_in_type(
		world,
		type_0,
		component,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int,
	);
	return parent;
}
/* * Get the name of an entity.
 * This will return the name as specified in the EcsName component.
 *
 * @param world The world.
 * @param entity The entity.
 * @return The type of the entity, NULL if the entity has no name.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_name(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
) -> *const libc::c_char {
	if entity == (256 as libc::c_int + 26 as libc::c_int) as libc::c_ulong {
		return b"$\x00" as *const u8 as *const libc::c_char;
	}
	let mut id: *const EcsName =
		ecs_get_w_entity(world, entity, 6 as libc::c_int as ecs_entity_t) as *const EcsName;
	if !id.is_null() {
		return (*id).value;
	} else {
		return 0 as *const libc::c_char;
	};
}
/* *
 * @file type.h
 * @brief Type API.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_type_from_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
) -> ecs_type_t {
	if entity == 0 {
		return 0 as ecs_type_t;
	}
	let mut type_0: *const EcsType =
		ecs_get_w_entity(world, entity, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
	if !type_0.is_null() {
		return (*type_0).normalized;
	}
	return ecs_type_find(world, &mut entity, 1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_to_entity(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
) -> ecs_entity_t {
	if type_0.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	/* If array contains n entities, it cannot be reduced to a single entity */
	if ecs_vector_count(type_0) != 1 as libc::c_int {
		_ecs_abort(
			9 as libc::c_int,
			0 as *const libc::c_char,
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			17699 as libc::c_int,
		);
		abort();
	}
	return *(_ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t);
}
/* * Test if an entity owns component, type or tag.
 * This operation is similar to ecs_has, but will return false if the entity
 * does not own the component, which is the case if the component is defined on
 * a base entity with an INSTANCEOF role.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The component, type or tag to test for.
 * @return True if the entity owns the component, type or tag, false if not.
 */
/* * Test if an entity owns an entity.
 * This operation is similar to ecs_has, but will return false if the entity
 * does not own the entity, which is the case if the entity is defined on
 * a base entity with an INSTANCEOF role.
 *
 * @param world The world.
 * @param entity The entity.
 * @param type The entity to test for.
 * @return True if the entity owns the entity, false if not.
 */
/* * @} */
/* *
 * @defgroup metadata Entity Metadata
 * @{
 */
/* * Test whether an entity is alive.
 *
 * @param world The world.
 * @param e The entity.
 * @return True if the entity is alive, false if the entity is not alive.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_is_alive(mut world: *mut ecs_world_t, mut e: ecs_entity_t) -> bool {
	return ecs_sparse_is_alive((*world).store.entity_index, e);
}
/* * Test whether an entity exists.
 * Similar as ecs_is_alive, but ignores entity generation count.
 *
 * @param world The world.
 * @param e The entity.
 * @return True if the entity exists, false if the entity does not exist.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_exists(mut world: *mut ecs_world_t, mut e: ecs_entity_t) -> bool {
	return ecs_sparse_exists((*world).store.entity_index, e);
}
/* * Get the type of an entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @return The type of the entity, NULL if the entity has no components.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
) -> ecs_type_t {
	let mut record: *mut ecs_record_t = 0 as *mut ecs_record_t;
	record = _ecs_sparse_get_sparse(
		(*world).store.entity_index,
		::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
		entity,
	) as *mut ecs_record_t;
	let mut table: *mut ecs_table_t = 0 as *mut ecs_table_t;
	if !record.is_null() && {
		table = (*record).table;
		!table.is_null()
	} {
		return (*table).type_0;
	}
	return 0 as ecs_type_t;
}
/* * Count entities that have a type.
 * Returns the number of entities that have the specified type.
 *
 * @param world The world.
 * @param type The type.
 * @return The number of entities that have the type.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_count_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
) -> int32_t {
	if type_0.is_null() {
		return 0 as libc::c_int;
	}
	return ecs_count_w_filter(world, &mut {
		let mut init = ecs_filter_t {
			include: type_0,
			exclude: 0 as *const ecs_vector_t,
			include_kind: EcsMatchDefault,
			exclude_kind: EcsMatchDefault,
		};
		init
	});
}
/* * Count entities that have an entity.
 * Returns the number of entities that have the specified entity.
 *
 * @param world The world.
 * @param entity The entity.
 * @return The number of entities that have the entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_count_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
) -> int32_t {
	if entity == 0 {
		return 0 as libc::c_int;
	}
	let mut type_0: ecs_type_t = ecs_type_from_entity(world, entity);
	return ecs_count_w_filter(world, &mut {
		let mut init = ecs_filter_t {
			include: type_0,
			exclude: 0 as *const ecs_vector_t,
			include_kind: EcsMatchDefault,
			exclude_kind: EcsMatchDefault,
		};
		init
	});
}
/* * Count entities that match a filter.
 * Returns the number of entities that match the specified filter.
 *
 * @param world The world.
 * @param type The type.
 * @return The number of entities that match the specified filter.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_count_w_filter(
	mut world: *mut ecs_world_t,
	mut filter: *const ecs_filter_t,
) -> int32_t {
	let mut tables: *mut ecs_sparse_t = (*world).store.tables;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count(tables);
	let mut result: int32_t = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		if filter.is_null() || ecs_table_match_filter(world, table, filter) as libc::c_int != 0 {
			result += ecs_table_count(table)
		}
		i += 1
	}
	return result;
}
/* * Defer operations until end of frame.
 * When this operation is invoked while iterating, operations inbetween the
 * defer_begin and defer_end operations are executed at the end of the frame.
 *
 * This operation is thread safe.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_begin(mut world: *mut ecs_world_t) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if (*world).in_progress {
		ecs_stage_defer_begin(world, stage);
	} else {
		ecs_defer_none(world, stage);
	};
}
/* * End block of operations to defer.
 * See defer_begin.
 *
 * This operation is thread safe.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_end(mut world: *mut ecs_world_t) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	if (*world).in_progress {
		ecs_stage_defer_end(world, stage);
	} else {
		ecs_defer_flush(world, stage);
	};
}
unsafe extern "C" fn append_to_str(
	mut buffer: *mut *mut libc::c_char,
	mut str: *const libc::c_char,
	mut bytes_left: size_t,
	mut required: *mut size_t,
) -> size_t {
	let mut ptr: *mut libc::c_char = *buffer;
	let mut len: size_t = strlen(str);
	let mut to_write: size_t = 0;
	if bytes_left < len {
		to_write = bytes_left;
		bytes_left = 0 as libc::c_int as size_t
	} else {
		to_write = len;
		bytes_left = (bytes_left as libc::c_ulong).wrapping_sub(len) as size_t as size_t
	}
	if to_write != 0 {
		strcpy(ptr, str);
	}
	*required = (*required as libc::c_ulong).wrapping_add(len) as size_t as size_t;
	*buffer = (*buffer).offset(to_write as isize);
	return bytes_left;
}
/* * Convert type role to string.
 * This operation converts a type role to a string.
 *
 * @param world The world.
 * @param entity The entity containing the type role.
 * @return The type role string, or NULL if no type role is provided.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_role_str(mut entity: ecs_entity_t) -> *const libc::c_char {
	if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"CHILDOF\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"INSTANCEOF\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"TRAIT\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"SWITCH\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x79 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"XOR\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7a as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"OR\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7b as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"AND\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x78 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"NOT\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"SWITCH\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"CASE\x00" as *const u8 as *const libc::c_char;
	} else if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x75 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return b"OWNED\x00" as *const u8 as *const libc::c_char;
	} else {
		return b"UNKNOWN\x00" as *const u8 as *const libc::c_char;
	};
}
/* * Convert entity identifier to string.
 * This operation interprets type roles and translates them to a string.
 *
 * @param world The world.
 * @param entity The entity to convert to a string.
 * @param buffer The buffer in which to store the string.
 * @param buffer_len The length of the provided buffer.
 * @return The number of characters required to write the string.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_entity_str(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut buffer: *mut libc::c_char,
	mut buffer_len: size_t,
) -> size_t {
	let mut ptr: *mut libc::c_char = buffer;
	let mut bytes_left: size_t = buffer_len;
	let mut required: size_t = 0 as libc::c_int as size_t;
	if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int != 0 {
		let mut role: *const libc::c_char = ecs_role_str(entity);
		bytes_left = append_to_str(&mut ptr, role, bytes_left, &mut required);
		bytes_left = append_to_str(
			&mut ptr,
			b"|\x00" as *const u8 as *const libc::c_char,
			bytes_left,
			&mut required,
		)
	}
	let mut e: ecs_entity_t =
		entity & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
	if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		let mut lo: ecs_entity_t = e as uint32_t as ecs_entity_t;
		let mut hi: ecs_entity_t = (e >> 32 as libc::c_int) as uint32_t as ecs_entity_t;
		if hi != 0 {
			let mut hi_path: *mut libc::c_char = ecs_get_path_w_sep(
				world,
				0 as libc::c_int as ecs_entity_t,
				hi,
				0 as libc::c_int as ecs_entity_t,
				b".\x00" as *const u8 as *const libc::c_char,
				0 as *const libc::c_char,
			);
			bytes_left = append_to_str(&mut ptr, hi_path, bytes_left, &mut required);
			ecs_os_api.free_.expect("non-null function pointer")(hi_path as *mut libc::c_void);
			bytes_left = append_to_str(
				&mut ptr,
				b">\x00" as *const u8 as *const libc::c_char,
				bytes_left,
				&mut required,
			)
		}
		let mut lo_path: *mut libc::c_char = ecs_get_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			lo,
			0 as libc::c_int as ecs_entity_t,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		bytes_left = append_to_str(&mut ptr, lo_path, bytes_left, &mut required);
		ecs_os_api.free_.expect("non-null function pointer")(lo_path as *mut libc::c_void);
	} else {
		let mut path: *mut libc::c_char = ecs_get_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			e,
			0 as libc::c_int as ecs_entity_t,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		bytes_left = append_to_str(&mut ptr, path, bytes_left, &mut required);
		ecs_os_api.free_.expect("non-null function pointer")(path as *mut libc::c_void);
	}
	*ptr.offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
	return required;
}
unsafe extern "C" fn flush_bulk_new(mut world: *mut ecs_world_t, mut op: *mut ecs_op_t) {
	let mut ids: *mut ecs_entity_t = (*op).is._n.entities;
	let mut bulk_data: *mut *mut libc::c_void = (*op).is._n.bulk_data;
	if !bulk_data.is_null() {
		let mut components: *mut ecs_entity_t = (*op).components.array;
		let mut c: libc::c_int = 0;
		let mut c_count: libc::c_int = (*op).components.count;
		c = 0 as libc::c_int;
		while c < c_count {
			let mut component: ecs_entity_t = *components.offset(c as isize);
			let mut cptr: *const EcsComponent =
				ecs_get_w_entity(world, component, 1 as libc::c_int as ecs_entity_t)
					as *const EcsComponent;
			let mut size: size_t = ecs_to_size_t((*cptr).size as int64_t);
			let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
			let mut data: *mut libc::c_void = *bulk_data.offset(c as isize);
			let mut i: libc::c_int = 0;
			let mut count: libc::c_int = (*op).is._n.count;
			i = 0 as libc::c_int;
			ptr = data;
			while i < count {
				assign_ptr_w_entity(
					world,
					*ids.offset(i as isize),
					component,
					size,
					ptr,
					1 as libc::c_int != 0,
					1 as libc::c_int != 0,
				);
				i += 1;
				ptr = (ptr as uintptr_t).wrapping_add(size) as *mut libc::c_void
			}
			ecs_os_api.free_.expect("non-null function pointer")(data);
			c += 1
		}
		ecs_os_api.free_.expect("non-null function pointer")(bulk_data as *mut libc::c_void);
	} else {
		let mut i_0: libc::c_int = 0;
		let mut count_0: libc::c_int = (*op).is._n.count;
		i_0 = 0 as libc::c_int;
		while i_0 < count_0 {
			add_entities(world, *ids.offset(i_0 as isize), &mut (*op).components);
			i_0 += 1
		}
	}
	ecs_os_api.free_.expect("non-null function pointer")(ids as *mut libc::c_void);
}
unsafe extern "C" fn discard_op(mut world: *mut ecs_world_t, mut op: *mut ecs_op_t) {
	if (*op).kind as libc::c_uint != EcsOpBulkNew as libc::c_int as libc::c_uint {
		let mut value: *mut libc::c_void = (*op).is._1.value;
		if !value.is_null() {
			ecs_os_api.free_.expect("non-null function pointer")(value);
		}
	} else {
		let mut bulk_data: *mut *mut libc::c_void = (*op).is._n.bulk_data;
		if !bulk_data.is_null() {
			let mut i: int32_t = 0;
			let mut c_count: int32_t = (*op).components.count;
			i = 0 as libc::c_int;
			while i < c_count {
				let mut component: ecs_entity_t = *(*op).components.array.offset(i as isize);
				let mut cptr: *const EcsComponent =
					ecs_get_w_entity(world, component, 1 as libc::c_int as ecs_entity_t)
						as *const EcsComponent;
				let mut size: size_t = ecs_to_size_t((*cptr).size as int64_t);
				let mut c_info: *mut ecs_c_info_t = get_c_info(world, component);
				let mut dtor: ecs_xtor_t = None;
				dtor = (*c_info).lifecycle.dtor;
				if dtor.is_some() {
					dtor.expect("non-null function pointer")(
						world,
						component,
						(*op).is._n.entities,
						*bulk_data.offset(i as isize),
						size,
						(*op).is._n.count,
						(*c_info).lifecycle.ctx,
					);
				} else {
					ecs_os_api.free_.expect("non-null function pointer")(
						*bulk_data.offset(i as isize),
					);
				}
				i += 1
			}
			ecs_os_api.free_.expect("non-null function pointer")(bulk_data as *mut libc::c_void);
		}
	}
	let mut components: *mut ecs_entity_t = (*op).components.array;
	if !components.is_null() {
		ecs_os_api.free_.expect("non-null function pointer")(components as *mut libc::c_void);
	};
}
unsafe extern "C" fn valid_components(
	mut world: *mut ecs_world_t,
	mut entities: *mut ecs_entities_t,
) -> bool {
	let mut array: *mut ecs_entity_t = (*entities).array;
	let mut i: int32_t = 0;
	let mut count: int32_t = (*entities).count;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			e &= !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			if ecs_exists(world, e) as libc::c_int != 0 && !ecs_is_alive(world, e) {
				return 0 as libc::c_int != 0;
			}
		}
		i += 1
	}
	return 1 as libc::c_int != 0;
}
/* Leave safe section. Run all deferred commands. */
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_flush(mut world: *mut ecs_world_t, mut stage: *mut ecs_stage_t) {
	(*stage).defer -= 1;
	if (*stage).defer == 0 {
		let mut defer_queue: *mut ecs_vector_t = (*stage).defer_queue;
		(*stage).defer_queue = 0 as *mut ecs_vector_t;
		if !defer_queue.is_null() {
			let mut ops: *mut ecs_op_t = _ecs_vector_first(
				defer_queue,
				::std::mem::size_of::<ecs_op_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_op_t>() as libc::c_ulong as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_op_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_op_t;
			let mut i: int32_t = 0;
			let mut count: int32_t = ecs_vector_count(defer_queue);
			let mut current_block_31: u64;
			i = 0 as libc::c_int;
			while i < count {
				let mut op: *mut ecs_op_t = &mut *ops.offset(i as isize) as *mut ecs_op_t;
				let mut e: ecs_entity_t = (*op).is._1.entity;
				if (*op).kind as libc::c_uint == EcsOpBulkNew as libc::c_int as libc::c_uint {
					e = 0 as libc::c_int as ecs_entity_t
				}
				/* If entity is no longer alive, this could be because the queue
				 * contained both a delete and a subsequent add/remove/set which
				 * should be ignored. */
				if e != 0
					&& !ecs_is_alive(world, e)
					&& ecs_sparse_exists((*world).store.entity_index, e) as libc::c_int != 0
				{
					match (*op).kind as libc::c_uint {
						1 | 3 | 2 => {
							current_block_31 = 17407779659766490442;
						}
						_ => {
							discard_op(world, op);
							current_block_31 = 820271813250567934;
						}
					}
				} else {
					current_block_31 = 17407779659766490442;
				}
				match current_block_31 {
					17407779659766490442 =>
					/* If the operation is creating a new entity, the id
					 * can still be not alive. */
					{
						if (*op).components.count == 1 as libc::c_int {
							(*op).components.array = &mut (*op).component
						}
						let mut current_block_22: u64;
						match (*op).kind as libc::c_uint {
							1 => {
								if (*op).scope != 0 {
									ecs_add_entity(
										world,
										e,
										(1 as libc::c_int as uint64_t) << 63 as libc::c_int
											| (0x7d as libc::c_int as ecs_entity_t)
												<< 56 as libc::c_int | (*op).scope,
									);
								}
								current_block_22 = 2458191191200179997;
							}
							4 => {
								current_block_22 = 2458191191200179997;
							}
							5 => {
								remove_entities(world, e, &mut (*op).components);
								current_block_22 = 6450597802325118133;
							}
							2 => {
								ecs_clone(world, e, (*op).component, (*op).is._1.clone_value);
								current_block_22 = 6450597802325118133;
							}
							6 => {
								assign_ptr_w_entity(
									world,
									e,
									(*op).component,
									ecs_to_size_t((*op).is._1.size as int64_t),
									(*op).is._1.value,
									1 as libc::c_int != 0,
									1 as libc::c_int != 0,
								);
								current_block_22 = 6450597802325118133;
							}
							7 => {
								assign_ptr_w_entity(
									world,
									e,
									(*op).component,
									ecs_to_size_t((*op).is._1.size as int64_t),
									(*op).is._1.value,
									1 as libc::c_int != 0,
									0 as libc::c_int != 0,
								);
								current_block_22 = 6450597802325118133;
							}
							8 => {
								ecs_modified_w_entity(world, e, (*op).component);
								current_block_22 = 6450597802325118133;
							}
							9 => {
								ecs_delete(world, e);
								current_block_22 = 6450597802325118133;
							}
							10 => {
								ecs_clear(world, e);
								current_block_22 = 6450597802325118133;
							}
							3 => {
								flush_bulk_new(world, op);
								current_block_22 = 6450597802325118133;
							}
							0 | _ => {
								current_block_22 = 6450597802325118133;
							}
						}
						match current_block_22 {
							2458191191200179997 =>
							/* Fallthrough */
							{
								if valid_components(world, &mut (*op).components) {
									add_entities(world, e, &mut (*op).components);
								}
							}
							_ => {}
						}
						if (*op).components.count > 1 as libc::c_int {
							ecs_os_api.free_.expect("non-null function pointer")(
								(*op).components.array as *mut libc::c_void,
							);
						}
						if !(*op).is._1.value.is_null() {
							ecs_os_api.free_.expect("non-null function pointer")((*op).is._1.value);
						}
					}
					_ => {}
				}
				i += 1
			}
			if defer_queue != (*stage).defer_merge_queue {
				ecs_vector_free(defer_queue);
			}
		}
	};
}
unsafe extern "C" fn new_defer_op(mut stage: *mut ecs_stage_t) -> *mut ecs_op_t {
	let mut result: *mut ecs_op_t = _ecs_vector_add(
		&mut (*stage).defer_queue,
		::std::mem::size_of::<ecs_op_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_op_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_op_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_op_t;
	memset(
		result as *mut libc::c_void,
		0 as libc::c_int,
		::std::mem::size_of::<ecs_op_t>() as libc::c_ulong as ecs_size_t as size_t,
	);
	return result;
}
unsafe extern "C" fn new_defer_component_ids(
	mut op: *mut ecs_op_t,
	mut components: *mut ecs_entities_t,
) {
	let mut components_count: int32_t = (*components).count;
	if components_count == 1 as libc::c_int {
		let mut component: ecs_entity_t = *(*components).array.offset(0 as libc::c_int as isize);
		(*op).component = component;
		(*op).components = {
			let mut init = ecs_entities_t {
				array: 0 as *mut ecs_entity_t,
				count: 1 as libc::c_int,
			};
			init
		}
	} else if components_count != 0 {
		let mut array_size: ecs_size_t =
			components_count * ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t;
		(*op).components.array =
			ecs_os_api.malloc_.expect("non-null function pointer")(array_size) as *mut ecs_entity_t;
		memcpy(
			(*op).components.array as *mut libc::c_void,
			(*components).array as *const libc::c_void,
			array_size as size_t,
		);
		(*op).components.count = components_count
	} else {
		(*op).component = 0 as libc::c_int as ecs_entity_t;
		(*op).components = {
			let mut init = ecs_entities_t {
				array: 0 as *mut ecs_entity_t,
				count: 0,
			};
			init
		}
	};
}
unsafe extern "C" fn defer_add_remove(
	mut stage: *mut ecs_stage_t,
	mut op_kind: ecs_op_kind_t,
	mut entity: ecs_entity_t,
	mut components: *mut ecs_entities_t,
) -> bool {
	if (*stage).defer != 0 {
		let mut scope: ecs_entity_t = (*stage).scope;
		if !components.is_null() {
			if (*components).count == 0 && scope == 0 {
				return 1 as libc::c_int != 0;
			}
		}
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = op_kind;
		(*op).scope = scope;
		(*op).is._1.entity = entity;
		new_defer_component_ids(op, components);
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
// //////////////////////////////////////////////////////////////////////////////
// // Defer API
// //////////////////////////////////////////////////////////////////////////////
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_none(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
) -> bool {
	(*stage).defer += 1;
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_modified(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
) -> bool {
	if (*stage).defer != 0 {
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = EcsOpModified;
		(*op).component = component;
		(*op).is._1.entity = entity;
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_clone(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
	mut src: ecs_entity_t,
	mut clone_value: bool,
) -> bool {
	if (*stage).defer != 0 {
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = EcsOpClone;
		(*op).component = src;
		(*op).is._1.entity = entity;
		(*op).is._1.clone_value = clone_value;
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_delete(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
) -> bool {
	if (*stage).defer != 0 {
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = EcsOpDelete;
		(*op).is._1.entity = entity;
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_clear(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
) -> bool {
	if (*stage).defer != 0 {
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = EcsOpClear;
		(*op).is._1.entity = entity;
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_bulk_new(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut count: int32_t,
	mut components_ids: *mut ecs_entities_t,
	mut component_data: *mut *mut libc::c_void,
	mut ids_out: *mut *const ecs_entity_t,
) -> bool {
	if (*stage).defer != 0 {
		let mut ids: *mut ecs_entity_t = ecs_os_api.malloc_.expect("non-null function pointer")(
			count * ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		) as *mut ecs_entity_t;
		let mut defer_data: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
		/* Use ecs_new_id as this is thread safe */
		let mut i: libc::c_int = 0;
		i = 0 as libc::c_int;
		while i < count {
			*ids.offset(i as isize) = ecs_new_id(world);
			i += 1
		}
		/* Create private copy for component data */
		if !component_data.is_null() {
			let mut c: libc::c_int = 0;
			let mut c_count: libc::c_int = (*components_ids).count;
			let mut components: *mut ecs_entity_t = (*components_ids).array;
			defer_data = ecs_os_api.malloc_.expect("non-null function pointer")(
				::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as ecs_size_t * c_count,
			) as *mut *mut libc::c_void;
			c = 0 as libc::c_int;
			while c < c_count {
				let mut comp: ecs_entity_t = *components.offset(c as isize);
				let mut cptr: *const EcsComponent =
					ecs_get_w_entity(world, comp, 1 as libc::c_int as ecs_entity_t)
						as *const EcsComponent;
				let mut size: ecs_size_t = (*cptr).size;
				let mut data: *mut libc::c_void =
					ecs_os_api.malloc_.expect("non-null function pointer")(size * count);
				let ref mut fresh21 = *defer_data.offset(c as isize);
				*fresh21 = data;
				let mut cinfo: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
				let mut real_id: ecs_entity_t = ecs_component_id_from_id(world, comp);
				if real_id != 0 {
					cinfo = ecs_get_c_info(world, real_id)
				}
				let mut ctor: ecs_xtor_t = None;
				if !cinfo.is_null() && {
					ctor = (*cinfo).lifecycle.ctor;
					ctor.is_some()
				} {
					let mut ctx: *mut libc::c_void = (*cinfo).lifecycle.ctx;
					ctor.expect("non-null function pointer")(
						world,
						comp,
						ids,
						data,
						ecs_to_size_t(size as int64_t),
						count,
						ctx,
					);
					let mut move_0: ecs_move_t = None;
					move_0 = (*cinfo).lifecycle.move_0;
					if move_0.is_some() {
						move_0.expect("non-null function pointer")(
							world,
							comp,
							ids,
							ids,
							data,
							*component_data.offset(c as isize),
							ecs_to_size_t(size as int64_t),
							count,
							ctx,
						);
					} else {
						memcpy(
							data,
							*component_data.offset(c as isize),
							(size * count) as size_t,
						);
					}
				} else {
					memcpy(
						data,
						*component_data.offset(c as isize),
						(size * count) as size_t,
					);
				}
				c += 1
			}
		}
		/* Store data in op */
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = EcsOpBulkNew;
		(*op).is._n.entities = ids;
		(*op).is._n.bulk_data = defer_data;
		(*op).is._n.count = count;
		new_defer_component_ids(op, components_ids);
		*ids_out = ids;
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_new(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
	mut components: *mut ecs_entities_t,
) -> bool {
	return defer_add_remove(stage, EcsOpNew, entity, components);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_add(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
	mut components: *mut ecs_entities_t,
) -> bool {
	return defer_add_remove(stage, EcsOpAdd, entity, components);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_remove(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut entity: ecs_entity_t,
	mut components: *mut ecs_entities_t,
) -> bool {
	return defer_add_remove(stage, EcsOpRemove, entity, components);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_defer_set(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut op_kind: ecs_op_kind_t,
	mut entity: ecs_entity_t,
	mut component: ecs_entity_t,
	mut size: ecs_size_t,
	mut value: *const libc::c_void,
	mut value_out: *mut *mut libc::c_void,
	mut is_added: *mut bool,
) -> bool {
	if (*stage).defer != 0 {
		if size == 0 {
			let mut cptr: *const EcsComponent =
				ecs_get_w_entity(world, component, 1 as libc::c_int as ecs_entity_t)
					as *const EcsComponent;
			size = (*cptr).size
		}
		let mut op: *mut ecs_op_t = new_defer_op(stage);
		(*op).kind = op_kind;
		(*op).component = component;
		(*op).is._1.entity = entity;
		(*op).is._1.size = size;
		(*op).is._1.value = ecs_os_api.malloc_.expect("non-null function pointer")(size);
		if value.is_null() {
			value = ecs_get_w_entity(world, entity, component);
			if !is_added.is_null() {
				*is_added = value == 0 as *mut libc::c_void
			}
		}
		let mut c_info: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
		let mut real_id: ecs_entity_t = ecs_component_id_from_id(world, component);
		if real_id != 0 {
			c_info = ecs_get_c_info(world, real_id)
		}
		let mut ctor: ecs_xtor_t = None;
		if !c_info.is_null() && {
			ctor = (*c_info).lifecycle.ctor;
			ctor.is_some()
		} {
			ctor.expect("non-null function pointer")(
				world,
				component,
				&mut entity,
				(*op).is._1.value,
				ecs_to_size_t(size as int64_t),
				1 as libc::c_int,
				(*c_info).lifecycle.ctx,
			);
			let mut copy: ecs_copy_t = None;
			if !value.is_null() {
				copy = (*c_info).lifecycle.copy;
				if copy.is_some() {
					copy.expect("non-null function pointer")(
						world,
						component,
						&mut entity,
						&mut entity,
						(*op).is._1.value,
						value,
						ecs_to_size_t(size as int64_t),
						1 as libc::c_int,
						(*c_info).lifecycle.ctx,
					);
				} else {
					memcpy((*op).is._1.value, value, size as size_t);
				}
			}
		} else if !value.is_null() {
			memcpy((*op).is._1.value, value, size as size_t);
		}
		if !value_out.is_null() {
			*value_out = (*op).is._1.value
		}
		return 1 as libc::c_int != 0;
	} else {
		(*stage).defer += 1
	}
	return 0 as libc::c_int != 0;
}
/* Merge stage with main stage */
#[no_mangle]
pub unsafe extern "C" fn ecs_stage_merge(mut world: *mut ecs_world_t, mut stage: *mut ecs_stage_t) {
	if ecs_vector_count((*stage).defer_merge_queue) != 0 {
		(*stage).defer += 1;
		(*stage).defer_queue = (*stage).defer_merge_queue;
		ecs_defer_flush(world, stage);
		ecs_vector_clear((*stage).defer_merge_queue);
	};
}
/* Begin defer for stage */
#[no_mangle]
pub unsafe extern "C" fn ecs_stage_defer_begin(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
) {
	ecs_defer_none(world, stage);
	if (*stage).defer == 1 as libc::c_int {
		(*stage).defer_queue = (*stage).defer_merge_queue
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_stage_defer_end(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
) {
	(*stage).defer -= 1;
	if (*stage).defer == 0 {
		(*stage).defer_merge_queue = (*stage).defer_queue;
		(*stage).defer_queue = 0 as *mut ecs_vector_t
	};
}
/* Post-frame merge actions */
#[no_mangle]
pub unsafe extern "C" fn ecs_stage_merge_post_frame(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
) {
	/* Execute post frame actions */
	let mut action_i: libc::c_int = 0;
	let mut action_count: libc::c_int = ecs_vector_count((*stage).post_frame_actions);
	let mut action_array: *mut ecs_action_elem_t = _ecs_vector_first(
		(*stage).post_frame_actions,
		::std::mem::size_of::<ecs_action_elem_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_action_elem_t;
	action_i = 0 as libc::c_int;
	while action_i < action_count {
		let mut action: *mut ecs_action_elem_t =
			&mut *action_array.offset(action_i as isize) as *mut ecs_action_elem_t;
		(*action).action.expect("non-null function pointer")(world, (*action).ctx);
		action_i += 1
	}
	ecs_vector_free((*stage).post_frame_actions);
	(*stage).post_frame_actions = 0 as *mut ecs_vector_t;
}
// //////////////////////////////////////////////////////////////////////////////
// // Stage API
// //////////////////////////////////////////////////////////////////////////////
/* Initialize stage data structures */
#[no_mangle]
pub unsafe extern "C" fn ecs_stage_init(mut world: *mut ecs_world_t, mut stage: *mut ecs_stage_t) {
	memset(
		stage as *mut libc::c_void,
		0 as libc::c_int,
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong,
	);
	if stage == &mut (*world).stage as *mut ecs_stage_t {
		(*stage).id = 0 as libc::c_int
	} else if stage == &mut (*world).temp_stage as *mut ecs_stage_t {
		(*stage).id = 1 as libc::c_int
	};
}
/* Deinitialize stage */
#[no_mangle]
pub unsafe extern "C" fn ecs_stage_deinit(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
) {
	ecs_vector_free((*stage).defer_queue);
	ecs_vector_free((*stage).defer_merge_queue);
}
/* * Resize the vector buffer */
unsafe extern "C" fn resize(
	mut vector: *mut ecs_vector_t,
	mut offset: int16_t,
	mut size: int32_t,
) -> *mut ecs_vector_t {
	let mut result: *mut ecs_vector_t = ecs_os_api.realloc_.expect("non-null function pointer")(
		vector as *mut libc::c_void,
		offset as libc::c_int + size,
	) as *mut ecs_vector_t;
	return result;
}
/* -- Public functions -- */
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_new(
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> *mut ecs_vector_t {
	let mut result: *mut ecs_vector_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		offset as libc::c_int + elem_size * elem_count,
	) as *mut ecs_vector_t;
	(*result).count = 0 as libc::c_int;
	(*result).size = elem_count;
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_from_array(
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
	mut array: *mut libc::c_void,
) -> *mut ecs_vector_t {
	let mut result: *mut ecs_vector_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		offset as libc::c_int + elem_size * elem_count,
	) as *mut ecs_vector_t;
	memcpy(
		(result as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void,
		array,
		(elem_size * elem_count) as size_t,
	);
	(*result).count = elem_count;
	(*result).size = elem_count;
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_vector_free(mut vector: *mut ecs_vector_t) {
	ecs_os_api.free_.expect("non-null function pointer")(vector as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_vector_clear(mut vector: *mut ecs_vector_t) {
	if !vector.is_null() {
		(*vector).count = 0 as libc::c_int
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_addn(
	mut array_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> *mut libc::c_void {
	if elem_count == 1 as libc::c_int {
		return _ecs_vector_add(array_inout, elem_size, offset);
	}
	let mut vector: *mut ecs_vector_t = *array_inout;
	if vector.is_null() {
		vector = _ecs_vector_new(elem_size, offset, 1 as libc::c_int);
		*array_inout = vector
	}
	let mut max_count: int32_t = (*vector).size;
	let mut old_count: int32_t = (*vector).count;
	let mut new_count: int32_t = old_count + elem_count;
	if new_count - 1 as libc::c_int >= max_count {
		if max_count == 0 {
			max_count = elem_count
		} else {
			while max_count < new_count {
				max_count *= 2 as libc::c_int
			}
		}
		vector = resize(vector, offset, max_count * elem_size);
		(*vector).size = max_count;
		*array_inout = vector
	}
	(*vector).count = new_count;
	return (vector as uintptr_t)
		.wrapping_add((offset as libc::c_int + elem_size * old_count) as uintptr_t)
		as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_add(
	mut array_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) -> *mut libc::c_void {
	let mut vector: *mut ecs_vector_t = *array_inout;
	let mut count: int32_t = 0;
	let mut size: int32_t = 0;
	if !vector.is_null() {
		count = (*vector).count;
		size = (*vector).size;
		if count >= size {
			size *= 2 as libc::c_int;
			if size == 0 {
				size = 2 as libc::c_int
			}
			vector = resize(vector, offset, size * elem_size);
			*array_inout = vector;
			(*vector).size = size
		}
		(*vector).count = count + 1 as libc::c_int;
		return (vector as uintptr_t)
			.wrapping_add((offset as libc::c_int + elem_size * count) as uintptr_t)
			as *mut libc::c_void;
	}
	vector = _ecs_vector_new(elem_size, offset, 2 as libc::c_int);
	*array_inout = vector;
	(*vector).count = 1 as libc::c_int;
	(*vector).size = 2 as libc::c_int;
	return (vector as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_move_index(
	mut dst: *mut *mut ecs_vector_t,
	mut src: *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut index: int32_t,
) -> int32_t {
	let mut dst_elem: *mut libc::c_void = _ecs_vector_add(dst, elem_size, offset);
	let mut src_elem: *mut libc::c_void = _ecs_vector_get(src, elem_size, offset, index);
	memcpy(dst_elem, src_elem, elem_size as size_t);
	return _ecs_vector_remove_index(src, elem_size, offset, index);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_remove(
	mut vector: *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem: *mut libc::c_void,
) -> int32_t {
	if elem.is_null() {
		return 0 as libc::c_int;
	}
	let mut count: int32_t = (*vector).count;
	let mut buffer: *mut libc::c_void =
		(vector as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
	let mut index: int32_t = (elem as *mut libc::c_char)
		.wrapping_offset_from(buffer as *mut libc::c_char) as libc::c_long
		as ecs_size_t
		/ elem_size;
	if index >= count {
		return count;
	}
	if index != count - 1 as libc::c_int {
		let mut last_elem: *mut libc::c_void = (buffer as uintptr_t)
			.wrapping_add((elem_size * (count - 1 as libc::c_int)) as uintptr_t)
			as *mut libc::c_void;
		memcpy(elem, last_elem, elem_size as size_t);
	}
	count -= 1;
	(*vector).count = count;
	return count;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_vector_remove_last(mut vector: *mut ecs_vector_t) {
	if !vector.is_null() && (*vector).count != 0 {
		(*vector).count -= 1
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_pop(
	mut vector: *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut value: *mut libc::c_void,
) -> bool {
	if vector.is_null() {
		return 0 as libc::c_int != 0;
	}
	let mut count: int32_t = (*vector).count;
	if count == 0 {
		return 0 as libc::c_int != 0;
	}
	let mut elem: *mut libc::c_void = (vector as uintptr_t)
		.wrapping_add((offset as libc::c_int + (count - 1 as libc::c_int) * elem_size) as uintptr_t)
		as *mut libc::c_void;
	if !value.is_null() {
		memcpy(value, elem, elem_size as size_t);
	}
	ecs_vector_remove_last(vector);
	return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_remove_index(
	mut vector: *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut index: int32_t,
) -> int32_t {
	let mut count: int32_t = (*vector).count;
	let mut buffer: *mut libc::c_void =
		(vector as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
	let mut elem: *mut libc::c_void =
		(buffer as uintptr_t).wrapping_add((index * elem_size) as uintptr_t) as *mut libc::c_void;
	count -= 1;
	if index != count {
		let mut last_elem: *mut libc::c_void = (buffer as uintptr_t)
			.wrapping_add((elem_size * count) as uintptr_t)
			as *mut libc::c_void;
		memcpy(elem, last_elem, elem_size as size_t);
	}
	(*vector).count = count;
	return count;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_reclaim(
	mut array_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) {
	let mut vector: *mut ecs_vector_t = *array_inout;
	let mut size: int32_t = (*vector).size;
	let mut count: int32_t = (*vector).count;
	if count < size {
		size = count;
		vector = resize(vector, offset, size * elem_size);
		(*vector).size = size;
		*array_inout = vector
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_vector_count(mut vector: *const ecs_vector_t) -> int32_t {
	if vector.is_null() {
		return 0 as libc::c_int;
	}
	return (*vector).count;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_vector_size(mut vector: *const ecs_vector_t) -> int32_t {
	if vector.is_null() {
		return 0 as libc::c_int;
	}
	return (*vector).size;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_set_size(
	mut array_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> int32_t {
	let mut vector: *mut ecs_vector_t = *array_inout;
	if vector.is_null() {
		*array_inout = _ecs_vector_new(elem_size, offset, elem_count);
		return elem_count;
	} else {
		let mut result: int32_t = (*vector).size;
		if elem_count < (*vector).count {
			elem_count = (*vector).count
		}
		if result < elem_count {
			vector = resize(vector, offset, elem_count * elem_size);
			(*vector).size = elem_count;
			*array_inout = vector;
			result = elem_count
		}
		return result;
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_grow(
	mut array_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> int32_t {
	let mut current: int32_t = ecs_vector_count(*array_inout);
	return _ecs_vector_set_size(array_inout, elem_size, offset, current + elem_count);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_set_count(
	mut array_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> int32_t {
	if (*array_inout).is_null() {
		*array_inout = _ecs_vector_new(elem_size, offset, elem_count)
	}
	(**array_inout).count = elem_count;
	let mut size: ecs_size_t = _ecs_vector_set_size(array_inout, elem_size, offset, elem_count);
	return size;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_set_min_size(
	mut vector_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> int32_t {
	if (*vector_inout).is_null() || (**vector_inout).size < elem_count {
		return _ecs_vector_set_size(vector_inout, elem_size, offset, elem_count);
	} else {
		return (**vector_inout).size;
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_set_min_count(
	mut vector_inout: *mut *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> int32_t {
	_ecs_vector_set_min_size(vector_inout, elem_size, offset, elem_count);
	let mut v: *mut ecs_vector_t = *vector_inout;
	if !v.is_null() && (*v).count < elem_count {
		(*v).count = elem_count
	}
	return (*v).count;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_first(
	mut vector: *const ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) -> *mut libc::c_void {
	if !vector.is_null() && (*vector).size != 0 {
		return (vector as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
	} else {
		return 0 as *mut libc::c_void;
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_get(
	mut vector: *const ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut index: int32_t,
) -> *mut libc::c_void {
	if vector.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut count: int32_t = (*vector).count;
	if index >= count {
		return 0 as *mut libc::c_void;
	}
	return (vector as uintptr_t)
		.wrapping_add((offset as libc::c_int + elem_size * index) as uintptr_t)
		as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_last(
	mut vector: *const ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) -> *mut libc::c_void {
	if !vector.is_null() {
		let mut count: int32_t = (*vector).count;
		if count == 0 {
			return 0 as *mut libc::c_void;
		} else {
			return (vector as uintptr_t).wrapping_add(
				(offset as libc::c_int + elem_size * (count - 1 as libc::c_int)) as uintptr_t,
			) as *mut libc::c_void;
		}
	} else {
		return 0 as *mut libc::c_void;
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_sort(
	mut vector: *mut ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut compare_action: ecs_comparator_t,
) {
	if vector.is_null() {
		return;
	}
	let mut count: int32_t = (*vector).count;
	let mut buffer: *mut libc::c_void =
		(vector as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
	if count > 1 as libc::c_int {
		qsort(buffer, count as size_t, elem_size as size_t, compare_action);
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_memory(
	mut vector: *const ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut allocd: *mut int32_t,
	mut used: *mut int32_t,
) {
	if vector.is_null() {
		return;
	}
	if !allocd.is_null() {
		*allocd += (*vector).size * elem_size + offset as libc::c_int
	}
	if !used.is_null() {
		*used += (*vector).count * elem_size
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_vector_copy(
	mut src: *const ecs_vector_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) -> *mut ecs_vector_t {
	if src.is_null() {
		return 0 as *mut ecs_vector_t;
	}
	let mut dst: *mut ecs_vector_t = _ecs_vector_new(elem_size, offset, (*src).size);
	memcpy(
		dst as *mut libc::c_void,
		src as *const libc::c_void,
		(offset as libc::c_int + elem_size * (*src).count) as size_t,
	);
	return dst;
}
/* Maximum issued sparse index */
unsafe extern "C" fn chunk_new(
	mut sparse: *mut ecs_sparse_t,
	mut chunk_index: int32_t,
) -> *mut chunk_t {
	let mut count: int32_t = ecs_vector_count((*sparse).chunks);
	let mut chunks: *mut chunk_t = 0 as *mut chunk_t;
	if count <= chunk_index {
		_ecs_vector_set_count(
			&mut (*sparse).chunks,
			::std::mem::size_of::<chunk_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
			} as int16_t,
			chunk_index + 1 as libc::c_int,
		);
		chunks = _ecs_vector_first(
			(*sparse).chunks,
			::std::mem::size_of::<chunk_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut chunk_t;
		memset(
			&mut *chunks.offset(count as isize) as *mut chunk_t as *mut libc::c_void,
			0 as libc::c_int,
			((1 as libc::c_int + chunk_index - count)
				* ::std::mem::size_of::<chunk_t>() as libc::c_ulong as ecs_size_t) as size_t,
		);
	} else {
		chunks = _ecs_vector_first(
			(*sparse).chunks,
			::std::mem::size_of::<chunk_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut chunk_t
	}
	let mut result: *mut chunk_t = &mut *chunks.offset(chunk_index as isize) as *mut chunk_t;
	/* Initialize sparse array with zero's, as zero is used to indicate that the
	 * sparse element has not been paired with a dense element. Use zero
	 * as this means we can take advantage of calloc having a possibly better
	 * performance than malloc + memset. */
	(*result).sparse = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t * 4096 as libc::c_int,
	) as *mut int32_t;
	/* Initialize the data array with zero's to guarantee that data is
	 * always initialized. When an entry is removed, data is reset back to
	 * zero. Initialize now, as this can take advantage of calloc. */
	(*result).data = ecs_os_api.calloc_.expect("non-null function pointer")(
		(*sparse).size * 4096 as libc::c_int,
	);
	return result;
}
unsafe extern "C" fn chunk_free(mut chunk: *mut chunk_t) {
	ecs_os_api.free_.expect("non-null function pointer")((*chunk).sparse as *mut libc::c_void);
	ecs_os_api.free_.expect("non-null function pointer")((*chunk).data);
}
unsafe extern "C" fn get_chunk(
	mut sparse: *const ecs_sparse_t,
	mut chunk_index: int32_t,
) -> *mut chunk_t {
	let mut result: *mut chunk_t = _ecs_vector_get(
		(*sparse).chunks,
		::std::mem::size_of::<chunk_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
		} as int16_t,
		chunk_index,
	) as *mut chunk_t;
	if !result.is_null() && (*result).sparse.is_null() {
		return 0 as *mut chunk_t;
	}
	return result;
}
unsafe extern "C" fn get_or_create_chunk(
	mut sparse: *mut ecs_sparse_t,
	mut chunk_index: int32_t,
) -> *mut chunk_t {
	let mut chunk: *mut chunk_t = get_chunk(sparse, chunk_index);
	if !chunk.is_null() {
		return chunk;
	}
	return chunk_new(sparse, chunk_index);
}
unsafe extern "C" fn grow_dense(mut sparse: *mut ecs_sparse_t) {
	_ecs_vector_add(
		&mut (*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	);
}
unsafe extern "C" fn strip_generation(mut index_out: *mut uint64_t) -> uint64_t {
	let mut index: uint64_t = *index_out;
	let mut gen: uint64_t = index & (0xffff as libc::c_int as uint64_t) << 32 as libc::c_int;
	*index_out = (*index_out as libc::c_ulong).wrapping_sub(gen) as uint64_t as uint64_t;
	return gen;
}
unsafe extern "C" fn assign_index(
	mut chunk: *mut chunk_t,
	mut dense_array: *mut uint64_t,
	mut index: uint64_t,
	mut dense: int32_t,
) {
	*(*chunk)
		.sparse
		.offset((index as int32_t & 0xfff as libc::c_int) as isize) = dense;
	*dense_array.offset(dense as isize) = index;
}
unsafe extern "C" fn inc_gen(mut index: uint64_t) -> uint64_t {
	return index & !((0xffff as libc::c_int as uint64_t) << 32 as libc::c_int)
		| ((index & (0xffff as libc::c_int as uint64_t) << 32 as libc::c_int)
			>> 32 as libc::c_int)
			.wrapping_add(1 as libc::c_int as libc::c_ulong)
			<< 32 as libc::c_int;
}
unsafe extern "C" fn inc_id(mut sparse: *mut ecs_sparse_t) -> uint64_t {
	let ref mut fresh22 = *(*sparse).max_id.offset(0 as libc::c_int as isize);
	*fresh22 = (*fresh22).wrapping_add(1);
	return *fresh22;
}
unsafe extern "C" fn get_id(mut sparse: *const ecs_sparse_t) -> uint64_t {
	return *(*sparse).max_id.offset(0 as libc::c_int as isize);
}
unsafe extern "C" fn set_id(mut sparse: *mut ecs_sparse_t, mut value: uint64_t) {
	*(*sparse).max_id.offset(0 as libc::c_int as isize) = value;
}
unsafe extern "C" fn create_id(mut sparse: *mut ecs_sparse_t, mut dense: int32_t) -> uint64_t {
	let mut index: uint64_t = inc_id(sparse);
	grow_dense(sparse);
	let mut chunk: *mut chunk_t =
		get_or_create_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	let mut dense_array: *mut uint64_t = _ecs_vector_first(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	assign_index(chunk, dense_array, index, dense);
	return index;
}
unsafe extern "C" fn new_index(mut sparse: *mut ecs_sparse_t) -> uint64_t {
	let mut dense: *mut ecs_vector_t = (*sparse).dense;
	let mut dense_count: int32_t = ecs_vector_count(dense);
	let fresh23 = (*sparse).count;
	(*sparse).count = (*sparse).count + 1;
	let mut count: int32_t = fresh23;
	if count < dense_count {
		/* If there are unused elements in the dense array, return first */
		let mut dense_array: *mut uint64_t = _ecs_vector_first(
			dense,
			::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut uint64_t;
		return *dense_array.offset(count as isize);
	} else {
		return create_id(sparse, count);
	};
}
unsafe extern "C" fn try_sparse_any(
	mut sparse: *const ecs_sparse_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	strip_generation(&mut index);
	let mut chunk: *mut chunk_t = get_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	if chunk.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	let mut dense: int32_t = *(*chunk).sparse.offset(offset as isize);
	let mut in_use: bool = dense != 0 && dense < (*sparse).count;
	if !in_use {
		return 0 as *mut libc::c_void;
	}
	return ((*chunk).data as uintptr_t).wrapping_add(((*sparse).size * offset) as uintptr_t)
		as *mut libc::c_void;
}
unsafe extern "C" fn try_sparse(
	mut sparse: *const ecs_sparse_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	let mut chunk: *mut chunk_t = get_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	if chunk.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	let mut dense: int32_t = *(*chunk).sparse.offset(offset as isize);
	let mut in_use: bool = dense != 0 && dense < (*sparse).count;
	if !in_use {
		return 0 as *mut libc::c_void;
	}
	let mut gen: uint64_t = strip_generation(&mut index);
	let mut dense_array: *mut uint64_t = _ecs_vector_first(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	let mut cur_gen: uint64_t = *dense_array.offset(dense as isize)
		& (0xffff as libc::c_int as uint64_t) << 32 as libc::c_int;
	if cur_gen != gen {
		return 0 as *mut libc::c_void;
	}
	return ((*chunk).data as uintptr_t).wrapping_add(((*sparse).size * offset) as uintptr_t)
		as *mut libc::c_void;
}
unsafe extern "C" fn get_sparse(
	mut sparse: *const ecs_sparse_t,
	mut dense: int32_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	strip_generation(&mut index);
	let mut chunk: *mut chunk_t = get_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	return ((*chunk).data as uintptr_t).wrapping_add(((*sparse).size * offset) as uintptr_t)
		as *mut libc::c_void;
}
unsafe extern "C" fn swap_dense(
	mut sparse: *mut ecs_sparse_t,
	mut chunk_a: *mut chunk_t,
	mut a: int32_t,
	mut b: int32_t,
) {
	let mut dense_array: *mut uint64_t = _ecs_vector_first(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	let mut index_a: uint64_t = *dense_array.offset(a as isize);
	let mut index_b: uint64_t = *dense_array.offset(b as isize);
	let mut chunk_b: *mut chunk_t =
		get_or_create_chunk(sparse, index_b as int32_t >> 12 as libc::c_int);
	assign_index(chunk_a, dense_array, index_a, b);
	assign_index(chunk_b, dense_array, index_b, a);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_new(mut size: ecs_size_t) -> *mut ecs_sparse_t {
	let mut result: *mut ecs_sparse_t = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_sparse_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_sparse_t;
	(*result).size = size;
	(*result).max_id_local = 18446744073709551615 as libc::c_ulong;
	(*result).max_id = &mut (*result).max_id_local;
	/* Consume first value in dense array as 0 is used in the sparse array to
	 * indicate that a sparse element hasn't been paired yet. */
	_ecs_vector_add(
		&mut (*result).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	);
	(*result).count = 1 as libc::c_int;
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_set_id_source(
	mut sparse: *mut ecs_sparse_t,
	mut id_source: *mut uint64_t,
) {
	(*sparse).max_id = id_source;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_clear(mut sparse: *mut ecs_sparse_t) {
	let mut chunk_i: libc::c_int = 0;
	let mut chunk_count: libc::c_int = ecs_vector_count((*sparse).chunks);
	let mut chunk_array: *mut chunk_t = _ecs_vector_first(
		(*sparse).chunks,
		::std::mem::size_of::<chunk_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<chunk_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut chunk_t;
	chunk_i = 0 as libc::c_int;
	while chunk_i < chunk_count {
		let mut chunk: *mut chunk_t = &mut *chunk_array.offset(chunk_i as isize) as *mut chunk_t;
		chunk_free(chunk);
		chunk_i += 1
	}
	ecs_vector_free((*sparse).chunks);
	_ecs_vector_set_count(
		&mut (*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		1 as libc::c_int,
	);
	(*sparse).chunks = 0 as *mut ecs_vector_t;
	(*sparse).count = 1 as libc::c_int;
	(*sparse).max_id_local = 0 as libc::c_int as uint64_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_free(mut sparse: *mut ecs_sparse_t) {
	if !sparse.is_null() {
		ecs_sparse_clear(sparse);
		ecs_vector_free((*sparse).dense);
		ecs_os_api.free_.expect("non-null function pointer")(sparse as *mut libc::c_void);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_new_id(mut sparse: *mut ecs_sparse_t) -> uint64_t {
	return new_index(sparse);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_new_ids(
	mut sparse: *mut ecs_sparse_t,
	mut new_count: int32_t,
) -> *const uint64_t {
	let mut dense_count: int32_t = ecs_vector_count((*sparse).dense);
	let mut count: int32_t = (*sparse).count;
	let mut remaining: int32_t = dense_count - count;
	let mut i: int32_t = 0;
	let mut to_create: int32_t = new_count - remaining;
	if to_create > 0 as libc::c_int {
		ecs_sparse_set_size(sparse, dense_count + to_create);
		let mut dense_array: *mut uint64_t = _ecs_vector_first(
			(*sparse).dense,
			::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut uint64_t;
		i = 0 as libc::c_int;
		while i < to_create {
			let mut index: uint64_t = create_id(sparse, count + i);
			*dense_array.offset((dense_count + i) as isize) = index;
			i += 1
		}
	}
	(*sparse).count += new_count;
	return _ecs_vector_get(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		count,
	) as *mut uint64_t;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_add(
	mut sparse: *mut ecs_sparse_t,
	mut size: ecs_size_t,
) -> *mut libc::c_void {
	let mut index: uint64_t = new_index(sparse);
	let mut chunk: *mut chunk_t = get_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	return ((*chunk).data as uintptr_t)
		.wrapping_add((size * (index as int32_t & 0xfff as libc::c_int)) as uintptr_t)
		as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_last_id(mut sparse: *mut ecs_sparse_t) -> uint64_t {
	let mut dense_array: *mut uint64_t = _ecs_vector_first(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	return *dense_array.offset(((*sparse).count - 1 as libc::c_int) as isize);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_get_or_create(
	mut sparse: *mut ecs_sparse_t,
	mut size: ecs_size_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	let mut gen: uint64_t = strip_generation(&mut index);
	let mut chunk: *mut chunk_t =
		get_or_create_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	let mut dense: int32_t = *(*chunk).sparse.offset(offset as isize);
	if dense != 0 {
		/* Check if element is alive. If element is not alive, update indices so
		 * that the first unused dense element points to the sparse element. */
		let mut count: int32_t = (*sparse).count;
		if dense == count {
			/* If dense is the next unused element in the array, simply increase
			 * the count to make it part of the alive set. */
			(*sparse).count += 1
		} else if dense > count {
			/* If dense is not alive, swap it with the first unused element. */
			swap_dense(sparse, chunk, dense, count);
			/* First unused element is now last used element */
			(*sparse).count += 1
		}
	} else {
		/* Element is not paired yet. Must add a new element to dense array */
		grow_dense(sparse);
		let mut dense_vector: *mut ecs_vector_t = (*sparse).dense;
		let mut dense_array: *mut uint64_t = _ecs_vector_first(
			dense_vector,
			::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut uint64_t;
		let mut dense_count: int32_t = ecs_vector_count(dense_vector) - 1 as libc::c_int;
		let fresh24 = (*sparse).count;
		(*sparse).count = (*sparse).count + 1;
		let mut count_0: int32_t = fresh24;
		/* If index is larger than max id, update max id */
		if index >= get_id(sparse) {
			set_id(
				sparse,
				index.wrapping_add(1 as libc::c_int as libc::c_ulong),
			);
		}
		if count_0 < dense_count {
			/* If there are unused elements in the list, move the first unused
			 * element to the end of the list */
			let mut unused: uint64_t = *dense_array.offset(count_0 as isize);
			let mut unused_chunk: *mut chunk_t =
				get_or_create_chunk(sparse, unused as int32_t >> 12 as libc::c_int);
			assign_index(unused_chunk, dense_array, unused, dense_count);
		}
		assign_index(chunk, dense_array, index, count_0);
		let ref mut fresh25 = *dense_array.offset(count_0 as isize);
		*fresh25 |= gen
	}
	return ((*chunk).data as uintptr_t).wrapping_add(((*sparse).size * offset) as uintptr_t)
		as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_set(
	mut sparse: *mut ecs_sparse_t,
	mut elem_size: ecs_size_t,
	mut index: uint64_t,
	mut value: *mut libc::c_void,
) -> *mut libc::c_void {
	let mut ptr: *mut libc::c_void = _ecs_sparse_get_or_create(sparse, elem_size, index);
	memcpy(ptr, value, elem_size as size_t);
	return ptr;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_remove_get(
	mut sparse: *mut ecs_sparse_t,
	mut size: ecs_size_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	let mut chunk: *mut chunk_t =
		get_or_create_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	let mut gen: uint64_t = strip_generation(&mut index);
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	let mut dense: int32_t = *(*chunk).sparse.offset(offset as isize);
	if dense != 0 {
		let mut dense_array: *mut uint64_t = _ecs_vector_first(
			(*sparse).dense,
			::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut uint64_t;
		let mut cur_gen: uint64_t = *dense_array.offset(dense as isize)
			& (0xffff as libc::c_int as uint64_t) << 32 as libc::c_int;
		if gen != cur_gen {
			/* Generation doesn't match which means that the provided entity is
			 * already not alive. */
			return 0 as *mut libc::c_void;
		}
		/* Increase generation */
		*dense_array.offset(dense as isize) = index | inc_gen(cur_gen);
		let mut count: int32_t = (*sparse).count;
		if dense == count - 1 as libc::c_int {
			/* If dense is the last used element, simply decrease count */
			(*sparse).count -= 1
		} else if dense < count {
			/* If element is alive, move it to unused elements */
			swap_dense(sparse, chunk, dense, count - 1 as libc::c_int);
			(*sparse).count -= 1
		}
		/* Reset memory to zero on remove */
		return ((*chunk).data as uintptr_t).wrapping_add(((*sparse).size * offset) as uintptr_t)
			as *mut libc::c_void;
	} else {
		/* Element is not paired and thus not alive, nothing to be done */
		return 0 as *mut libc::c_void;
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_remove(mut sparse: *mut ecs_sparse_t, mut index: uint64_t) {
	let mut ptr: *mut libc::c_void = _ecs_sparse_remove_get(sparse, 0 as libc::c_int, index);
	if !ptr.is_null() {
		memset(ptr, 0 as libc::c_int, (*sparse).size as size_t);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_set_generation(
	mut sparse: *mut ecs_sparse_t,
	mut index: uint64_t,
) {
	let mut chunk: *mut chunk_t =
		get_or_create_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	let mut index_w_gen: uint64_t = index;
	strip_generation(&mut index);
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	let mut dense: int32_t = *(*chunk).sparse.offset(offset as isize);
	if dense != 0 {
		/* Increase generation */
		let mut dense_array: *mut uint64_t = _ecs_vector_first(
			(*sparse).dense,
			::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut uint64_t;
		*dense_array.offset(dense as isize) = index_w_gen
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_exists(
	mut sparse: *mut ecs_sparse_t,
	mut index: uint64_t,
) -> bool {
	let mut chunk: *mut chunk_t =
		get_or_create_chunk(sparse, index as int32_t >> 12 as libc::c_int);
	strip_generation(&mut index);
	let mut offset: int32_t = index as int32_t & 0xfff as libc::c_int;
	let mut dense: int32_t = *(*chunk).sparse.offset(offset as isize);
	return dense != 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_get(
	mut sparse: *const ecs_sparse_t,
	mut size: ecs_size_t,
	mut dense_index: int32_t,
) -> *mut libc::c_void {
	dense_index += 1;
	let mut dense_array: *mut uint64_t = _ecs_vector_first(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	return get_sparse(
		sparse,
		dense_index,
		*dense_array.offset(dense_index as isize),
	);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_is_alive(
	mut sparse: *const ecs_sparse_t,
	mut index: uint64_t,
) -> bool {
	return !try_sparse(sparse, index).is_null();
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_get_sparse(
	mut sparse: *const ecs_sparse_t,
	mut size: ecs_size_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	return try_sparse(sparse, index);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_sparse_get_sparse_any(
	mut sparse: *mut ecs_sparse_t,
	mut size: ecs_size_t,
	mut index: uint64_t,
) -> *mut libc::c_void {
	return try_sparse_any(sparse, index);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_count(mut sparse: *const ecs_sparse_t) -> int32_t {
	if sparse.is_null() {
		return 0 as libc::c_int;
	}
	return (*sparse).count - 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_size(mut sparse: *const ecs_sparse_t) -> int32_t {
	if sparse.is_null() {
		return 0 as libc::c_int;
	}
	return ecs_vector_count((*sparse).dense) - 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_ids(mut sparse: *const ecs_sparse_t) -> *const uint64_t {
	return &mut *((_ecs_vector_first
		as unsafe extern "C" fn(
			_: *const ecs_vector_t,
			_: ecs_size_t,
			_: int16_t,
		) -> *mut libc::c_void)(
		(*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t)
		.offset(1 as libc::c_int as isize) as *mut uint64_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_set_size(
	mut sparse: *mut ecs_sparse_t,
	mut elem_count: int32_t,
) {
	_ecs_vector_set_size(
		&mut (*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		elem_count,
	);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_grow(mut sparse: *mut ecs_sparse_t, mut elem_count: int32_t) {
	_ecs_vector_grow(
		&mut (*sparse).dense,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		elem_count,
	);
}
unsafe extern "C" fn sparse_copy(mut dst: *mut ecs_sparse_t, mut src: *const ecs_sparse_t) {
	ecs_sparse_set_size(dst, ecs_sparse_size(src));
	let mut indices: *const uint64_t = ecs_sparse_ids(src);
	let mut size: ecs_size_t = (*src).size;
	let mut i: int32_t = 0;
	let mut count: int32_t = (*src).count;
	i = 0 as libc::c_int;
	while i < count - 1 as libc::c_int {
		let mut index: uint64_t = *indices.offset(i as isize);
		let mut src_ptr: *mut libc::c_void = _ecs_sparse_get_sparse(src, size, index);
		let mut dst_ptr: *mut libc::c_void = _ecs_sparse_get_or_create(dst, size, index);
		ecs_sparse_set_generation(dst, index);
		memcpy(dst_ptr, src_ptr, size as size_t);
		i += 1
	}
	set_id(dst, get_id(src));
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_copy(mut src: *const ecs_sparse_t) -> *mut ecs_sparse_t {
	if src.is_null() {
		return 0 as *mut ecs_sparse_t;
	}
	let mut dst: *mut ecs_sparse_t = _ecs_sparse_new((*src).size);
	sparse_copy(dst, src);
	return dst;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_restore(
	mut dst: *mut ecs_sparse_t,
	mut src: *const ecs_sparse_t,
) {
	(*dst).count = 1 as libc::c_int;
	if !src.is_null() {
		sparse_copy(dst, src);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_sparse_memory(
	mut sparse: *mut ecs_sparse_t,
	mut allocd: *mut int32_t,
	mut used: *mut int32_t,
) {
}
unsafe extern "C" fn ecs_name_writer_alloc(mut writer: *mut ecs_name_writer_t, mut len: int32_t) {
	(*writer).len = len;
	if (*writer).len > (*writer).max_len {
		ecs_os_api.free_.expect("non-null function pointer")((*writer).name as *mut libc::c_void);
		(*writer).name = ecs_os_api.malloc_.expect("non-null function pointer")((*writer).len)
			as *mut libc::c_char;
		(*writer).max_len = (*writer).len
	}
	(*writer).written = 0 as libc::c_int;
}
unsafe extern "C" fn ecs_name_writer_write(
	mut writer: *mut ecs_name_writer_t,
	mut buffer: *const libc::c_char,
) -> bool {
	let mut written: ecs_size_t = (*writer).len - (*writer).written;
	let mut name_ptr: *mut libc::c_char = ((*writer).name as uintptr_t)
		.wrapping_add((*writer).written as uintptr_t)
		as *mut libc::c_void as *mut libc::c_char;
	if written >= ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t {
		*(name_ptr as *mut int32_t) = *(buffer as *mut int32_t);
		(*writer).written += ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
		return (*writer).written != (*writer).len;
	} else {
		memcpy(
			name_ptr as *mut libc::c_void,
			buffer as *const libc::c_void,
			written as size_t,
		);
		(*writer).written += written;
		return 0 as libc::c_int != 0;
	};
}
unsafe extern "C" fn ecs_name_writer_reset(mut writer: *mut ecs_name_writer_t) {
	(*writer).name = 0 as *mut libc::c_char;
	(*writer).max_len = 0 as libc::c_int;
	(*writer).len = 0 as libc::c_int;
}
unsafe extern "C" fn ecs_table_writer_register_table(mut stream: *mut ecs_writer_t) {
	let mut world: *mut ecs_world_t = (*stream).world;
	let mut writer: *mut ecs_table_writer_t = &mut (*stream).table;
	let mut type_0: ecs_type_t = ecs_type_find(world, (*writer).type_array, (*writer).type_count);
	(*writer).table = ecs_table_from_type(world, type_0);
	ecs_os_api.free_.expect("non-null function pointer")((*writer).type_array as *mut libc::c_void);
	(*writer).type_array = 0 as *mut ecs_entity_t;
	let mut data: *mut ecs_data_t = ecs_table_get_or_create_data((*writer).table);
	if !(*data).entities.is_null() {
		/* Remove any existing entities from entity index */
		let mut e_ptr_i: libc::c_int = 0;
		let mut e_ptr_count: libc::c_int = ecs_vector_count((*data).entities);
		let mut e_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
			(*data).entities,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		e_ptr_i = 0 as libc::c_int;
		while e_ptr_i < e_ptr_count {
			let mut e_ptr: *mut ecs_entity_t =
				&mut *e_ptr_array.offset(e_ptr_i as isize) as *mut ecs_entity_t;
			ecs_sparse_remove((*world).store.entity_index, *e_ptr);
			/* Don't increase generation to ensure the restored data exactly
			 * matches the data in the blob */
			ecs_sparse_set_generation((*world).store.entity_index, *e_ptr);
			e_ptr_i += 1
		}
		return;
	} else {
		/* Set size of table to 0. This will initialize columns */
		ecs_table_set_size(world, (*writer).table, data, 0 as libc::c_int);
	};
}
unsafe extern "C" fn ecs_table_writer_finalize_table(mut stream: *mut ecs_writer_t) {
	let mut world: *mut ecs_world_t = (*stream).world;
	let mut writer: *mut ecs_table_writer_t = &mut (*stream).table;
	/* Register entities in table in entity index */
	let mut data: *mut ecs_data_t = ecs_table_get_data((*writer).table);
	let mut entity_vector: *mut ecs_vector_t = (*data).entities;
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		entity_vector,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(entity_vector);
	i = 0 as libc::c_int;
	while i < count {
		let mut record_ptr: *mut ecs_record_t = _ecs_sparse_get_sparse_any(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			*entities.offset(i as isize),
		) as *mut ecs_record_t;
		if !record_ptr.is_null() {
			if (*record_ptr).table != (*writer).table {
				let mut table: *mut ecs_table_t = (*record_ptr).table;
				let mut table_data: *mut ecs_data_t = ecs_table_get_data(table);
				ecs_table_delete(
					world,
					table,
					table_data,
					(*record_ptr).row - 1 as libc::c_int,
					0 as libc::c_int != 0,
				);
			}
		} else {
			record_ptr = _ecs_sparse_get_or_create(
				(*world).store.entity_index,
				::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
				*entities.offset(i as isize),
			) as *mut ecs_record_t
		}
		(*record_ptr).row = i + 1 as libc::c_int;
		(*record_ptr).table = (*writer).table;
		if *entities.offset(i as isize) >= (*world).stats.last_id {
			(*world).stats.last_id =
				(*entities.offset(i as isize)).wrapping_add(1 as libc::c_int as libc::c_ulong)
		}
		i += 1
	}
}
unsafe extern "C" fn ecs_table_writer_prepare_column(
	mut stream: *mut ecs_writer_t,
	mut size: int32_t,
) {
	let mut writer: *mut ecs_table_writer_t = &mut (*stream).table;
	let mut data: *mut ecs_data_t = ecs_table_get_or_create_data((*writer).table);
	if (*writer).column_index != 0 {
		let mut column: *mut ecs_column_t = &mut *(*data)
			.columns
			.offset(((*writer).column_index - 1 as libc::c_int) as isize)
			as *mut ecs_column_t;
		if size != 0 {
			let mut old_count: int32_t = ecs_vector_count((*column).data);
			_ecs_vector_set_count(
				&mut (*column).data,
				size,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> 0 as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					0 as libc::c_int
				} as int16_t,
				(*writer).row_count,
			);
			/* Initialize new elements to 0 */
			let mut buffer: *mut libc::c_void = _ecs_vector_first(
				(*column).data,
				size,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> 0 as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					0 as libc::c_int
				} as int16_t,
			);
			memset(
				(buffer as uintptr_t).wrapping_add((old_count * size) as uintptr_t)
					as *mut libc::c_void,
				0 as libc::c_int,
				(((*writer).row_count - old_count) * size) as size_t,
			);
		}
		(*writer).column_vector = (*column).data;
		(*writer).column_size = ecs_to_i16(size as int64_t)
	} else {
		_ecs_vector_set_count(
			&mut (*data).entities,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
			(*writer).row_count,
		);
		_ecs_vector_set_count(
			&mut (*data).record_ptrs,
			::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
			} as int16_t,
			(*writer).row_count,
		);
		(*writer).column_vector = (*data).entities;
		(*writer).column_size =
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t as int16_t
	}
	(*writer).column_data = _ecs_vector_first(
		(*writer).column_vector,
		(*writer).column_size as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			> (*writer).column_alignment as libc::c_int
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
		} else {
			(*writer).column_alignment as libc::c_int
		} as int16_t,
	);
	(*writer).column_written = 0 as libc::c_int;
}
unsafe extern "C" fn ecs_table_writer_next(mut stream: *mut ecs_writer_t) {
	let mut writer: *mut ecs_table_writer_t = &mut (*stream).table;
	let mut current_block_21: u64;
	match (*writer).state as libc::c_uint {
		4 => {
			(*writer).state = EcsTableType;
			current_block_21 = 16924917904204750491;
		}
		5 => {
			(*writer).state = EcsTableSize;
			current_block_21 = 16924917904204750491;
		}
		6 => {
			(*writer).state = EcsTableColumn;
			current_block_21 = 16924917904204750491;
		}
		8 => {
			(*writer).state = EcsTableColumnSize;
			current_block_21 = 16924917904204750491;
		}
		9 => {
			(*writer).state = EcsTableColumnData;
			current_block_21 = 16924917904204750491;
		}
		11 => {
			(*writer).state = EcsTableColumnNameLength;
			current_block_21 = 16924917904204750491;
		}
		12 => {
			(*writer).state = EcsTableColumnName;
			current_block_21 = 16924917904204750491;
		}
		13 => {
			(*writer).row_index += 1;
			if (*writer).row_index < (*writer).row_count {
				(*writer).state = EcsTableColumnNameLength;
				current_block_21 = 16924917904204750491;
			} else {
				current_block_21 = 3604357593802168520;
			}
		}
		10 => {
			current_block_21 = 3604357593802168520;
		}
		_ => {
			_ecs_abort(
				12 as libc::c_int,
				0 as *const libc::c_char,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				19888 as libc::c_int,
			);
			abort();
		}
	}
	match current_block_21 {
		3604357593802168520 =>
		// fall through
		{
			(*writer).column_index += 1;
			if (*writer).column_index > (*(*writer).table).column_count {
				ecs_table_writer_finalize_table(stream);
				(*stream).state = EcsStreamHeader;
				(*writer).column_written = 0 as libc::c_int;
				(*writer).state = EcsStreamHeader;
				(*writer).column_index = 0 as libc::c_int;
				(*writer).row_index = 0 as libc::c_int
			} else {
				(*writer).state = EcsTableColumn
			}
		}
		_ => {}
	};
}
unsafe extern "C" fn ecs_table_writer(
	mut buffer: *const libc::c_char,
	mut size: ecs_size_t,
	mut stream: *mut ecs_writer_t,
) -> ecs_size_t {
	let mut current_block: u64;
	let mut writer: *mut ecs_table_writer_t = &mut (*stream).table;
	let mut written: ecs_size_t = 0 as libc::c_int;
	if (*writer).state as u64 == 0 {
		(*writer).state = EcsTableTypeSize
	}
	match (*writer).state as libc::c_uint {
		4 => {
			(*writer).type_count = *(buffer as *mut int32_t);
			(*writer).type_array = ecs_os_api.malloc_.expect("non-null function pointer")(
				(*writer).type_count
					* ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			) as *mut ecs_entity_t;
			(*writer).type_max_count = (*writer).type_count;
			(*writer).type_written = 0 as libc::c_int;
			written = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_writer_next(stream);
			current_block = 13707613154239713890;
		}
		5 => {
			*(((*writer).type_array as uintptr_t).wrapping_add((*writer).type_written as uintptr_t)
				as *mut libc::c_void as *mut int32_t) = *(buffer as *mut int32_t);
			written = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			(*writer).type_written += written;
			if (*writer).type_written
				== (*writer).type_count
					* ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t
			{
				ecs_table_writer_register_table(stream);
				ecs_table_writer_next(stream);
			}
			current_block = 13707613154239713890;
		}
		6 => {
			(*writer).row_count = *(buffer as *mut int32_t);
			written += ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_writer_next(stream);
			current_block = 13707613154239713890;
		}
		7 => {
			(*writer).state = *(buffer as *mut ecs_blob_header_kind_t);
			if (*writer).state as libc::c_uint
				!= EcsTableColumnHeader as libc::c_int as libc::c_uint
				&& (*writer).state as libc::c_uint
					!= EcsTableColumnNameHeader as libc::c_int as libc::c_uint
			{
				(*stream).error = 40 as libc::c_int;
				return -(1 as libc::c_int);
			} else {
				written += ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t
			}
			current_block = 13707613154239713890;
		}
		8 | 9 => {
			ecs_table_writer_prepare_column(stream, *(buffer as *mut int32_t));
			ecs_table_writer_next(stream);
			written += ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_writer_next(stream);
			/* If column has no size, there will be no column data, so skip to the
			 * next state. */
			if (*writer).column_size == 0 {
				ecs_table_writer_next(stream);
			}
			current_block = 13707613154239713890;
		}
		10 => {
			written = (*writer).row_count * (*writer).column_size as libc::c_int
				- (*writer).column_written;
			if written > size {
				written = size
			}
			memcpy(
				((*writer).column_data as uintptr_t)
					.wrapping_add((*writer).column_written as uintptr_t) as *mut libc::c_void,
				buffer as *const libc::c_void,
				written as size_t,
			);
			(*writer).column_written += written;
			written = ((written - 1 as libc::c_int)
				/ ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t
				+ 1 as libc::c_int)
				* ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			if (*writer).column_written
				== (*writer).row_count * (*writer).column_size as libc::c_int
			{
				ecs_table_writer_next(stream);
			}
			current_block = 13707613154239713890;
		}
		11 => {
			ecs_table_writer_prepare_column(
				stream,
				::std::mem::size_of::<EcsName>() as libc::c_ulong as ecs_size_t,
			);
			ecs_table_writer_next(stream);
			current_block = 17369808064762292150;
		}
		12 => {
			current_block = 17369808064762292150;
		}
		13 => {
			written = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			if !ecs_name_writer_write(&mut (*writer).name, buffer) {
				let mut name_ptr: *mut EcsName = &mut *((*writer).column_data as *mut EcsName)
					.offset((*writer).row_index as isize)
					as *mut EcsName;
				(*name_ptr).value = (*writer).name.name;
				if !(*name_ptr).alloc_value.is_null() {
					ecs_os_api.free_.expect("non-null function pointer")(
						(*name_ptr).alloc_value as *mut libc::c_void,
					);
				}
				(*name_ptr).alloc_value = (*writer).name.name;
				/* Don't overwrite entity name */
				ecs_name_writer_reset(&mut (*writer).name);
				ecs_table_writer_next(stream);
			}
			current_block = 13707613154239713890;
		}
		_ => {
			_ecs_abort(
				12 as libc::c_int,
				0 as *const libc::c_char,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				20010 as libc::c_int,
			);
			abort();
		}
	}
	match current_block {
		17369808064762292150 =>
		// fall through
		{
			ecs_name_writer_alloc(&mut (*writer).name, *(buffer as *mut int32_t));
			written = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_writer_next(stream);
		}
		_ => {}
	}
	return written;
}
/* * Write to a writer.
 * This operation writes a specified number of bytes from a specified buffer
 * into the writer. The writer will restore the deserialized data into the
 * original serialized entities. The write operation may be invoked multiple
 * times with partial buffers, which allows applications to use static buffers
 * when reading from, for example, a file or the network.
 *
 * The data contained in the buffers must have been serialized with the
 * ecs_reader_read operation. If the data does not match the expected format, or
 * the data contains conflicts with the world, the operation will fail. The
 * data must be provided in the same order as produced by ecs_reader_read,
 * but the used buffer size does not have to be the same as the one used by
 * ecs_reader_read. The buffer size must be a multiple of 4.
 *
 * @param buffer The buffer to deserialize.
 * @param size The maximum number of bytes.
 * @param writer The writer to write to.
 * @return Zero if success, non-zero if failed to deserialize.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_writer_write(
	mut buffer: *const libc::c_char,
	mut size: ecs_size_t,
	mut writer: *mut ecs_writer_t,
) -> libc::c_int {
	let mut current_block: u64;
	let mut written: ecs_size_t = 0 as libc::c_int;
	let mut total_written: ecs_size_t = 0 as libc::c_int;
	let mut remaining: ecs_size_t = size;
	if size == 0 {
		return 0 as libc::c_int;
	}
	loop {
		if !(total_written < size) {
			current_block = 12147880666119273379;
			break;
		}
		if (*writer).state as libc::c_uint == EcsStreamHeader as libc::c_int as libc::c_uint {
			(*writer).state = *((buffer as uintptr_t).wrapping_add(total_written as uintptr_t)
				as *mut libc::c_void as *mut ecs_blob_header_kind_t);
			if (*writer).state as libc::c_uint != EcsTableHeader as libc::c_int as libc::c_uint {
				(*writer).error = 40 as libc::c_int;
				current_block = 16026662740998309270;
				break;
			} else {
				written =
					::std::mem::size_of::<ecs_blob_header_kind_t>() as libc::c_ulong as ecs_size_t
			}
		} else if (*writer).state as libc::c_uint == EcsTableHeader as libc::c_int as libc::c_uint {
			written = ecs_table_writer(
				(buffer as uintptr_t).wrapping_add(total_written as uintptr_t) as *mut libc::c_void
					as *const libc::c_char,
				remaining,
				writer,
			)
		}
		if written == 0 {
			current_block = 12147880666119273379;
			break;
		}
		if written == -(1 as libc::c_int) {
			current_block = 16026662740998309270;
			break;
		}
		remaining -= written;
		total_written += written
	}
	match current_block {
		16026662740998309270 => return -(1 as libc::c_int),
		_ => return (total_written == 0 as libc::c_int) as libc::c_int,
	};
}
/* * Initialize a writer.
 * A writer deserializes data from a sequence of bytes into a world. This
 * enables applications to restore data from disk or the network.
 *
 * The provided world must be either empty or compatible with the data to
 * deserialize, where compatible means that the serialized component ids and
 * sizes must match exactly with those in the world. Errors can occur if a world
 * is provided in which components have been declared in a different order, or
 * when components have different type definitions.
 *
 * @param world The world in which to deserialize the data.
 * @return The writer.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_writer_init(mut world: *mut ecs_world_t) -> ecs_writer_t {
	return {
		let mut init = ecs_writer_t {
			world: world,
			state: EcsStreamHeader,
			table: ecs_table_writer_t {
				state: EcsStreamHeader,
				table: 0 as *mut ecs_table_t,
				column_vector: 0 as *mut ecs_vector_t,
				type_count: 0,
				type_max_count: 0,
				type_written: 0,
				type_array: 0 as *mut ecs_entity_t,
				column_index: 0,
				column_size: 0,
				column_alignment: 0,
				column_written: 0,
				column_data: 0 as *mut libc::c_void,
				row_count: 0,
				row_index: 0,
				name: ecs_name_writer_t {
					name: 0 as *mut libc::c_char,
					written: 0,
					len: 0,
					max_len: 0,
				},
			},
			error: 0,
		};
		init
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_module_path_from_c(
	mut c_name: *const libc::c_char,
) -> *mut libc::c_char {
	let mut str: ecs_strbuf_t = {
		let mut init = ecs_strbuf_t {
			buf: 0 as *mut libc::c_char,
			max: 0,
			size: 0,
			elementCount: 0,
			firstElement: ecs_strbuf_element_embedded {
				super_0: ecs_strbuf_element {
					buffer_embedded: false,
					pos: 0,
					buf: 0 as *mut libc::c_char,
					next: 0 as *mut ecs_strbuf_element,
				},
				buf: [0; 512],
			},
			current: 0 as *mut ecs_strbuf_element,
			list_stack: [ecs_strbuf_list_elem {
				count: 0,
				separator: 0 as *const libc::c_char,
			}; 32],
			list_sp: 0,
		};
		init
	};
	let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
	let mut ch: libc::c_char = 0;
	ptr = c_name;
	loop {
		ch = *ptr;
		if !(ch != 0) {
			break;
		}
		if *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
			& _ISupper as libc::c_int as libc::c_ushort as libc::c_int
			!= 0
		{
			ch = ecs_to_i8(tolower(ch as libc::c_int) as int64_t) as libc::c_char;
			if ptr != c_name {
				ecs_strbuf_appendstrn(
					&mut str,
					b".\x00" as *const u8 as *const libc::c_char,
					1 as libc::c_int,
				);
			}
		}
		ecs_strbuf_appendstrn(&mut str, &mut ch, 1 as libc::c_int);
		ptr = ptr.offset(1)
	}
	return ecs_strbuf_get(&mut str);
}
/* * @} */
/* Optional modules */
/* *
 * @file module.h
 * @brief Module API.
 */
// //////////////////////////////////////////////////////////////////////////////
// // Module API
// //////////////////////////////////////////////////////////////////////////////
/* * Import a module.
 * This operation will load a modules and store the public module handles in the
 * handles_out out parameter. The module name will be used to verify if the
 * module was already loaded, in which case it won't be reimported. The name
 * will be translated from PascalCase to an entity path (pascal.case) before the
 * lookup occurs.
 *
 * Module contents will be stored as children of the module entity. This
 * prevents modules from accidentally defining conflicting identifiers. This is
 * enforced by setting the scope before and after loading the module to the
 * module entity id.
 *
 * A more convenient way to import a module is by using the ECS_IMPORT macro.
 *
 * @param world The world.
 * @param module The module to load.
 * @param module_name The name of the module to load.
 * @param flags An integer that will be passed into the module import action.
 * @param handles_out A struct with handles to the module components/systems.
 * @param handles_size Size of the handles_out parameter.
 * @return The module entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_import(
	mut world: *mut ecs_world_t,
	mut init_action: ecs_module_action_t,
	mut module_name: *const libc::c_char,
	mut handles_out: *mut libc::c_void,
	mut handles_size: size_t,
) -> ecs_entity_t {
	let mut old_scope: ecs_entity_t = ecs_set_scope(world, 0 as libc::c_int as ecs_entity_t);
	let mut old_name_prefix: *const libc::c_char = (*world).name_prefix;
	let mut e: ecs_entity_t = ecs_lookup_path_w_sep(
		world,
		0 as libc::c_int as ecs_entity_t,
		module_name,
		b".\x00" as *const u8 as *const libc::c_char,
		0 as *const libc::c_char,
	);
	if e == 0 {
		ecs_log_push();
		/* Load module */
		init_action.expect("non-null function pointer")(world);
		/* Lookup module entity (must be registered by module) */
		e = ecs_lookup_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			module_name,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		ecs_log_pop();
	}
	/* Copy value of module component in handles_out parameter */
	if handles_size != 0 && !handles_out.is_null() {
		let mut handles_ptr: *mut libc::c_void = ecs_get_mut_w_entity(world, e, e, 0 as *mut bool);
		memcpy(
			handles_out,
			handles_ptr,
			ecs_from_size_t(handles_size) as size_t,
		);
	}
	/* Restore to previous state */
	ecs_set_scope(world, old_scope);
	(*world).name_prefix = old_name_prefix;
	return e;
}
/* Import a module from a library.
 * Similar to ecs_import, except that this operation will attempt to load the
 * module from a dynamic library.
 *
 * A library may contain multiple modules, which is why both a library name and
 * a module name need to be provided. If only a library name is provided, the
 * library name will be reused for the module name.
 *
 * The library will be looked up using a canonical name, which is in the same
 * form as a module, like `flecs.components.transform`. To transform this
 * identifier to a platform specific library name, the operation relies on the
 * module_to_dl callback of the os_api which the application has to override if
 * the default does not yield the correct library name.
 *
 * @param world The world.
 * @param library_name The name of the library to load.
 * @param module_name The name of the module to load.
 * @param flags The flags to pass to the module.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_import_from_library(
	mut world: *mut ecs_world_t,
	mut library_name: *const libc::c_char,
	mut module_name: *const libc::c_char,
) -> ecs_entity_t {
	let mut import_func: *mut libc::c_char = module_name as *mut libc::c_char; /* safe */
	let mut module: *mut libc::c_char = module_name as *mut libc::c_char;
	if !ecs_os_has_modules() || !ecs_os_has_dl() {
		ecs_os_err(b"library loading not supported, set module_to_dl, dlopen, dlclose and dlproc os API callbacks first\x00"
			as *const u8 as *const libc::c_char);
		return 0 as libc::c_int as ecs_entity_t;
	}
	/* If no module name is specified, try default naming convention for loading
	 * the main module from the library */
	if import_func.is_null() {
		import_func = ecs_os_api.malloc_.expect("non-null function pointer")(
			strlen(library_name) as ecs_size_t
				+ ::std::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong as ecs_size_t,
		) as *mut libc::c_char;
		let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
		let mut ch: libc::c_char = 0;
		let mut bptr: *mut libc::c_char = import_func;
		let mut capitalize: bool = 1 as libc::c_int != 0;
		ptr = library_name;
		loop {
			ch = *ptr;
			if !(ch != 0) {
				break;
			}
			if ch as libc::c_int == '.' as i32 {
				capitalize = 1 as libc::c_int != 0
			} else if capitalize {
				*bptr = ecs_to_i8(toupper(ch as libc::c_int) as int64_t) as libc::c_char;
				bptr = bptr.offset(1);
				capitalize = 0 as libc::c_int != 0
			} else {
				*bptr = ecs_to_i8(tolower(ch as libc::c_int) as int64_t) as libc::c_char;
				bptr = bptr.offset(1)
			}
			ptr = ptr.offset(1)
		}
		*bptr = '\u{0}' as i32 as libc::c_char;
		module = ecs_os_api.strdup_.expect("non-null function pointer")(import_func);
		strcat(bptr, b"Import\x00" as *const u8 as *const libc::c_char);
	}
	let mut library_filename: *mut libc::c_char =
		ecs_os_api.module_to_dl_.expect("non-null function pointer")(library_name);
	if library_filename.is_null() {
		ecs_os_err(
			b"failed to find library file for \'%s\'\x00" as *const u8 as *const libc::c_char,
			library_name,
		);
		if module != module_name as *mut libc::c_char {
			ecs_os_api.free_.expect("non-null function pointer")(module as *mut libc::c_void);
		}
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut dl: ecs_os_dl_t =
		ecs_os_api.dlopen_.expect("non-null function pointer")(library_filename);
	if dl == 0 {
		ecs_os_err(
			b"failed to load library \'%s\' (\'%s\')\x00" as *const u8 as *const libc::c_char,
			library_name,
			library_filename,
		);
		ecs_os_api.free_.expect("non-null function pointer")(library_filename as *mut libc::c_void);
		if module != module_name as *mut libc::c_char {
			ecs_os_api.free_.expect("non-null function pointer")(module as *mut libc::c_void);
		}
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut action: ecs_module_action_t =
		::std::mem::transmute::<ecs_os_proc_t, ecs_module_action_t>(ecs_os_api
			.dlproc_
			.expect("non-null function pointer")(
			dl, import_func
		));
	if action.is_none() {
		ecs_os_err(
			b"failed to load import function %s from library %s\x00" as *const u8
				as *const libc::c_char,
			import_func,
			library_name,
		);
		ecs_os_api.free_.expect("non-null function pointer")(library_filename as *mut libc::c_void);
		ecs_os_api.dlclose_.expect("non-null function pointer")(dl);
		return 0 as libc::c_int as ecs_entity_t;
	}
	/* Do not free id, as it will be stored as the component identifier */
	let mut result: ecs_entity_t = ecs_import(
		world,
		action,
		module,
		0 as *mut libc::c_void,
		0 as libc::c_int as size_t,
	);
	if import_func != module_name as *mut libc::c_char {
		ecs_os_api.free_.expect("non-null function pointer")(import_func as *mut libc::c_void);
	}
	if module != module_name as *mut libc::c_char {
		ecs_os_api.free_.expect("non-null function pointer")(module as *mut libc::c_void);
	}
	ecs_os_api.free_.expect("non-null function pointer")(library_filename as *mut libc::c_void);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_module(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut size: size_t,
	mut alignment: size_t,
) -> ecs_entity_t {
	if e == 0 {
		let mut module_path: *mut libc::c_char = ecs_module_path_from_c(name);
		e = ecs_new_from_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			module_path,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		let mut name_ptr: *mut EcsName =
			ecs_get_mut_w_entity(world, e, 6 as libc::c_int as ecs_entity_t, 0 as *mut bool)
				as *mut EcsName;
		(*name_ptr).symbol = name;
		ecs_os_api.free_.expect("non-null function pointer")(module_path as *mut libc::c_void);
	}
	let mut result: ecs_entity_t =
		ecs_new_component(world, e, 0 as *const libc::c_char, size, alignment);
	/* Add module tag */
	ecs_add_entity(
		world,
		result,
		(256 as libc::c_int + 0 as libc::c_int) as ecs_entity_t,
	);
	/* Add module to itself. This way we have all the module information stored
	 * in a single contained entity that we can use for namespacing */
	ecs_set_ptr_w_entity(world, result, result, size, 0 as *const libc::c_void);
	/* Set the current scope to the module */
	ecs_set_scope(world, result);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_queue_new(
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
) -> *mut ecs_queue_t {
	let mut result: *mut ecs_queue_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_queue_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_queue_t;
	(*result).data = _ecs_vector_new(elem_size, offset, elem_count);
	(*result).index = 0 as libc::c_int;
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_queue_from_array(
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut elem_count: int32_t,
	mut array: *mut libc::c_void,
) -> *mut ecs_queue_t {
	let mut result: *mut ecs_queue_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_queue_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_queue_t;
	(*result).data = _ecs_vector_from_array(elem_size, offset, elem_count, array);
	(*result).index = 0 as libc::c_int;
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_queue_push(
	mut buffer: *mut ecs_queue_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) -> *mut libc::c_void {
	let mut size: int32_t = ecs_vector_size((*buffer).data);
	let mut count: int32_t = ecs_vector_count((*buffer).data);
	let mut result: *mut libc::c_void = 0 as *mut libc::c_void;
	if count == (*buffer).index {
		result = _ecs_vector_add(&mut (*buffer).data, elem_size, offset)
	} else {
		result = _ecs_vector_get((*buffer).data, elem_size, offset, (*buffer).index)
	}
	(*buffer).index = ((*buffer).index + 1 as libc::c_int) % size;
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_queue_free(mut buffer: *mut ecs_queue_t) {
	ecs_vector_free((*buffer).data);
	ecs_os_api.free_.expect("non-null function pointer")(buffer as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_queue_get(
	mut buffer: *mut ecs_queue_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
	mut index: int32_t,
) -> *mut libc::c_void {
	let mut count: int32_t = ecs_vector_count((*buffer).data);
	let mut size: int32_t = ecs_vector_size((*buffer).data);
	index = ((*buffer).index - count + size + index) % size;
	return _ecs_vector_get((*buffer).data, elem_size, offset, index);
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_queue_last(
	mut buffer: *mut ecs_queue_t,
	mut elem_size: ecs_size_t,
	mut offset: int16_t,
) -> *mut libc::c_void {
	let mut index: int32_t = (*buffer).index;
	if index == 0 {
		index = ecs_vector_size((*buffer).data)
	}
	return _ecs_vector_get((*buffer).data, elem_size, offset, index - 1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_queue_index(mut buffer: *mut ecs_queue_t) -> int32_t {
	return (*buffer).index;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_queue_count(mut buffer: *mut ecs_queue_t) -> int32_t {
	return ecs_vector_count((*buffer).data);
}
unsafe extern "C" fn duplicate_data(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut main_data: *mut ecs_data_t,
) -> *mut ecs_data_t {
	let mut result: *mut ecs_data_t = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_data_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_data_t;
	let mut i: int32_t = 0;
	let mut column_count: int32_t = (*table).column_count;
	let mut components: *mut ecs_entity_t = _ecs_vector_first(
		(*table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	(*result).columns = ecs_os_memdup(
		(*main_data).columns as *const libc::c_void,
		::std::mem::size_of::<ecs_column_t>() as libc::c_ulong as ecs_size_t * column_count,
	) as *mut ecs_column_t;
	/* Copy entities */
	(*result).entities = _ecs_vector_copy(
		(*main_data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	);
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*result).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	/* Copy record ptrs */
	(*result).record_ptrs = _ecs_vector_copy(
		(*main_data).record_ptrs,
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
	);
	/* Copy each column */
	i = 0 as libc::c_int;
	while i < column_count {
		let mut component: ecs_entity_t = *components.offset(i as isize);
		let mut column: *mut ecs_column_t =
			&mut *(*result).columns.offset(i as isize) as *mut ecs_column_t;
		if component > 256 as libc::c_int as libc::c_ulong {
			(*column).data = 0 as *mut ecs_vector_t
		} else {
			let mut cdata: *mut ecs_c_info_t = ecs_get_c_info(world, component);
			let mut size: int16_t = (*column).size;
			let mut alignment: int16_t = (*column).alignment;
			let mut copy: ecs_copy_t = None;
			if !cdata.is_null() && {
				copy = (*cdata).lifecycle.copy;
				copy.is_some()
			} {
				let mut count: int32_t = ecs_vector_count((*column).data);
				let mut dst_vec: *mut ecs_vector_t = _ecs_vector_new(
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					count,
				);
				_ecs_vector_set_count(
					&mut dst_vec,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
					count,
				);
				let mut dst_ptr: *mut libc::c_void = _ecs_vector_first(
					dst_vec,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
				);
				let mut ctx: *mut libc::c_void = (*cdata).lifecycle.ctx;
				let mut ctor: ecs_xtor_t = (*cdata).lifecycle.ctor;
				if ctor.is_some() {
					ctor.expect("non-null function pointer")(
						world,
						component,
						entities,
						dst_ptr,
						ecs_to_size_t(size as int64_t),
						count,
						ctx,
					);
				}
				let mut src_ptr: *mut libc::c_void = _ecs_vector_first(
					(*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
				);
				copy.expect("non-null function pointer")(
					world,
					component,
					entities,
					entities,
					dst_ptr,
					src_ptr,
					ecs_to_size_t(size as int64_t),
					count,
					ctx,
				);
				(*column).data = dst_vec
			} else {
				(*column).data = _ecs_vector_copy(
					(*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> alignment as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						alignment as libc::c_int
					} as int16_t,
				)
			}
		}
		i += 1
	}
	return result;
}
unsafe extern "C" fn snapshot_create(
	mut world: *mut ecs_world_t,
	mut entity_index: *const ecs_sparse_t,
	mut iter: *mut ecs_iter_t,
	mut next: ecs_iter_next_action_t,
) -> *mut ecs_snapshot_t {
	let mut result: *mut ecs_snapshot_t = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_snapshot_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_snapshot_t;
	(*result).world = world;
	/* If no iterator is provided, the snapshot will be taken of the entire
	 * world, and we can simply copy the entity index as it will be restored
	 * entirely upon snapshote restore. */
	if iter.is_null() && !entity_index.is_null() {
		(*result).entity_index = ecs_sparse_copy(entity_index);
		(*result).tables = _ecs_vector_new(
			::std::mem::size_of::<ecs_table_leaf_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
			} as int16_t,
			0 as libc::c_int,
		)
	}
	let mut iter_stack: ecs_iter_t = ecs_iter_t {
		world: 0 as *mut ecs_world_t,
		system: 0,
		table: 0 as *mut ecs_iter_table_t,
		query: 0 as *mut ecs_query_t,
		table_count: 0,
		inactive_table_count: 0,
		column_count: 0,
		table_columns: 0 as *mut libc::c_void,
		entities: 0 as *mut ecs_entity_t,
		param: 0 as *mut libc::c_void,
		delta_time: 0.,
		delta_system_time: 0.,
		world_time: 0.,
		frame_offset: 0,
		table_offset: 0,
		offset: 0,
		count: 0,
		total_count: 0,
		triggered_by: 0 as *mut ecs_entities_t,
		interrupted_by: 0,
		iter: C2RustUnnamed {
			parent: ecs_scope_iter_t {
				filter: ecs_filter_t {
					include: 0 as *const ecs_vector_t,
					exclude: 0 as *const ecs_vector_t,
					include_kind: EcsMatchDefault,
					exclude_kind: EcsMatchDefault,
				},
				tables: 0 as *mut ecs_vector_t,
				index: 0,
				table: ecs_iter_table_t {
					columns: 0 as *mut int32_t,
					table: 0 as *mut ecs_table_t,
					data: 0 as *mut ecs_data_t,
					components: 0 as *mut ecs_entity_t,
					types: 0 as *mut ecs_type_t,
					references: 0 as *mut ecs_ref_t,
				},
			},
		},
	};
	if iter.is_null() {
		iter_stack = ecs_filter_iter(world, 0 as *const ecs_filter_t);
		iter = &mut iter_stack;
		next = Some(ecs_filter_next as unsafe extern "C" fn(_: *mut ecs_iter_t) -> bool)
	} else {
		/* If an iterator is provided, this is a filterred snapshot. In this case we
		 * have to patch the entity index one by one upon restore, as we don't want
		 * to affect entities that were not part of the snapshot. */
		(*result).entity_index = 0 as *mut ecs_sparse_t
	}
	/* Iterate tables in iterator */
	while next.expect("non-null function pointer")(iter) {
		let mut t: *mut ecs_table_t = (*(*iter).table).table;
		if (*t).flags & 1 as libc::c_uint != 0 {
			continue;
		}
		let mut data: *mut ecs_data_t = ecs_table_get_data(t);
		if data.is_null() || (*data).entities.is_null() || ecs_vector_count((*data).entities) == 0 {
			continue;
		}
		let mut l: *mut ecs_table_leaf_t = _ecs_vector_add(
			&mut (*result).tables,
			::std::mem::size_of::<ecs_table_leaf_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_table_leaf_t;
		(*l).table = t;
		(*l).type_0 = (*t).type_0;
		(*l).data = duplicate_data(world, t, data)
	}
	return result;
}
/* *
 * @file snapshot.h
 * @brief Snapshot API.
 */
/* * Create a snapshot.
 * This operation makes a copy of all component in the world that matches the
 * specified filter.
 *
 * @param world The world to snapshot.
 * @param return The snapshot.
 */
/* * Create a snapshot */
#[no_mangle]
pub unsafe extern "C" fn ecs_snapshot_take(mut world: *mut ecs_world_t) -> *mut ecs_snapshot_t {
	let mut result: *mut ecs_snapshot_t = snapshot_create(
		world,
		(*world).store.entity_index,
		0 as *mut ecs_iter_t,
		None,
	);
	(*result).last_id = (*world).stats.last_id;
	return result;
}
/* * Create a filtered snapshot.
 * This operation is the same as ecs_snapshot_take, but accepts an iterator so
 * an application can control what is stored by the snapshot.
 *
 * @param iter An iterator to the data to be stored by the snapshot.
 * @param next A function pointer to the next operation for the iterator.
 * @param return The snapshot.
 */
/* * Create a filtered snapshot */
#[no_mangle]
pub unsafe extern "C" fn ecs_snapshot_take_w_iter(
	mut iter: *mut ecs_iter_t,
	mut next: ecs_iter_next_action_t,
) -> *mut ecs_snapshot_t {
	let mut world: *mut ecs_world_t = (*iter).world;
	let mut result: *mut ecs_snapshot_t =
		snapshot_create(world, (*world).store.entity_index, iter, next);
	(*result).last_id = (*world).stats.last_id;
	return result;
}
/* * Restore a snapshot.
 * This operation restores the world to the state it was in when the specified
 * snapshot was taken. A snapshot can only be used once for restoring, as its
 * data replaces the data that is currently in the world.
 * This operation also resets the last issued entity handle, so any calls to
 * ecs_new may return entity ids that have been issued before restoring the
 * snapshot.
 *
 * The world in which the snapshot is restored must be the same as the world in
 * which the snapshot is taken.
 *
 * @param world The world to restore the snapshot to.
 * @param snapshot The snapshot to restore.
 */
/* * Restore a snapshot */
#[no_mangle]
pub unsafe extern "C" fn ecs_snapshot_restore(
	mut world: *mut ecs_world_t,
	mut snapshot: *mut ecs_snapshot_t,
) {
	let mut is_filtered: bool = 1 as libc::c_int != 0;
	if !(*snapshot).entity_index.is_null() {
		ecs_sparse_restore((*world).store.entity_index, (*snapshot).entity_index);
		ecs_sparse_free((*snapshot).entity_index);
		is_filtered = 0 as libc::c_int != 0
	}
	if !is_filtered {
		(*world).stats.last_id = (*snapshot).last_id
	}
	let mut leafs: *mut ecs_table_leaf_t = _ecs_vector_first(
		(*snapshot).tables,
		::std::mem::size_of::<ecs_table_leaf_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_table_leaf_t;
	let mut l: int32_t = 0 as libc::c_int;
	let mut count: int32_t = ecs_vector_count((*snapshot).tables);
	let mut t: int32_t = 0;
	let mut table_count: int32_t = ecs_sparse_count((*world).store.tables);
	t = 0 as libc::c_int;
	while t < table_count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			t,
		) as *mut ecs_table_t;
		if !((*table).flags & 1 as libc::c_uint != 0) {
			let mut leaf: *mut ecs_table_leaf_t = 0 as *mut ecs_table_leaf_t;
			if l < count {
				leaf = &mut *leafs.offset(l as isize) as *mut ecs_table_leaf_t
			}
			if !leaf.is_null() && (*leaf).table == table {
				/* If the snapshot is filtered, update the entity index for the
				 * entities in the snapshot. If the snapshot was not filtered
				 * the entity index would have been replaced entirely, and this
				 * is not necessary. */
				if is_filtered {
					let mut e_ptr_i: libc::c_int = 0;
					let mut e_ptr_count: libc::c_int = ecs_vector_count((*(*leaf).data).entities);
					let mut e_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
						(*(*leaf).data).entities,
						::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
							as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
						} as int16_t,
					) as *mut ecs_entity_t;
					e_ptr_i = 0 as libc::c_int;
					while e_ptr_i < e_ptr_count {
						let mut e_ptr: *mut ecs_entity_t =
							&mut *e_ptr_array.offset(e_ptr_i as isize) as *mut ecs_entity_t;
						let mut r: *mut ecs_record_t = _ecs_sparse_get_sparse(
							(*world).store.entity_index,
							::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
							*e_ptr,
						) as *mut ecs_record_t;
						if !r.is_null() && !(*r).table.is_null() {
							let mut data: *mut ecs_data_t = ecs_table_get_data((*r).table);
							/* Data must be not NULL, otherwise entity index could
							 * not point to it */
							let mut is_monitored: bool = false;
							let mut row: int32_t = ecs_record_to_row((*r).row, &mut is_monitored);
							/* Always delete entity, so that even if the entity is
							 * in the current table, there won't be duplicates */
							ecs_table_delete(world, (*r).table, data, row, 0 as libc::c_int != 0);
						} else {
							ecs_sparse_set_generation((*world).store.entity_index, *e_ptr);
						}
						e_ptr_i += 1
					}
					let mut old_count: int32_t = ecs_table_count(table);
					let mut new_count: int32_t = ecs_table_data_count((*leaf).data);
					let mut data_0: *mut ecs_data_t = ecs_table_get_data(table);
					data_0 = ecs_table_merge(world, table, table, data_0, (*leaf).data);
					/* Run OnSet systems for merged entities */
					let mut components: ecs_entities_t = ecs_type_to_entities((*table).type_0);
					ecs_run_set_systems(
						world,
						&mut components,
						table,
						data_0,
						old_count,
						new_count,
						1 as libc::c_int != 0,
					);
					ecs_os_api.free_.expect("non-null function pointer")(
						(*(*leaf).data).columns as *mut libc::c_void,
					);
				} else {
					ecs_table_replace_data(world, table, (*leaf).data);
				}
				ecs_os_api.free_.expect("non-null function pointer")(
					(*leaf).data as *mut libc::c_void,
				);
				l += 1
			} else if !is_filtered {
				/* If the snapshot is not filtered, the snapshot should restore the
				 * world to the exact state it was in. When a snapshot is filtered,
				 * it should only update the entities that were in the snapshot.
				 * If a table is found that was not in the snapshot, and the
				 * snapshot was not filtered, clear the table. */
				/* Use clear_silent so no triggers are fired */
				ecs_table_clear_silent(world, table);
			}
			(*table).alloc_count += 1
		}
		t += 1
	}
	/* If snapshot was not filtered, run OnSet systems now. This cannot be done
	 * while restoring the snapshot, because the world is in an inconsistent
	 * state while restoring. When a snapshot is filtered, the world is not left
	 * in an inconsistent state, which makes running OnSet systems while
	 * restoring safe */
	if !is_filtered {
		t = 0 as libc::c_int;
		while t < table_count {
			let mut table_0: *mut ecs_table_t = _ecs_sparse_get(
				(*world).store.tables,
				::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
				t,
			) as *mut ecs_table_t;
			if !((*table_0).flags & 1 as libc::c_uint != 0) {
				let mut components_0: ecs_entities_t = ecs_type_to_entities((*table_0).type_0);
				let mut table_data: *mut ecs_data_t = ecs_table_get_data(table_0);
				let mut entity_count: int32_t = ecs_table_data_count(table_data);
				ecs_run_set_systems(
					world,
					&mut components_0,
					table_0,
					table_data,
					0 as libc::c_int,
					entity_count,
					1 as libc::c_int != 0,
				);
			}
			t += 1
		}
	}
	ecs_vector_free((*snapshot).tables);
	ecs_os_api.free_.expect("non-null function pointer")(snapshot as *mut libc::c_void);
}
/* * Obtain iterator to snapshot data.
 *
 * @param snapshot The snapshot to iterate over.
 * @return Iterator to snapshot data. */
#[no_mangle]
pub unsafe extern "C" fn ecs_snapshot_iter(
	mut snapshot: *mut ecs_snapshot_t,
	mut filter: *const ecs_filter_t,
) -> ecs_iter_t {
	let mut iter: ecs_snapshot_iter_t = {
		let mut init = ecs_snapshot_iter_t {
			filter: if !filter.is_null() {
				*filter
			} else {
				let mut init = ecs_filter_t {
					include: 0 as ecs_type_t,
					exclude: 0 as *const ecs_vector_t,
					include_kind: EcsMatchDefault,
					exclude_kind: EcsMatchDefault,
				};
				init
			},
			tables: (*snapshot).tables,
			index: 0 as libc::c_int,
			table: ecs_iter_table_t {
				columns: 0 as *mut int32_t,
				table: 0 as *mut ecs_table_t,
				data: 0 as *mut ecs_data_t,
				components: 0 as *mut ecs_entity_t,
				types: 0 as *mut ecs_type_t,
				references: 0 as *mut ecs_ref_t,
			},
		};
		init
	};
	return {
		let mut init = ecs_iter_t {
			world: (*snapshot).world,
			system: 0,
			table: 0 as *mut ecs_iter_table_t,
			query: 0 as *mut ecs_query_t,
			table_count: ecs_vector_count((*snapshot).tables),
			inactive_table_count: 0,
			column_count: 0,
			table_columns: 0 as *mut libc::c_void,
			entities: 0 as *mut ecs_entity_t,
			param: 0 as *mut libc::c_void,
			delta_time: 0.,
			delta_system_time: 0.,
			world_time: 0.,
			frame_offset: 0,
			table_offset: 0,
			offset: 0,
			count: 0,
			total_count: 0,
			triggered_by: 0 as *mut ecs_entities_t,
			interrupted_by: 0,
			iter: C2RustUnnamed { snapshot: iter },
		};
		init
	};
}
/* * Progress snapshot iterator.
 *
 * @param iter The snapshot iterator.
 * @return True if more data is available, otherwise false.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_snapshot_next(mut it: *mut ecs_iter_t) -> bool {
	let mut iter: *mut ecs_snapshot_iter_t = &mut (*it).iter.snapshot;
	let mut tables: *mut ecs_table_leaf_t = _ecs_vector_first(
		(*iter).tables,
		::std::mem::size_of::<ecs_table_leaf_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_table_leaf_t;
	let mut count: int32_t = ecs_vector_count((*iter).tables);
	let mut i: int32_t = 0;
	i = (*iter).index;
	while i < count {
		let mut table: *mut ecs_table_t = (*tables.offset(i as isize)).table;
		let mut data: *mut ecs_data_t = (*tables.offset(i as isize)).data;
		if !data.is_null() {
			if ecs_table_match_filter((*it).world, table, &mut (*iter).filter) {
				(*iter).table.table = table;
				(*it).table = &mut (*iter).table;
				(*it).table_columns = (*data).columns as *mut libc::c_void;
				(*it).count = ecs_table_data_count(data);
				(*it).entities = _ecs_vector_first(
					(*data).entities,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				(*iter).index = i + 1 as libc::c_int;
				return 1 as libc::c_int != 0;
			}
		}
		i += 1
	}
	return 0 as libc::c_int != 0;
}
/* * Free snapshot resources.
 * This frees resources associated with a snapshot without restoring it.
 *
 * @param world The world.
 * @param snapshot The snapshot to free.
 */
/* * Cleanup snapshot */
#[no_mangle]
pub unsafe extern "C" fn ecs_snapshot_free(mut snapshot: *mut ecs_snapshot_t) {
	ecs_sparse_free((*snapshot).entity_index);
	let mut tables: *mut ecs_table_leaf_t = _ecs_vector_first(
		(*snapshot).tables,
		::std::mem::size_of::<ecs_table_leaf_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_table_leaf_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_table_leaf_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*snapshot).tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut leaf: *mut ecs_table_leaf_t =
			&mut *tables.offset(i as isize) as *mut ecs_table_leaf_t;
		ecs_table_clear_data((*leaf).table, (*leaf).data);
		ecs_os_api.free_.expect("non-null function pointer")((*leaf).data as *mut libc::c_void);
		i += 1
	}
	ecs_vector_free((*snapshot).tables);
	ecs_os_api.free_.expect("non-null function pointer")(snapshot as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_find_table(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
) -> *mut ecs_table_t {
	let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
	return table;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_table(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut dbg_out: *mut ecs_dbg_table_t,
) {
	*dbg_out = {
		let mut init = ecs_dbg_table_t {
			table: table,
			type_0: 0 as *const ecs_vector_t,
			shared: 0 as *const ecs_vector_t,
			container: 0 as *const ecs_vector_t,
			parent_entities: 0 as *const ecs_vector_t,
			base_entities: 0 as *const ecs_vector_t,
			systems_matched: 0 as *mut ecs_vector_t,
			entities: 0 as *mut ecs_entity_t,
			entities_count: 0,
		};
		init
	};
	(*dbg_out).type_0 = (*table).type_0;
	(*dbg_out).systems_matched = (*table).queries;
	/* Determine components from parent/base entities */
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*table).type_0);
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			let mut parent_dbg: ecs_dbg_entity_t = ecs_dbg_entity_t {
				entity: 0,
				table: 0 as *mut ecs_table_t,
				type_0: 0 as *const ecs_vector_t,
				row: 0,
				is_watched: false,
			};
			ecs_dbg_entity(
				world,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
				&mut parent_dbg,
			);
			let mut parent_table_dbg: ecs_dbg_table_t = ecs_dbg_table_t {
				table: 0 as *mut ecs_table_t,
				type_0: 0 as *const ecs_vector_t,
				shared: 0 as *const ecs_vector_t,
				container: 0 as *const ecs_vector_t,
				parent_entities: 0 as *const ecs_vector_t,
				base_entities: 0 as *const ecs_vector_t,
				systems_matched: 0 as *mut ecs_vector_t,
				entities: 0 as *mut ecs_entity_t,
				entities_count: 0,
			};
			ecs_dbg_table(world, parent_dbg.table, &mut parent_table_dbg);
			/* Owned and shared components are available from container */
			(*dbg_out).container = ecs_type_merge(
				world,
				(*dbg_out).container,
				parent_dbg.type_0,
				0 as ecs_type_t,
			);
			(*dbg_out).container = ecs_type_merge(
				world,
				(*dbg_out).container,
				parent_table_dbg.shared,
				0 as ecs_type_t,
			);
			/* Add entity to list of parent entities */
			(*dbg_out).parent_entities = ecs_type_add(
				world,
				(*dbg_out).parent_entities,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
			)
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			let mut base_dbg: ecs_dbg_entity_t = ecs_dbg_entity_t {
				entity: 0,
				table: 0 as *mut ecs_table_t,
				type_0: 0 as *const ecs_vector_t,
				row: 0,
				is_watched: false,
			};
			ecs_dbg_entity(
				world,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
				&mut base_dbg,
			);
			let mut base_table_dbg: ecs_dbg_table_t = ecs_dbg_table_t {
				table: 0 as *mut ecs_table_t,
				type_0: 0 as *const ecs_vector_t,
				shared: 0 as *const ecs_vector_t,
				container: 0 as *const ecs_vector_t,
				parent_entities: 0 as *const ecs_vector_t,
				base_entities: 0 as *const ecs_vector_t,
				systems_matched: 0 as *mut ecs_vector_t,
				entities: 0 as *mut ecs_entity_t,
				entities_count: 0,
			};
			ecs_dbg_table(world, base_dbg.table, &mut base_table_dbg);
			/* Owned and shared components are available from base */
			(*dbg_out).shared =
				ecs_type_merge(world, (*dbg_out).shared, base_dbg.type_0, 0 as ecs_type_t);
			(*dbg_out).shared = ecs_type_merge(
				world,
				(*dbg_out).shared,
				base_table_dbg.shared,
				0 as ecs_type_t,
			);
			/* Never inherit EcsName or EcsPrefab */
			(*dbg_out).shared =
				ecs_type_merge(world, (*dbg_out).shared, 0 as ecs_type_t, FLECS__TEcsName);
			(*dbg_out).shared = ecs_type_merge(
				world,
				(*dbg_out).shared,
				0 as ecs_type_t,
				ecs_type_from_entity(
					world,
					(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t,
				),
			);
			/* Shared components are always masked by owned components */
			(*dbg_out).shared =
				ecs_type_merge(world, (*dbg_out).shared, 0 as ecs_type_t, (*table).type_0);
			/* Add entity to list of base entities */
			(*dbg_out).base_entities = ecs_type_add(
				world,
				(*dbg_out).base_entities,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
			);
			/* Add base entities of entity to list of base entities */
			(*dbg_out).base_entities = ecs_type_add(
				world,
				base_table_dbg.base_entities,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
			)
		}
		i += 1
	}
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if !data.is_null() {
		(*dbg_out).entities = _ecs_vector_first(
			(*data).entities,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		(*dbg_out).entities_count = ecs_vector_count((*data).entities)
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_get_table(
	mut world: *mut ecs_world_t,
	mut index: int32_t,
) -> *mut ecs_table_t {
	if ecs_sparse_count((*world).store.tables) <= index {
		return 0 as *mut ecs_table_t;
	}
	return _ecs_sparse_get(
		(*world).store.tables,
		::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
		index,
	) as *mut ecs_table_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_filter_table(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut filter: *mut ecs_filter_t,
) -> bool {
	return ecs_table_match_filter(world, table, filter);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_table_get_type(mut table: *mut ecs_table_t) -> ecs_type_t {
	return (*table).type_0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut dbg_out: *mut ecs_dbg_entity_t,
) {
	*dbg_out = {
		let mut init = ecs_dbg_entity_t {
			entity: entity,
			table: 0 as *mut ecs_table_t,
			type_0: 0 as *const ecs_vector_t,
			row: 0,
			is_watched: false,
		};
		init
	};
	let mut info: ecs_entity_info_t = {
		let mut init = ecs_entity_info_t {
			record: 0 as *mut ecs_record_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			row: 0,
			is_watched: false,
		};
		init
	};
	if ecs_get_info(world, entity, &mut info) {
		(*dbg_out).table = info.table;
		(*dbg_out).row = info.row;
		(*dbg_out).is_watched = info.is_watched;
		(*dbg_out).type_0 = if !info.table.is_null() {
			(*info.table).type_0
		} else {
			0 as ecs_type_t
		}
	};
}
unsafe extern "C" fn iter_table(
	mut reader: *mut ecs_table_reader_t,
	mut it: *mut ecs_iter_t,
	mut next: ecs_iter_next_action_t,
	mut skip_builtin: bool,
) -> bool {
	let mut table_found: bool = 0 as libc::c_int != 0;
	while next.expect("non-null function pointer")(it) {
		let mut table: *mut ecs_table_t = (*(*it).table).table;
		(*reader).table = table;
		let mut data: *mut ecs_data_t = ecs_table_get_data(table);
		(*reader).data = data;
		(*reader).table_index += 1;
		if skip_builtin as libc::c_int != 0 && (*(*reader).table).flags & 1 as libc::c_uint != 0 {
			continue;
		}
		if data.is_null() || (*it).count == 0 {
			continue;
		}
		table_found = 1 as libc::c_int != 0;
		break;
	}
	return table_found;
}
unsafe extern "C" fn next_table(
	mut stream: *mut ecs_reader_t,
	mut reader: *mut ecs_table_reader_t,
) {
	let mut count: int32_t = 0;
	/* First iterate all component tables, as component data must always be
	 * stored in a blob before anything else */
	let mut table_found: bool = iter_table(
		reader,
		&mut (*stream).component_iter,
		(*stream).component_next,
		0 as libc::c_int != 0,
	);
	/* If all components have been added, add the regular data tables. Make sure
	 * to not add component tables again, in case the provided iterator also
	 * matches component tables. */
	if !table_found {
		table_found = iter_table(
			reader,
			&mut (*stream).data_iter,
			(*stream).data_next,
			1 as libc::c_int != 0,
		);
		count = (*stream).data_iter.count
	} else {
		count = (*stream).component_iter.count
	}
	if !table_found {
		(*stream).state = EcsFooterSegment
	} else {
		(*reader).type_0 = (*(*reader).table).type_0;
		(*reader).total_columns = (*(*reader).table).column_count + 1 as libc::c_int;
		(*reader).column_index = 0 as libc::c_int;
		(*reader).row_count = count
	};
}
unsafe extern "C" fn ecs_table_reader_next(mut stream: *mut ecs_reader_t) {
	let mut reader: *mut ecs_table_reader_t = &mut (*stream).table;
	let mut current_block_40: u64;
	match (*reader).state as libc::c_uint {
		3 => {
			(*reader).state = EcsTableTypeSize;
			current_block_40 = 13619784596304402172;
		}
		4 => {
			(*reader).state = EcsTableType;
			(*reader).type_written = 0 as libc::c_int;
			current_block_40 = 13619784596304402172;
		}
		5 => {
			(*reader).state = EcsTableSize;
			current_block_40 = 13619784596304402172;
		}
		6 => {
			(*reader).state = EcsTableColumnHeader;
			current_block_40 = 13619784596304402172;
		}
		8 => {
			(*reader).state = EcsTableColumnSize;
			if (*reader).column_index == 0 {
				(*reader).column_vector = (*(*reader).data).entities;
				(*reader).column_size =
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t as int16_t
			} else {
				let mut column: *mut ecs_column_t = &mut *(*(*reader).data)
					.columns
					.offset(((*reader).column_index - 1 as libc::c_int) as isize)
					as *mut ecs_column_t;
				(*reader).column_vector = (*column).data;
				(*reader).column_size = (*column).size;
				(*reader).column_alignment = (*column).alignment
			}
			current_block_40 = 13619784596304402172;
		}
		9 => {
			(*reader).state = EcsTableColumnData;
			(*reader).column_data = _ecs_vector_first(
				(*reader).column_vector,
				(*reader).column_size as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					> (*reader).column_alignment as libc::c_int
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				} else {
					(*reader).column_alignment as libc::c_int
				} as int16_t,
			);
			(*reader).column_written = 0 as libc::c_int;
			current_block_40 = 13619784596304402172;
		}
		11 => {
			(*reader).state = EcsTableColumnNameLength;
			let mut column_0: *mut ecs_column_t = &mut *(*(*reader).data)
				.columns
				.offset(((*reader).column_index - 1 as libc::c_int) as isize)
				as *mut ecs_column_t;
			(*reader).column_vector = (*column_0).data;
			(*reader).column_data = _ecs_vector_first(
				(*reader).column_vector,
				::std::mem::size_of::<EcsName>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut EcsName as *mut libc::c_void;
			(*reader).row_index = 0 as libc::c_int;
			current_block_40 = 13619784596304402172;
		}
		12 => {
			(*reader).state = EcsTableColumnName;
			(*reader).row_index += 1;
			current_block_40 = 13619784596304402172;
		}
		13 => {
			if (*reader).row_index < (*reader).row_count {
				(*reader).state = EcsTableColumnNameLength;
				current_block_40 = 13619784596304402172;
			} else {
				current_block_40 = 267668232575933182;
			}
		}
		10 => {
			current_block_40 = 267668232575933182;
		}
		_ => {
			_ecs_abort(
				12 as libc::c_int,
				0 as *const libc::c_char,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				21037 as libc::c_int,
			);
			abort();
		}
	}
	match current_block_40 {
		267668232575933182 =>
		// fall through
		{
			(*reader).column_index += 1;
			if (*reader).column_index == (*reader).total_columns {
				(*reader).state = EcsTableHeader;
				next_table(stream, reader);
			} else {
				let mut type_buffer: *mut ecs_entity_t = _ecs_vector_first(
					(*reader).type_0,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				if (*reader).column_index >= 1 as libc::c_int {
					let mut e: ecs_entity_t =
						*type_buffer.offset(((*reader).column_index - 1 as libc::c_int) as isize);
					if e != 6 as libc::c_int as libc::c_ulong {
						(*reader).state = EcsTableColumnHeader
					} else {
						(*reader).state = EcsTableColumnNameHeader
					}
				} else {
					(*reader).state = EcsTableColumnHeader
				}
			}
		}
		_ => {}
	};
}
unsafe extern "C" fn ecs_table_reader(
	mut buffer: *mut libc::c_char,
	mut size: ecs_size_t,
	mut stream: *mut ecs_reader_t,
) -> ecs_size_t {
	if size == 0 {
		return 0 as libc::c_int;
	}
	if size < ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t {
		return -(1 as libc::c_int);
	}
	let mut reader: *mut ecs_table_reader_t = &mut (*stream).table;
	let mut read: ecs_size_t = 0 as libc::c_int;
	if (*reader).state as u64 == 0 {
		next_table(stream, reader);
		(*reader).state = EcsTableHeader
	}
	match (*reader).state as libc::c_uint {
		3 => {
			*(buffer as *mut ecs_blob_header_kind_t) = EcsTableHeader;
			read = ::std::mem::size_of::<ecs_blob_header_kind_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
		}
		4 => {
			*(buffer as *mut int32_t) = ecs_vector_count((*reader).type_0);
			read = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
		}
		5 => {
			let mut type_array: *mut ecs_entity_t = _ecs_vector_first(
				(*reader).type_0,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			*(buffer as *mut int32_t) = *((type_array as uintptr_t)
				.wrapping_add((*reader).type_written as uintptr_t)
				as *mut libc::c_void as *mut int32_t);
			(*reader).type_written +=
				::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			read = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			if (*reader).type_written
				== ecs_vector_count((*reader).type_0)
					* ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t
			{
				ecs_table_reader_next(stream);
			}
		}
		6 => {
			*(buffer as *mut int32_t) = ecs_table_count((*reader).table);
			read = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
		}
		8 => {
			*(buffer as *mut ecs_blob_header_kind_t) = EcsTableColumnHeader;
			read = ::std::mem::size_of::<ecs_blob_header_kind_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
		}
		9 => {
			*(buffer as *mut int32_t) = (*reader).column_size as int32_t;
			read = ::std::mem::size_of::<ecs_blob_header_kind_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
			if (*reader).column_size == 0 {
				ecs_table_reader_next(stream);
			}
		}
		10 => {
			let mut column_bytes: ecs_size_t =
				(*reader).column_size as libc::c_int * (*reader).row_count;
			read = column_bytes - (*reader).column_written;
			if read > size {
				read = size
			}
			memcpy(
				buffer as *mut libc::c_void,
				((*reader).column_data as uintptr_t)
					.wrapping_add((*reader).column_written as uintptr_t) as *mut libc::c_void,
				read as size_t,
			);
			(*reader).column_written += read;
			let mut align: ecs_size_t = ((read - 1 as libc::c_int)
				/ ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t
				+ 1 as libc::c_int)
				* ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			if align != read {
				/* Initialize padding bytes to 0 to keep valgrind happy */
				memset(
					(buffer as uintptr_t).wrapping_add(read as uintptr_t) as *mut libc::c_void,
					0 as libc::c_int,
					(align - read) as size_t,
				);
				/* Set read to align so that data is always aligned to 4 bytes */
				read = align
			}
			if (*reader).column_written == column_bytes {
				ecs_table_reader_next(stream);
			}
		}
		11 => {
			*(buffer as *mut ecs_blob_header_kind_t) = EcsTableColumnNameHeader;
			read = ::std::mem::size_of::<ecs_blob_header_kind_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
		}
		12 => {
			(*reader).name = (*((*reader).column_data as *mut EcsName)
				.offset((*reader).row_index as isize))
			.value;
			(*reader).name_len = strlen((*reader).name) as ecs_size_t + 1 as libc::c_int;
			(*reader).name_written = 0 as libc::c_int;
			*(buffer as *mut int32_t) = (*reader).name_len;
			read = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			ecs_table_reader_next(stream);
		}
		13 => {
			read = (*reader).name_len - (*reader).name_written;
			if read >= ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t {
				let mut i: int32_t = 0;
				i = 0 as libc::c_int;
				while i < 4 as libc::c_int {
					*((buffer as uintptr_t).wrapping_add(i as uintptr_t) as *mut libc::c_void
						as *mut libc::c_char) = *(((*reader).name as uintptr_t)
						.wrapping_add(((*reader).name_written + i) as uintptr_t)
						as *mut libc::c_void as *mut libc::c_char);
					i += 1
				}
				(*reader).name_written +=
					::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t
			} else {
				memcpy(
					buffer as *mut libc::c_void,
					((*reader).name as uintptr_t).wrapping_add((*reader).name_written as uintptr_t)
						as *mut libc::c_void,
					read as size_t,
				);
				memset(
					(buffer as uintptr_t).wrapping_add(read as uintptr_t) as *mut libc::c_void,
					0 as libc::c_int,
					(::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t - read)
						as size_t,
				);
				(*reader).name_written += read
			}
			/* Always align buffer to multiples of 4 bytes */
			read = ::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t;
			if (*reader).name_written == (*reader).name_len {
				ecs_table_reader_next(stream);
			}
		}
		_ => {
			_ecs_abort(
				12 as libc::c_int,
				0 as *const libc::c_char,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				21185 as libc::c_int,
			);
			abort();
		}
	}
	return read;
}
/* * Read from a reader.
 * This operation reads a specified number of bytes from a reader and stores it
 * in the specified buffer. When there are no more bytes to read from the reader
 * the operation will return 0, otherwise it will return the number of bytes
 * read.
 *
 * The specified buffer must be at least as big as the specified size, and the
 * specified size must be a multiple of 4.
 *
 * @param buffer The buffer in which to store the read bytes.
 * @param size The maximum number of bytes to read.
 * @param reader The reader from which to read the bytes.
 * @return The number of bytes read.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_reader_read(
	mut buffer: *mut libc::c_char,
	mut size: ecs_size_t,
	mut reader: *mut ecs_reader_t,
) -> ecs_size_t {
	let mut read: ecs_size_t = 0;
	let mut total_read: ecs_size_t = 0 as libc::c_int;
	let mut remaining: ecs_size_t = size;
	if size == 0 {
		return 0 as libc::c_int;
	}
	if (*reader).state as libc::c_uint == EcsTableSegment as libc::c_int as libc::c_uint {
		loop {
			read = ecs_table_reader(
				(buffer as uintptr_t).wrapping_add(total_read as uintptr_t) as *mut libc::c_void
					as *mut libc::c_char,
				remaining,
				reader,
			);
			if !(read != 0) {
				break;
			}
			remaining -= read;
			total_read += read;
			if (*reader).state as libc::c_uint != EcsTableSegment as libc::c_int as libc::c_uint {
				break;
			}
		}
	}
	return total_read;
}
/* * Initialize a reader.
 * A reader serializes data in a world to a sequence of bytes that can be stored
 * in a file or sent across a network.
 *
 * @param world The world to serialize.
 * @return The reader.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_reader_init(mut world: *mut ecs_world_t) -> ecs_reader_t {
	let mut result: ecs_reader_t = {
		let mut init = ecs_reader_t {
			world: world,
			state: EcsTableSegment,
			data_iter: ecs_filter_iter(world, 0 as *const ecs_filter_t),
			data_next: Some(ecs_filter_next as unsafe extern "C" fn(_: *mut ecs_iter_t) -> bool),
			component_iter: ecs_filter_iter(world, &mut {
				let mut init = ecs_filter_t {
					include: FLECS__TEcsComponent,
					exclude: 0 as *const ecs_vector_t,
					include_kind: EcsMatchDefault,
					exclude_kind: EcsMatchDefault,
				};
				init
			}),
			component_next: Some(
				ecs_filter_next as unsafe extern "C" fn(_: *mut ecs_iter_t) -> bool,
			),
			table: ecs_table_reader_t {
				state: EcsStreamHeader,
				table_index: 0,
				table: 0 as *mut ecs_table_t,
				data: 0 as *mut ecs_data_t,
				type_written: 0,
				type_0: 0 as *const ecs_vector_t,
				column_vector: 0 as *mut ecs_vector_t,
				column_index: 0,
				total_columns: 0,
				column_data: 0 as *mut libc::c_void,
				column_size: 0,
				column_alignment: 0,
				column_written: 0,
				row_index: 0,
				row_count: 0,
				name: 0 as *const libc::c_char,
				name_len: 0,
				name_written: 0,
				has_next_table: false,
			},
		};
		init
	};
	return result;
}
/* * Initialize a snapshot reader.
 * A snapshot reader serializes data in a snapshot to a sequence of bytes that
 * can be stored in a file or sent across a network. A snapshot reader has as
 * advantage that serialization can take place asynchronously while the world
 * is progressing.
 *
 * @param world The world in which the snapshot is taken.
 * @param iter Iterator to the data to be serialized.
 * @return The reader.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_reader_init_w_iter(
	mut it: *mut ecs_iter_t,
	mut next: ecs_iter_next_action_t,
) -> ecs_reader_t {
	let mut world: *mut ecs_world_t = (*it).world;
	let mut result: ecs_reader_t = {
		let mut init = ecs_reader_t {
			world: world,
			state: EcsTableSegment,
			data_iter: *it,
			data_next: next,
			component_iter: ecs_filter_iter(world, &mut {
				let mut init = ecs_filter_t {
					include: FLECS__TEcsComponent,
					exclude: 0 as *const ecs_vector_t,
					include_kind: EcsMatchDefault,
					exclude_kind: EcsMatchDefault,
				};
				init
			}),
			component_next: Some(
				ecs_filter_next as unsafe extern "C" fn(_: *mut ecs_iter_t) -> bool,
			),
			table: ecs_table_reader_t {
				state: EcsStreamHeader,
				table_index: 0,
				table: 0 as *mut ecs_table_t,
				data: 0 as *mut ecs_data_t,
				type_written: 0,
				type_0: 0 as *const ecs_vector_t,
				column_vector: 0 as *mut ecs_vector_t,
				column_index: 0,
				total_columns: 0,
				column_data: 0 as *mut libc::c_void,
				column_size: 0,
				column_alignment: 0,
				column_written: 0,
				row_index: 0,
				row_count: 0,
				name: 0 as *const libc::c_char,
				name_len: 0,
				name_written: 0,
				has_next_table: false,
			},
		};
		init
	};
	return result;
}
unsafe extern "C" fn bulk_delete(
	mut world: *mut ecs_world_t,
	mut filter: *const ecs_filter_t,
	mut is_delete: bool,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count((*world).store.tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		if !((*table).flags & 1 as libc::c_uint != 0) {
			if ecs_table_match_filter(world, table, filter) {
				/* Remove entities from index */
				let mut data: *mut ecs_data_t = ecs_table_get_data(table);
				if !data.is_null() {
					let mut entities: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
					if !data.is_null() {
						entities = (*data).entities
					}
					let mut e_ptr_i: libc::c_int = 0;
					let mut e_ptr_count: libc::c_int = ecs_vector_count(entities);
					let mut e_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
						entities,
						::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
							as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
						} as int16_t,
					) as *mut ecs_entity_t;
					e_ptr_i = 0 as libc::c_int;
					while e_ptr_i < e_ptr_count {
						let mut e_ptr: *mut ecs_entity_t =
							&mut *e_ptr_array.offset(e_ptr_i as isize) as *mut ecs_entity_t;
						ecs_sparse_remove((*world).store.entity_index, *e_ptr);
						e_ptr_i += 1
					}
					/* Both filters passed, clear table */
					if is_delete {
						ecs_table_clear(world, table);
					} else {
						ecs_table_clear_silent(world, table);
					}
				}
			}
		}
		/* If table has no data, there's nothing to delete */
		i += 1
	}
}
unsafe extern "C" fn merge_table(
	mut world: *mut ecs_world_t,
	mut dst_table: *mut ecs_table_t,
	mut src_table: *mut ecs_table_t,
	mut to_add: *mut ecs_entities_t,
	mut to_remove: *mut ecs_entities_t,
) {
	if (*dst_table).type_0.is_null() {
		/* If this removes all components, clear table */
		ecs_table_clear(world, src_table);
	} else if dst_table != src_table {
		let mut src_data: *mut ecs_data_t = ecs_table_get_data(src_table);
		let mut dst_count: int32_t = ecs_table_count(dst_table);
		let mut src_count: int32_t = ecs_table_count(src_table);
		if !to_remove.is_null() && (*to_remove).count != 0 && !src_data.is_null() {
			ecs_run_remove_actions(
				world,
				src_table,
				src_data,
				0 as libc::c_int,
				src_count,
				to_remove,
				0 as libc::c_int != 0,
			);
		}
		let mut dst_data: *mut ecs_data_t = ecs_table_get_data(dst_table);
		dst_data = ecs_table_merge(world, dst_table, src_table, dst_data, src_data);
		if !to_add.is_null() && (*to_add).count != 0 && !dst_data.is_null() {
			let mut set_mask: ecs_comp_set_t = {
				let mut init = ecs_comp_set_t {
					hi_count: 0 as libc::c_int,
					hi_array: [0; 32],
					lo_mask: [0; 4],
				};
				init
			};
			ecs_run_add_actions(
				world,
				dst_table,
				dst_data,
				dst_count,
				src_count,
				to_add,
				&mut set_mask,
				0 as libc::c_int != 0,
				1 as libc::c_int != 0,
			);
		}
	};
}
/* Merge table into dst_table */
/* * Add / remove component, type or tag from entities matching a filter.
 * Combination of ecs_bulk_add and ecs_bulk_remove.
 *
 * @param world The world.
 * @param to_add The component, type or tag to add.
 * @param to_remove The component, type or tag to remove.
 * @param filter The filter.
 */
/* * Delete entities matching a filter.
 * This operation is the same as ecs_delete, but applies to all entities that
 * match a filter.
 *
 * @param world The world.
 * @param filter The filter.
 */
/* -- Public API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_bulk_delete(
	mut world: *mut ecs_world_t,
	mut filter: *const ecs_filter_t,
) {
	bulk_delete(world, filter, 1 as libc::c_int != 0);
}
/* *
 * @file bulk.h
 * @brief Bulk API.
 */
/* * Add an entity to entities matching a filter.
 * This operation is the same as ecs_add_entity, but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param entity_add The entity to add.
 * @param filter The filter.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_bulk_add_entity(
	mut world: *mut ecs_world_t,
	mut to_add: ecs_entity_t,
	mut filter: *const ecs_filter_t,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut to_add_array: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut to_add,
			count: 1 as libc::c_int,
		};
		init
	};
	let mut added_entity: ecs_entity_t = 0;
	let mut added: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut added_entity,
			count: 0 as libc::c_int,
		};
		init
	};
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count((*world).store.tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		if !((*table).flags & 1 as libc::c_uint != 0) {
			if ecs_table_match_filter(world, table, filter) {
				let mut dst_table: *mut ecs_table_t =
					ecs_table_traverse_add(world, table, &mut to_add_array, &mut added);
				if !(added.count == 0) {
					merge_table(
						world,
						dst_table,
						table,
						&mut added,
						0 as *mut ecs_entities_t,
					);
					added.count = 0 as libc::c_int
				}
			}
		}
		i += 1
	}
}
/* * Add a component / type / tag to entities matching a filter.
 * This operation is the same as ecs_add but is applied to all entities
 * that match the provided filter.
 *
 * @param world The world.
 * @param type The component, type or tag to add.
 * @param filter The filter.
 */
/* * Removes an entity from entities matching a filter.
 * This operation is the same as ecs_remove_entity, but is applied to all
 * entities that match the provided filter.
 *
 * @param world The world.
 * @param entity_remove The entity to remove.
 * @param filter The filter.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_bulk_remove_entity(
	mut world: *mut ecs_world_t,
	mut to_remove: ecs_entity_t,
	mut filter: *const ecs_filter_t,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut to_remove_array: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut to_remove,
			count: 1 as libc::c_int,
		};
		init
	};
	let mut removed_entity: ecs_entity_t = 0;
	let mut removed: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut removed_entity,
			count: 0 as libc::c_int,
		};
		init
	};
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count((*world).store.tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		if !((*table).flags & 1 as libc::c_uint != 0) {
			if ecs_table_match_filter(world, table, filter) {
				let mut dst_table: *mut ecs_table_t =
					ecs_table_traverse_remove(world, table, &mut to_remove_array, &mut removed);
				if !(removed.count == 0) {
					merge_table(
						world,
						dst_table,
						table,
						0 as *mut ecs_entities_t,
						&mut removed,
					);
					removed.count = 0 as libc::c_int
				}
			}
		}
		i += 1
	}
}
/* Get current thread-specific stage */
/* -- Private functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_stage(mut world_ptr: *mut *mut ecs_world_t) -> *mut ecs_stage_t {
	let mut world: *mut ecs_world_t = *world_ptr;
	if (*world).magic == 0x65637377 as libc::c_int {
		if (*world).in_progress {
			return &mut (*world).temp_stage;
		} else {
			return &mut (*world).stage;
		}
	} else {
		if (*world).magic == 0x65637374 as libc::c_int {
			let mut thread: *mut ecs_thread_t = world as *mut ecs_thread_t;
			*world_ptr = (*thread).world;
			return (*thread).stage;
		}
	}
	return 0 as *mut ecs_stage_t;
}
/* Evaluate component monitor. If a monitored entity changed it will have set a
 * flag in one of the world's component monitors. Queries can register
 * themselves with component monitors to determine whether they need to rematch
 * with tables. */
unsafe extern "C" fn eval_component_monitor(
	mut world: *mut ecs_world_t,
	mut mon: *mut ecs_component_monitor_t,
) {
	if !(*mon).rematch {
		return;
	}
	let mut eval: [*mut ecs_vector_t; 256] = [0 as *mut ecs_vector_t; 256];
	let mut eval_count: int32_t = 0 as libc::c_int;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < 256 as libc::c_int {
		if (*mon).dirty_flags[i as usize] {
			let fresh29 = eval_count;
			eval_count = eval_count + 1;
			eval[fresh29 as usize] = (*mon).monitors[i as usize];
			(*mon).dirty_flags[i as usize] = 0 as libc::c_int != 0
		}
		i += 1
	}
	i = 0 as libc::c_int;
	while i < eval_count {
		let mut q_ptr_i: libc::c_int = 0;
		let mut q_ptr_count: libc::c_int = ecs_vector_count(eval[i as usize]);
		let mut q_ptr_array: *mut *mut ecs_query_t = _ecs_vector_first(
			eval[i as usize],
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_query_t;
		q_ptr_i = 0 as libc::c_int;
		while q_ptr_i < q_ptr_count {
			let mut q_ptr: *mut *mut ecs_query_t =
				&mut *q_ptr_array.offset(q_ptr_i as isize) as *mut *mut ecs_query_t;
			ecs_query_notify(world, *q_ptr, &mut {
				let mut init = ecs_query_event_t {
					kind: EcsQueryTableRematch,
					table: 0 as *mut ecs_table_t,
					parent_query: 0 as *mut ecs_query_t,
				};
				init
			});
			q_ptr_i += 1
		}
		i += 1
	}
	(*mon).rematch = 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_component_monitor_mark(
	mut mon: *mut ecs_component_monitor_t,
	mut component: ecs_entity_t,
) {
	/* Only flag if there are actually monitors registered, so that we
	 * don't waste cycles evaluating monitors if there's no interest */
	if !(*mon).monitors[component as usize].is_null() {
		(*mon).dirty_flags[component as usize] = 1 as libc::c_int != 0;
		(*mon).rematch = 1 as libc::c_int != 0
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_component_monitor_register(
	mut mon: *mut ecs_component_monitor_t,
	mut component: ecs_entity_t,
	mut query: *mut ecs_query_t,
) {
	/* Ignore component ids > ECS_HI_COMPONENT_ID */
	if component >= 256 as libc::c_int as libc::c_ulong {
		return;
	}
	let mut q: *mut *mut ecs_query_t = _ecs_vector_add(
		&mut *(*mon).monitors.as_mut_ptr().offset(component as isize),
		::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_query_t;
	*q = query;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_component_monitor_free(mut mon: *mut ecs_component_monitor_t) {
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < 256 as libc::c_int {
		ecs_vector_free((*mon).monitors[i as usize]);
		i += 1
	}
}
unsafe extern "C" fn init_store(mut world: *mut ecs_world_t) {
	memset(
		&mut (*world).store as *mut ecs_store_t as *mut libc::c_void,
		0 as libc::c_int,
		::std::mem::size_of::<ecs_store_t>() as libc::c_ulong as ecs_size_t as size_t,
	);
	/* Initialize entity index */
	(*world).store.entity_index =
		_ecs_sparse_new(::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t);
	ecs_sparse_set_id_source((*world).store.entity_index, &mut (*world).stats.last_id);
	/* Initialize root table */
	(*world).store.tables =
		_ecs_sparse_new(::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t);
	/* Initialize one root table per stage */
	ecs_init_root_table(world);
}
unsafe extern "C" fn clean_tables(mut world: *mut ecs_world_t) {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count((*world).store.tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut t: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		ecs_table_free(world, t);
		i += 1
	}
	/* Clear the root table */
	if count != 0 {
		ecs_table_reset(world, &mut (*world).store.root);
	};
}
unsafe extern "C" fn fini_store(mut world: *mut ecs_world_t) {
	clean_tables(world);
	ecs_sparse_free((*world).store.tables);
	ecs_table_free(world, &mut (*world).store.root);
	ecs_sparse_free((*world).store.entity_index);
}
/* * Same as ecs_init, but with minimal set of modules loaded.
 *
 * @return A new world object
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_mini() -> *mut ecs_world_t {
	ecs_os_init();
	ecs_log_push();
	if !ecs_os_has_heap() {
		_ecs_abort(
			32 as libc::c_int,
			0 as *const libc::c_char,
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			21776 as libc::c_int,
		);
		abort();
	}
	ecs_os_has_threading();
	ecs_os_has_time();
	let mut world: *mut ecs_world_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_world_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_world_t;
	(*world).magic = 0x65637377 as libc::c_int;
	memset(
		&mut (*world).c_info as *mut [ecs_c_info_t; 256] as *mut libc::c_void,
		0 as libc::c_int,
		(::std::mem::size_of::<ecs_c_info_t>() as libc::c_ulong)
			.wrapping_mul(256 as libc::c_int as libc::c_ulong),
	);
	(*world).t_info = _ecs_map_new(
		::std::mem::size_of::<ecs_c_info_t>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<ecs_c_info_t>() as libc::c_ulong as int64_t as ecs_size_t,
		0 as libc::c_int,
	);
	(*world).fini_actions = 0 as *mut ecs_vector_t;
	(*world).aliases = 0 as *mut ecs_vector_t;
	(*world).queries = _ecs_vector_new(
		::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
		0 as libc::c_int,
	);
	(*world).fini_tasks = _ecs_vector_new(
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		0 as libc::c_int,
	);
	(*world).child_tables = 0 as *mut ecs_map_t;
	(*world).name_prefix = 0 as *const libc::c_char;
	memset(
		&mut (*world).component_monitors as *mut ecs_component_monitor_t as *mut libc::c_void,
		0 as libc::c_int,
		::std::mem::size_of::<ecs_component_monitor_t>() as libc::c_ulong,
	);
	memset(
		&mut (*world).parent_monitors as *mut ecs_component_monitor_t as *mut libc::c_void,
		0 as libc::c_int,
		::std::mem::size_of::<ecs_component_monitor_t>() as libc::c_ulong,
	);
	(*world).type_handles = _ecs_map_new(
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t as ecs_size_t,
		0 as libc::c_int,
	);
	(*world).on_activate_components = _ecs_map_new(
		::std::mem::size_of::<ecs_on_demand_in_t>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<ecs_on_demand_in_t>() as libc::c_ulong as int64_t as ecs_size_t,
		0 as libc::c_int,
	);
	(*world).on_enable_components = _ecs_map_new(
		::std::mem::size_of::<ecs_on_demand_in_t>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<ecs_on_demand_in_t>() as libc::c_ulong as int64_t as ecs_size_t,
		0 as libc::c_int,
	);
	(*world).stage_count = 2 as libc::c_int;
	(*world).worker_stages = 0 as *mut ecs_vector_t;
	(*world).workers = 0 as *mut ecs_vector_t;
	(*world).workers_waiting = 0 as libc::c_int;
	(*world).workers_running = 0 as libc::c_int;
	(*world).valid_schedule = 0 as libc::c_int != 0;
	(*world).quit_workers = 0 as libc::c_int != 0;
	(*world).in_progress = 0 as libc::c_int != 0;
	(*world).is_merging = 0 as libc::c_int != 0;
	(*world).auto_merge = 1 as libc::c_int != 0;
	(*world).measure_frame_time = 0 as libc::c_int != 0;
	(*world).measure_system_time = 0 as libc::c_int != 0;
	(*world).should_quit = 0 as libc::c_int != 0;
	(*world).locking_enabled = 0 as libc::c_int != 0;
	(*world).pipeline = 0 as libc::c_int as ecs_entity_t;
	(*world).frame_start_time = {
		let mut init = ecs_time_t {
			sec: 0 as libc::c_int as uint32_t,
			nanosec: 0 as libc::c_int as uint32_t,
		};
		init
	};
	if ecs_os_has_time() {
		ecs_os_api.get_time_.expect("non-null function pointer")(&mut (*world).world_start_time);
	}
	(*world).stats.target_fps = 0 as libc::c_int as libc::c_float;
	(*world).stats.last_id = 0 as libc::c_int as ecs_entity_t;
	(*world).stats.delta_time_raw = 0 as libc::c_int as libc::c_float;
	(*world).stats.delta_time = 0 as libc::c_int as libc::c_float;
	(*world).stats.time_scale = 1.0f64 as libc::c_float;
	(*world).stats.frame_time_total = 0 as libc::c_int as libc::c_float;
	(*world).stats.sleep_err = 0 as libc::c_int as libc::c_float;
	(*world).stats.system_time_total = 0 as libc::c_int as libc::c_float;
	(*world).stats.merge_time_total = 0 as libc::c_int as libc::c_float;
	(*world).stats.world_time_total = 0 as libc::c_int as libc::c_float;
	(*world).stats.frame_count_total = 0 as libc::c_int;
	(*world).stats.merge_count_total = 0 as libc::c_int;
	(*world).stats.systems_ran_frame = 0 as libc::c_int;
	(*world).stats.pipeline_build_count_total = 0 as libc::c_int;
	(*world).range_check_enabled = 1 as libc::c_int != 0;
	(*world).fps_sleep = 0 as libc::c_int as libc::c_float;
	(*world).context = 0 as *mut libc::c_void;
	(*world).arg_fps = 0 as libc::c_int;
	(*world).arg_threads = 0 as libc::c_int;
	ecs_stage_init(world, &mut (*world).stage);
	ecs_stage_init(world, &mut (*world).temp_stage);
	init_store(world);
	(*world).stage.world = world;
	(*world).temp_stage.world = world;
	ecs_bootstrap(world);
	ecs_log_pop();
	return world;
}
/* * @} */
/* *
 * @defgroup convenience_macros Convenience Macro's
 * @{
 */
/* Macro's rely on variadic arguments which are C99 and above */
/* * Declare an extern component variable.
 * Use this macro in a header when defining a component identifier globally.
 * Must be used together with ECS_ENTITY_DECLARE.
 *
 * Example:
 *   ECS_COMPONENT_EXTERN(Position);
 */
/* * Declare an entity variable outside the scope of a function.
 * Use this macro in a header when defining a tag identifier globally.
 * Must be used together with ECS_ENTITY_DEFINE.
 *
 * Example:
 *   ECS_ENTITY_DECLARE(Position);
 */
/* * Define a component, store in variable outside of the current scope.
 * Use this macro in a header when defining a component identifier globally.
 * Must be used together with ECS_ENTITY_DECLARE.
 *
 * Example:
 *   ECS_ENTITY_DEFINE(world, Position);
 */
/* * Declare a named entity with a type expression.
 * Example:
 *   ECS_ENTITY(world, MyEntity, Position, Velocity);
 */
/* * Declare a prefab with a type expression.
 * Example:
 *   ECS_PREFAB(world, MyEntity, Position, Velocity);
 */
/* * Declare a component.
 * Example:
 *   ECS_COMPONENT(world, Position);
 */
/* * Declare an extern component variable.
 * Use this macro in a header when defining a component identifier globally.
 * Must be used together with ECS_COMPONENT_DECLARE.
 *
 * Example:
 *   ECS_COMPONENT_EXTERN(Position);
 */
/* * Declare a component variable outside the scope of a function.
 * Use this macro in a header when defining a component identifier globally.
 * Must be used together with ECS_COMPONENT_DEFINE.
 *
 * Example:
 *   ECS_COMPONENT_IMPL(Position);
 */
/* * Define a component, store in variable outside of the current scope.
 * Use this macro in a header when defining a component identifier globally.
 * Must be used together with ECS_COMPONENT_DECLARE.
 *
 * Example:
 *   ECS_COMPONENT_DEFINE(world, Position);
 */
/* * Declare a tag.
 * Example:
 *   ECS_TAG(world, MyTag);
 */
/* * Declare an extern tag variable.
 * Use this macro in a header when defining a tag identifier globally.
 * Must be used together with ECS_TAG_DECLARE.
 *
 * Example:
 *   ECS_TAG_EXTERN(Enemy);
 */
/* * Declare a tag variable outside the scope of a function.
 * Use this macro in a header when defining a tag identifier globally.
 * Must be used together with ECS_TAG_DEFINE.
 *
 * Example:
 *   ECS_TAG_DECLARE(Enemy);
 */
/* * Define a tag, store in variable outside of the current scope.
 * Use this macro in a header when defining a tag identifier globally.
 * Must be used together with ECS_TAG_DECLARE.
 *
 * Example:
 *   ECS_TAG_DEFINE(world, Enemy);
 */
/* * Declare a type.
 * Example:
 *   ECS_TYPE(world, MyType, Position, Velocity);
 */
/* * Declare an extern type variable.
 * Use this macro in a header when defining a type globally.
 * Must be used together with ECS_TYPE_DECLARE.
 *
 * Example:
 *   ECS_TYPE_EXTERN(Movable);
 */
/* * Declare a type variable outside the scope of a function.
 * Use this macro in a header when defining a type globally.
 * Must be used together with ECS_TYPE_DEFINE.
 *
 * Example:
 *   ECS_TYPE_DECLARE(Movable);
 */
/* * Define a type, store in variable outside of the current scope.
 * Use this macro in a header when defining a type globally.
 * Must be used together with ECS_TYPE_DECLARE.
 *
 * Example:
 *   ECS_TYPE_DEFINE(world, Movable, Position, Velocity);
 */
/* * Declare a constructor.
 * Example:
 *   ECS_CTOR(MyType, ptr, { ptr->value = NULL; });
 */
/* * Declare a destructor.
 * Example:
 *   ECS_DTOR(MyType, ptr, { free(ptr->value); });
 */
/* * Declare a copy action.
 * Example:
 *   ECS_COPY(MyType, dst, src, { dst->value = strdup(src->value); });
 */
/* * Declare a move action.
 * Example:
 *   ECS_MOVE(MyType, dst, src, { dst->value = src->value; src->value = 0; });
 */
/* Map from typename to function name of component lifecycle action */
/* FLECS_LEGACY */
/* * @} */
/* *
 * @defgroup world_api World API
 * @{
 */
/* * Create a new world.
 * A world manages all the ECS data and supporting infrastructure. Applications
 * must have at least one world. Entities, component and system handles are
 * local to a world and should not be shared between worlds.
 *
 * @return A new world object
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_init() -> *mut ecs_world_t {
	let mut world: *mut ecs_world_t = ecs_mini();
	ecs_log_push();
	let mut FLECS__MFlecsPipeline: FlecsPipeline = FlecsPipeline { dummy: 0 };
	let mut FlecsPipeline__name: *mut libc::c_char =
		ecs_module_path_from_c(b"FlecsPipeline\x00" as *const u8 as *const libc::c_char);
	let mut FLECS__EFlecsPipeline: ecs_entity_t = ecs_import(
		world,
		Some(FlecsPipelineImport as unsafe extern "C" fn(_: *mut ecs_world_t) -> ()),
		FlecsPipeline__name,
		&mut FLECS__MFlecsPipeline as *mut FlecsPipeline as *mut libc::c_void,
		::std::mem::size_of::<FlecsPipeline>() as libc::c_ulong,
	);
	ecs_os_api.free_.expect("non-null function pointer")(FlecsPipeline__name as *mut libc::c_void);
	let mut __FLECS__TFlecsPipeline_value: C2RustUnnamed_34 = {
		let mut init = C2RustUnnamed_34 {
			header: C2RustUnnamed_35 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsPipeline: *const ecs_vector_t =
		&mut __FLECS__TFlecsPipeline_value as *mut C2RustUnnamed_34 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsPipeline_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsPipeline as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__MFlecsTimer: FlecsTimer = FlecsTimer { dummy: 0 };
	let mut FlecsTimer__name: *mut libc::c_char =
		ecs_module_path_from_c(b"FlecsTimer\x00" as *const u8 as *const libc::c_char);
	let mut FLECS__EFlecsTimer: ecs_entity_t = ecs_import(
		world,
		Some(FlecsTimerImport as unsafe extern "C" fn(_: *mut ecs_world_t) -> ()),
		FlecsTimer__name,
		&mut FLECS__MFlecsTimer as *mut FlecsTimer as *mut libc::c_void,
		::std::mem::size_of::<FlecsTimer>() as libc::c_ulong,
	);
	ecs_os_api.free_.expect("non-null function pointer")(FlecsTimer__name as *mut libc::c_void);
	let mut __FLECS__TFlecsTimer_value: C2RustUnnamed_4 = {
		let mut init = C2RustUnnamed_4 {
			header: C2RustUnnamed_5 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsTimer: *const ecs_vector_t =
		&mut __FLECS__TFlecsTimer_value as *mut C2RustUnnamed_4 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsTimer_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsTimer as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	ecs_log_pop();
	return world;
}
/* * Create a new world with arguments.
 * Same as ecs_init, but allows passing in command line arguments. These can be
 * used to dynamically enable flecs features to an application, like performance
 * monitoring or the web dashboard (if it is installed) without having to modify
 * the code of an application.
 *
 * The following options are available:
 * --threads [n]   Use n worker threads
 * --fps [hz]      Run at hz FPS
 * --admin [port]  Enable admin dashboard (requires flecs-systems-admin & flecs-systems-civetweb)
 * --console       Enables console (requires flecs-systems-console)
 * --debug         Enables debug tracing
 *
 * @return A new world object
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_init_w_args(
	mut argc: libc::c_int,
	mut argv: *mut *mut libc::c_char,
) -> *mut ecs_world_t {
	return ecs_init();
}
unsafe extern "C" fn on_demand_in_map_deinit(mut map: *mut ecs_map_t) {
	let mut it: ecs_map_iter_t = ecs_map_iter(map);
	let mut elem: *mut ecs_on_demand_in_t = 0 as *mut ecs_on_demand_in_t;
	loop {
		elem = _ecs_map_next(
			&mut it,
			::std::mem::size_of::<ecs_on_demand_in_t>() as libc::c_ulong as ecs_size_t,
			0 as *mut ecs_map_key_t,
		) as *mut ecs_on_demand_in_t;
		if elem.is_null() {
			break;
		}
		ecs_vector_free((*elem).systems);
	}
	ecs_map_free(map);
}
unsafe extern "C" fn ctor_init_zero(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut entity_ptr: *const ecs_entity_t,
	mut ptr: *mut libc::c_void,
	mut size: size_t,
	mut count: int32_t,
	mut ctx: *mut libc::c_void,
) {
	memset(
		ptr,
		0 as libc::c_int,
		(ecs_from_size_t(size) * count) as size_t,
	);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_notify_tables(
	mut world: *mut ecs_world_t,
	mut event: *mut ecs_table_event_t,
) {
	let mut tables: *mut ecs_sparse_t = (*world).store.tables;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count(tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		ecs_table_notify(world, table, event);
		i += 1
	}
}
/* * Register ctor, dtor, copy & move actions for component.
 *
 * @param world The world.
 * @param component The component id for which to register the actions
 * @param actions Type that contains the component actions.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_component_actions_w_entity(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut lifecycle: *mut EcsComponentLifecycle,
) {
	let mut c_info: *mut ecs_c_info_t = ecs_get_or_create_c_info(world, component);
	if !(*c_info).lifecycle_set {
		(*c_info).component = component;
		(*c_info).lifecycle = *lifecycle;
		(*c_info).lifecycle_set = 1 as libc::c_int != 0;
		/* If no constructor is set, invoking any of the other lifecycle actions
		 * is not safe as they will potentially access uninitialized memory. For
		 * ease of use, if no constructor is specified, set a default one that
		 * initializes the component to 0. */
		if (*lifecycle).ctor.is_none()
			&& ((*lifecycle).dtor.is_some()
				|| (*lifecycle).copy.is_some()
				|| (*lifecycle).move_0.is_some())
		{
			(*c_info).lifecycle.ctor = Some(
				ctor_init_zero
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			)
		}
		ecs_notify_tables(world, &mut {
			let mut init = ecs_table_event_t {
				kind: EcsTableComponentInfo,
				query: 0 as *mut ecs_query_t,
				matched_table_index: 0,
				component: component,
			};
			init
		});
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_component_has_actions(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
) -> bool {
	let mut c_info: *mut ecs_c_info_t = ecs_get_c_info(world, component);
	return !c_info.is_null() && (*c_info).lifecycle_set as libc::c_int != 0;
}
/* * Register action to be executed when world is destroyed.
 * Fini actions are typically used when a module needs to clean up before a
 * world shuts down.
 *
 * @param world The world.
 * @param action The function to execute.
 * @param ctx Userdata to pass to the function */
#[no_mangle]
pub unsafe extern "C" fn ecs_atfini(
	mut world: *mut ecs_world_t,
	mut action: ecs_fini_action_t,
	mut ctx: *mut libc::c_void,
) {
	let mut elem: *mut ecs_action_elem_t = _ecs_vector_add(
		&mut (*world).fini_actions,
		::std::mem::size_of::<ecs_action_elem_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_action_elem_t;
	(*elem).action = action;
	(*elem).ctx = ctx;
}
/* * Register action to be executed once after frame.
 * Post frame actions are typically used for calling operations that cannot be
 * invoked during iteration, such as changing the number of threads.
 *
 * @param world The world.
 * @param action The function to execute.
 * @param ctx Userdata to pass to the function */
#[no_mangle]
pub unsafe extern "C" fn ecs_run_post_frame(
	mut world: *mut ecs_world_t,
	mut action: ecs_fini_action_t,
	mut ctx: *mut libc::c_void,
) {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut elem: *mut ecs_action_elem_t = _ecs_vector_add(
		&mut (*stage).post_frame_actions,
		::std::mem::size_of::<ecs_action_elem_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_action_elem_t;
	(*elem).action = action;
	(*elem).ctx = ctx;
}
/* Unset data in tables */
unsafe extern "C" fn fini_unset_tables(mut world: *mut ecs_world_t) {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count((*world).store.tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		ecs_table_unset(world, table);
		i += 1
	}
}
/* Invoke fini actions */
unsafe extern "C" fn fini_actions(mut world: *mut ecs_world_t) {
	let mut elem_i: libc::c_int = 0;
	let mut elem_count: libc::c_int = ecs_vector_count((*world).fini_actions);
	let mut elem_array: *mut ecs_action_elem_t = _ecs_vector_first(
		(*world).fini_actions,
		::std::mem::size_of::<ecs_action_elem_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_action_elem_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_action_elem_t;
	elem_i = 0 as libc::c_int;
	while elem_i < elem_count {
		let mut elem: *mut ecs_action_elem_t =
			&mut *elem_array.offset(elem_i as isize) as *mut ecs_action_elem_t;
		(*elem).action.expect("non-null function pointer")(world, (*elem).ctx);
		elem_i += 1
	}
	ecs_vector_free((*world).fini_actions);
}
/* Cleanup component lifecycle callbacks & systems */
unsafe extern "C" fn fini_component_lifecycle(mut world: *mut ecs_world_t) {
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < 256 as libc::c_int {
		ecs_vector_free((*world).c_info[i as usize].on_add);
		ecs_vector_free((*world).c_info[i as usize].on_remove);
		i += 1
	}
	let mut it: ecs_map_iter_t = ecs_map_iter((*world).t_info);
	let mut c_info: *mut ecs_c_info_t = 0 as *mut ecs_c_info_t;
	loop {
		c_info = _ecs_map_next(
			&mut it,
			::std::mem::size_of::<ecs_c_info_t>() as libc::c_ulong as ecs_size_t,
			0 as *mut ecs_map_key_t,
		) as *mut ecs_c_info_t;
		if c_info.is_null() {
			break;
		}
		ecs_vector_free((*c_info).on_add);
		ecs_vector_free((*c_info).on_remove);
	}
	ecs_map_free((*world).t_info);
}
/* Cleanup queries */
unsafe extern "C" fn fini_queries(mut world: *mut ecs_world_t) {
	/* Set world->queries to NULL, so ecs_query_free won't attempt to remove
	 * itself from the vector */
	let mut query_vec: *mut ecs_vector_t = (*world).queries;
	(*world).queries = 0 as *mut ecs_vector_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(query_vec);
	let mut queries: *mut *mut ecs_query_t = _ecs_vector_first(
		query_vec,
		::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_query_t;
	i = 0 as libc::c_int;
	while i < count {
		ecs_query_free(*queries.offset(i as isize));
		i += 1
	}
	ecs_vector_free(query_vec);
}
/* Cleanup stages */
unsafe extern "C" fn fini_stages(mut world: *mut ecs_world_t) {
	ecs_stage_deinit(world, &mut (*world).stage);
	ecs_stage_deinit(world, &mut (*world).temp_stage);
}
/* Cleanup child table admin */
unsafe extern "C" fn fini_child_tables(mut world: *mut ecs_world_t) {
	let mut it: ecs_map_iter_t = ecs_map_iter((*world).child_tables);
	let mut tables: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
	loop {
		tables = _ecs_map_next_ptr(&mut it, 0 as *mut ecs_map_key_t) as *mut ecs_vector_t;
		if tables.is_null() {
			break;
		}
		ecs_vector_free(tables);
	}
	ecs_map_free((*world).child_tables);
}
/* Cleanup aliases */
unsafe extern "C" fn fini_aliases(mut world: *mut ecs_world_t) {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*world).aliases);
	let mut aliases: *mut ecs_alias_t = _ecs_vector_first(
		(*world).aliases,
		::std::mem::size_of::<ecs_alias_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_alias_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_alias_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_alias_t;
	i = 0 as libc::c_int;
	while i < count {
		ecs_os_api.free_.expect("non-null function pointer")(
			(*aliases.offset(i as isize)).name as *mut libc::c_void,
		);
		i += 1
	}
	ecs_vector_free((*world).aliases);
}
/* Cleanup misc structures */
unsafe extern "C" fn fini_misc(mut world: *mut ecs_world_t) {
	on_demand_in_map_deinit((*world).on_activate_components);
	on_demand_in_map_deinit((*world).on_enable_components);
	ecs_map_free((*world).type_handles);
	ecs_vector_free((*world).fini_tasks);
	ecs_component_monitor_free(&mut (*world).component_monitors);
	ecs_component_monitor_free(&mut (*world).parent_monitors);
}
/* * Delete a world.
 * This operation deletes the world, and everything it contains.
 *
 * @param world The world to delete.
 * @return Zero if successful, non-zero if failed.
 */
/* The destroyer of worlds */
#[no_mangle]
pub unsafe extern "C" fn ecs_fini(mut world: *mut ecs_world_t) -> libc::c_int {
	fini_unset_tables(world);
	fini_actions(world);
	if (*world).locking_enabled {
		ecs_os_api.mutex_free_.expect("non-null function pointer")((*world).mutex);
	}
	fini_stages(world);
	fini_store(world);
	fini_component_lifecycle(world);
	fini_queries(world);
	fini_child_tables(world);
	fini_aliases(world);
	fini_misc(world);
	/* In case the application tries to use the memory of the freed world, this
	 * will trigger an assert */
	(*world).magic = 0 as libc::c_int;
	ecs_increase_timer_resolution(0 as libc::c_int != 0);
	/* End of the world */
	ecs_os_api.free_.expect("non-null function pointer")(world as *mut libc::c_void);
	ecs_os_fini();
	return 0 as libc::c_int;
}
/* * Dimension the world for a specified number of entities.
 * This operation will preallocate memory in the world for the specified number
 * of entities. Specifying a number lower than the current number of entities in
 * the world will have no effect. Note that this function does not allocate
 * memory for components (use ecs_dim_type for that).
 *
 * @param world The world.
 * @param entity_count The number of entities to preallocate.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_dim(mut world: *mut ecs_world_t, mut entity_count: int32_t) {
	ecs_sparse_set_size(
		(*world).store.entity_index,
		entity_count + 256 as libc::c_int,
	);
}
/* * Dimension a type for a specified number of entities.
 * This operation will preallocate memory for a type (table) for the
 * specified number of entites. Specifying a number lower than the current
 * number of entities in the table will have no effect.
 *
 * @param world The world.
 * @param type Handle to the type, as obtained by ecs_type_get.
 * @param entity_count The number of entities to preallocate.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_dim_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut entity_count: int32_t,
) {
	if !type_0.is_null() {
		let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
		let mut data: *mut ecs_data_t = ecs_table_get_or_create_data(table);
		ecs_table_set_size(world, table, data, entity_count);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_eval_component_monitors(mut world: *mut ecs_world_t) {
	eval_component_monitor(world, &mut (*world).component_monitors);
	eval_component_monitor(world, &mut (*world).parent_monitors);
}
/* * Manually merge.
 * When automerging is set to false, an application can invoke this operation to
 * force merging all stages.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_merge(mut world: *mut ecs_world_t) {
	let mut measure_frame_time: bool = (*world).measure_frame_time;
	(*world).is_merging = 1 as libc::c_int != 0;
	let mut t_start: ecs_time_t = ecs_time_t { sec: 0, nanosec: 0 };
	if measure_frame_time {
		ecs_os_api.get_time_.expect("non-null function pointer")(&mut t_start);
	}
	ecs_stage_merge(world, &mut (*world).temp_stage);
	let mut stage_i: libc::c_int = 0;
	let mut stage_count: libc::c_int = ecs_vector_count((*world).worker_stages);
	let mut stage_array: *mut ecs_stage_t = _ecs_vector_first(
		(*world).worker_stages,
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_stage_t;
	stage_i = 0 as libc::c_int;
	while stage_i < stage_count {
		let mut stage: *mut ecs_stage_t =
			&mut *stage_array.offset(stage_i as isize) as *mut ecs_stage_t;
		ecs_stage_merge(world, stage);
		stage_i += 1
	}
	(*world).is_merging = 0 as libc::c_int != 0;
	ecs_eval_component_monitors(world);
	if measure_frame_time {
		(*world).stats.merge_time_total += ecs_time_measure(&mut t_start) as libc::c_float
	}
	(*world).stats.merge_count_total += 1;
}
/* * Enable / disable automerging.
 * When automerging is enabled, running a pipeline will automatically merge when
 * necessary. With automerging disabled, merging will not happen unless the
 * application manually invokes ecs_merge.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_automerge(mut world: *mut ecs_world_t, mut auto_merge: bool) {
	(*world).auto_merge = auto_merge;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_measure_frame_time(mut world: *mut ecs_world_t, mut enable: bool) {
	if (*world).stats.target_fps as libc::c_double == 0.0f64 || enable as libc::c_int != 0 {
		(*world).measure_frame_time = enable
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_measure_system_time(mut world: *mut ecs_world_t, mut enable: bool) {
	(*world).measure_system_time = enable;
}
/* Increase timer resolution based on target fps */
unsafe extern "C" fn set_timer_resolution(mut fps: libc::c_float) {
	if fps >= 60.0f32 {
		ecs_increase_timer_resolution(1 as libc::c_int != 0);
	} else {
		ecs_increase_timer_resolution(0 as libc::c_int != 0);
	};
}
/* * Set target frames per second (FPS) for application.
 * Setting the target FPS ensures that ecs_progress is not invoked faster than
 * the specified FPS. When enabled, ecs_progress tracks the time passed since
 * the last invocation, and sleeps the remaining time of the frame (if any).
 *
 * This feature ensures systems are ran at a consistent interval, as well as
 * conserving CPU time by not running systems more often than required.
 *
 * Note that ecs_progress only sleeps if there is time left in the frame. Both
 * time spent in flecs as time spent outside of flecs are taken into
 * account.
 *
 * @param world The world.
 * @param fps The target FPS.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_target_fps(mut world: *mut ecs_world_t, mut fps: libc::c_float) {
	if (*world).arg_fps == 0 {
		ecs_measure_frame_time(world, 1 as libc::c_int != 0);
		(*world).stats.target_fps = fps;
		set_timer_resolution(fps);
	};
}
/* * Get the world context.
 * This operation retrieves a previously set world context.
 *
 * @param world The world.
 * @return The context set with ecs_set_context. If no context was set, the
 *         function returns NULL.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_context(mut world: *mut ecs_world_t) -> *mut libc::c_void {
	ecs_get_stage(&mut world);
	return (*world).context;
}
/* * Set a world context.
 * This operation allows an application to register custom data with a world
 * that can be accessed anywhere where the application has the world object.
 *
 * @param world The world.
 * @param ctx A pointer to a user defined structure.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_context(
	mut world: *mut ecs_world_t,
	mut context: *mut libc::c_void,
) {
	(*world).context = context;
}
/* * Set a range for issueing new entity ids.
 * This function constrains the entity identifiers returned by ecs_new to the
 * specified range. This operation can be used to ensure that multiple processes
 * can run in the same simulation without requiring a central service that
 * coordinates issueing identifiers.
 *
 * If id_end is set to 0, the range is infinite. If id_end is set to a non-zero
 * value, it has to be larger than id_start. If id_end is set and ecs_new is
 * invoked after an id is issued that is equal to id_end, the application will
 * abort.
 *
 * @param world The world.
 * @param id_start The start of the range.
 * @param id_end The end of the range.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_entity_range(
	mut world: *mut ecs_world_t,
	mut id_start: ecs_entity_t,
	mut id_end: ecs_entity_t,
) {
	if (*world).stats.last_id < id_start {
		(*world).stats.last_id = id_start.wrapping_sub(1 as libc::c_int as libc::c_ulong)
	}
	(*world).stats.min_id = id_start;
	(*world).stats.max_id = id_end;
}
/* * Enable/disable range limits.
 * When an application is both a receiver of range-limited entities and a
 * producer of range-limited entities, range checking needs to be temporarily
 * disabled when inserting received entities. Range checking is disabled on a
 * stage, so setting this value is thread safe.
 *
 * @param world The world.
 * @param enable True if range checking should be enabled, false to disable.
 * @return The previous value.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_enable_range_check(
	mut world: *mut ecs_world_t,
	mut enable: bool,
) -> bool {
	let mut old_value: bool = (*world).range_check_enabled;
	(*world).range_check_enabled = enable;
	return old_value;
}
/* * Get current thread index */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_thread_index(mut world: *mut ecs_world_t) -> int32_t {
	if (*world).magic == 0x65637374 as libc::c_int {
		let mut thr: *mut ecs_thread_t = world as *mut ecs_thread_t;
		return (*thr).index;
	} else if (*world).magic == 0x65637377 as libc::c_int {
		return 0 as libc::c_int;
	} else {
		_ecs_abort(
			12 as libc::c_int,
			0 as *const libc::c_char,
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			22369 as libc::c_int,
		);
		abort();
	};
}
/* * Get current number of threads. */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_threads(mut world: *mut ecs_world_t) -> int32_t {
	return ecs_vector_count((*world).workers);
}
/* * Enable world locking while in progress.
 * When locking is enabled, Flecs will lock the world while in progress. This
 * allows applications to interact with the world from other threads without
 * running into race conditions.
 *
 * This is a better alternative to applications putting a lock around calls to
 * ecs_progress, since ecs_progress can sleep when FPS control is enabled,
 * which is time during which other threads could perform work.
 *
 * Locking must be enabled before applications can use the ecs_lock and
 * ecs_unlock functions. Locking is turned off by default.
 *
 * @param world The world.
 * @param enable True if locking is to be enabled.
 * @result The previous value of the setting.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_enable_locking(mut world: *mut ecs_world_t, mut enable: bool) -> bool {
	if enable {
		if !(*world).locking_enabled {
			(*world).mutex = ecs_os_api.mutex_new_.expect("non-null function pointer")();
			(*world).thr_sync = ecs_os_api.mutex_new_.expect("non-null function pointer")();
			(*world).thr_cond = ecs_os_api.cond_new_.expect("non-null function pointer")()
		}
	} else if (*world).locking_enabled {
		ecs_os_api.mutex_free_.expect("non-null function pointer")((*world).mutex);
		ecs_os_api.mutex_free_.expect("non-null function pointer")((*world).thr_sync);
		ecs_os_api.cond_free_.expect("non-null function pointer")((*world).thr_cond);
	}
	let mut old: bool = (*world).locking_enabled;
	(*world).locking_enabled = enable;
	return old;
}
/* * Locks the world.
 * See ecs_enable_locking for details.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_lock(mut world: *mut ecs_world_t) {
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).mutex);
}
/* * Unlocks the world.
 * See ecs_enable_locking for details.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_unlock(mut world: *mut ecs_world_t) {
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).mutex);
}
/* * Wait until world becomes available.
 * When a non-flecs thread needs to interact with the world, it should invoke
 * this function to wait until the world becomes available (as in, it is not
 * progressing the frame). Invoking this function guarantees that the thread
 * will not starve. (as opposed to simply taking the world lock).
 *
 * An application will have to invoke ecs_end_wait after this function returns.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_begin_wait(mut world: *mut ecs_world_t) {
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).thr_sync);
	ecs_os_api.cond_wait_.expect("non-null function pointer")((*world).thr_cond, (*world).thr_sync);
}
/* * Release world after calling ecs_begin_wait.
 * This operation should be invoked after invoking ecs_begin_wait, and will
 * release the world back to the thread running the main loop.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_end_wait(mut world: *mut ecs_world_t) {
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).thr_sync);
}
/* Get component callbacks */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_c_info(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
) -> *mut ecs_c_info_t {
	if component < 256 as libc::c_int as libc::c_ulong {
		let mut c_info: *mut ecs_c_info_t =
			&mut *(*world).c_info.as_mut_ptr().offset(component as isize) as *mut ecs_c_info_t;
		if (*c_info).component != 0 {
			return c_info;
		} else {
			return 0 as *mut ecs_c_info_t;
		}
	} else {
		return _ecs_map_get(
			(*world).t_info,
			::std::mem::size_of::<ecs_c_info_t>() as libc::c_ulong as ecs_size_t,
			component,
		) as *mut ecs_c_info_t;
	};
}
/* Get or create component callbacks */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_or_create_c_info(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
) -> *mut ecs_c_info_t {
	let mut c_info: *mut ecs_c_info_t = ecs_get_c_info(world, component);
	if c_info.is_null() {
		if component < 256 as libc::c_int as libc::c_ulong {
			c_info =
				&mut *(*world).c_info.as_mut_ptr().offset(component as isize) as *mut ecs_c_info_t;
			(*c_info).component = component
		} else {
			let mut t_info: ecs_c_info_t = {
				let mut init = ecs_c_info_t {
					component: 0 as libc::c_int as ecs_entity_t,
					on_add: 0 as *mut ecs_vector_t,
					on_remove: 0 as *mut ecs_vector_t,
					lifecycle: EcsComponentLifecycle {
						ctor: None,
						dtor: None,
						copy: None,
						move_0: None,
						ctx: 0 as *mut libc::c_void,
					},
					lifecycle_set: false,
				};
				init
			};
			_ecs_map_set(
				(*world).t_info,
				::std::mem::size_of::<ecs_c_info_t>() as libc::c_ulong as ecs_size_t,
				component,
				&mut t_info as *mut ecs_c_info_t as *const libc::c_void,
			);
			c_info = _ecs_map_get(
				(*world).t_info,
				::std::mem::size_of::<ecs_c_info_t>() as libc::c_ulong as ecs_size_t,
				component,
			) as *mut ecs_c_info_t
		}
	}
	return c_info;
}
/* * Begin staging.
 * When staging is enabled, modifications to entities are stored to a stage.
 * This ensures that arrays are not modified while iterating. Modifications are
 * merged back to the "main stage" when ecs_staging_end is invoked.
 *
 * @param world The world
 * @return Whether world is currently staged.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_staging_begin(mut world: *mut ecs_world_t) -> bool {
	let mut in_progress: bool = (*world).in_progress;
	(*world).in_progress = 1 as libc::c_int != 0;
	return in_progress;
}
/* * End staging.
 * If any data was staged, this operation will merge that data back to the main
 * stage.
 *
 * @param world The world
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_staging_end(mut world: *mut ecs_world_t) {
	(*world).in_progress = 0 as libc::c_int != 0;
	if (*world).auto_merge {
		ecs_merge(world);
	};
}
unsafe extern "C" fn insert_sleep(
	mut world: *mut ecs_world_t,
	mut stop: *mut ecs_time_t,
) -> libc::c_double {
	let mut start: ecs_time_t = *stop;
	let mut delta_time: libc::c_double = ecs_time_measure(stop);
	if (*world).stats.target_fps == 0 as libc::c_int as libc::c_float {
		return delta_time;
	}
	let mut target_delta_time: libc::c_double =
		1.0f64 / (*world).stats.target_fps as libc::c_double;
	let mut world_sleep_err: libc::c_double = (*world).stats.sleep_err as libc::c_double
		/ (*world).stats.frame_count_total as libc::c_double;
	/* Calculate the time we need to sleep by taking the measured delta from the
	 * previous frame, and subtracting it from target_delta_time. */
	let mut sleep: libc::c_double = target_delta_time - delta_time;
	/* Pick a sleep interval that is 20 times lower than the time one frame
	 * should take. This means that this function at most iterates 20 times in
	 * a busy loop */
	let mut sleep_time: libc::c_double = target_delta_time / 20 as libc::c_int as libc::c_double;
	/* Measure at least two frames before interpreting sleep error */
	if (*world).stats.frame_count_total > 1 as libc::c_int {
		/* If the ratio between the sleep error and the sleep time is too high,
		 * just do a busy loop */
		if world_sleep_err / sleep_time > 0.1f64 {
			sleep_time = 0 as libc::c_int as libc::c_double
		}
	}
	/* If the time we need to sleep is large enough to warrant a sleep, sleep */
	if sleep > sleep_time - world_sleep_err {
		if sleep_time > sleep {
			/* Make sure we don't sleep longer than we should */
			sleep_time = sleep
		}
		let mut sleep_err: libc::c_double = 0 as libc::c_int as libc::c_double;
		let mut iterations: int32_t = 0 as libc::c_int;
		loop {
			/* Only call sleep when sleep_time is not 0. On some platforms, even
			 * a sleep with a timeout of 0 can cause stutter. */
			if sleep_time != 0 as libc::c_int as libc::c_double {
				ecs_sleepf(sleep_time);
			}
			let mut now: ecs_time_t = start;
			let mut prev_delta_time: libc::c_double = delta_time;
			delta_time = ecs_time_measure(&mut now);
			/* Measure the error of the sleep by taking the difference between
			 * the time we expected to sleep, and the measured time. This
			 * assumes that a sleep is less accurate than a high resolution
			 * timer which should be true in most cases. */
			sleep_err = delta_time - prev_delta_time - sleep_time;
			iterations += 1;
			if !(target_delta_time - delta_time > sleep_time - world_sleep_err) {
				break;
			}
		}
		/* Add sleep error measurement to sleep error, with a bias towards the
		 * latest measured values. */
		(*world).stats.sleep_err = (world_sleep_err * 0.9f64 + sleep_err * 0.1f64) as libc::c_float
			* (*world).stats.frame_count_total as libc::c_float
	}
	/*  Make last minute corrections if due to a larger clock error delta_time
	 * is still more than 5% away from the target. The 5% buffer is to account
	 * for the fact that measuring the time also takes time. */
	while delta_time < target_delta_time * 0.95f64 {
		let mut now_0: ecs_time_t = start;
		delta_time = ecs_time_measure(&mut now_0)
	}
	return delta_time;
}
unsafe extern "C" fn start_measure_frame(
	mut world: *mut ecs_world_t,
	mut user_delta_time: libc::c_float,
) -> libc::c_float {
	let mut delta_time: libc::c_double = 0 as libc::c_int as libc::c_double;
	if (*world).measure_frame_time as libc::c_int != 0
		|| user_delta_time == 0 as libc::c_int as libc::c_float
	{
		let mut t: ecs_time_t = (*world).frame_start_time;
		loop {
			if (*world).frame_start_time.sec != 0 {
				delta_time = insert_sleep(world, &mut t);
				ecs_time_measure(&mut t);
			} else {
				ecs_time_measure(&mut t);
				if (*world).stats.target_fps != 0 as libc::c_int as libc::c_float {
					delta_time = 1.0f64 / (*world).stats.target_fps as libc::c_double
				} else {
					delta_time = 1.0f64 / 60.0f64
					/* Best guess */
				}
			}
			if !(delta_time == 0 as libc::c_int as libc::c_double) {
				break;
			}
			/* Keep trying while delta_time is zero */
		}
		(*world).frame_start_time = t;
		/* Keep track of total time passed in world */
		(*world).stats.world_time_total_raw += delta_time as libc::c_float
	}
	return delta_time as libc::c_float;
}
unsafe extern "C" fn stop_measure_frame(mut world: *mut ecs_world_t) {
	if (*world).measure_frame_time {
		let mut t: ecs_time_t = (*world).frame_start_time;
		(*world).stats.frame_time_total += ecs_time_measure(&mut t) as libc::c_float
	};
}
/* * Get a strongly typed pointer to a column (owned or shared). */
/* * Get a strongly typed pointer to a column (owned or shared). */
/* * Obtain a handle to the component of a column */
/* * Obtain a handle to the entity of a column */
/* * Utility macro for importing all handles for a module from a system column */
/* * @} */
/* *
 * @defgroup staging Staging
 * @{
 */
/* * Begin frame. */
#[no_mangle]
pub unsafe extern "C" fn ecs_frame_begin(
	mut world: *mut ecs_world_t,
	mut user_delta_time: libc::c_float,
) -> libc::c_float {
	if (*world).locking_enabled {
		ecs_lock(world);
	}
	/* Start measuring total frame time */
	let mut delta_time: libc::c_float = start_measure_frame(world, user_delta_time);
	if user_delta_time == 0 as libc::c_int as libc::c_float {
		user_delta_time = delta_time
	}
	(*world).stats.delta_time_raw = user_delta_time;
	(*world).stats.delta_time = user_delta_time * (*world).stats.time_scale;
	/* Keep track of total scaled time passed in world */
	(*world).stats.world_time_total += (*world).stats.delta_time;
	return user_delta_time;
}
/* * End frame. */
#[no_mangle]
pub unsafe extern "C" fn ecs_frame_end(mut world: *mut ecs_world_t) {
	(*world).stats.frame_count_total += 1;
	ecs_stage_merge_post_frame(world, &mut (*world).temp_stage);
	let mut stage_i: libc::c_int = 0;
	let mut stage_count: libc::c_int = ecs_vector_count((*world).worker_stages);
	let mut stage_array: *mut ecs_stage_t = _ecs_vector_first(
		(*world).worker_stages,
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_stage_t;
	stage_i = 0 as libc::c_int;
	while stage_i < stage_count {
		let mut stage: *mut ecs_stage_t =
			&mut *stage_array.offset(stage_i as isize) as *mut ecs_stage_t;
		ecs_stage_merge_post_frame(world, stage);
		stage_i += 1
	}
	if (*world).locking_enabled {
		ecs_unlock(world);
		ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).thr_sync);
		ecs_os_api
			.cond_broadcast_
			.expect("non-null function pointer")((*world).thr_cond);
		ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).thr_sync);
	}
	stop_measure_frame(world);
}
/* * Get world info.
 *
 * @param world The world.
 * @return Pointer to the world info. This pointer will remain valid for as long
 *         as the world is valid.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_world_info(
	mut world: *mut ecs_world_t,
) -> *const ecs_world_info_t {
	return &mut (*world).stats;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_notify_queries(
	mut world: *mut ecs_world_t,
	mut event: *mut ecs_query_event_t,
) {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*world).queries);
	let mut queries: *mut *mut ecs_query_t = _ecs_vector_first(
		(*world).queries,
		::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_query_t;
	i = 0 as libc::c_int;
	while i < count {
		ecs_query_notify(world, *queries.offset(i as isize), event);
		i += 1
	}
}
/* Delete table from stage */
#[no_mangle]
pub unsafe extern "C" fn ecs_delete_table(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
) {
	/* Notify queries that table is to be removed */
	ecs_notify_queries(world, &mut {
		let mut init = ecs_query_event_t {
			kind: EcsQueryTableUnmatch,
			table: table,
			parent_query: 0 as *mut ecs_query_t,
		};
		init
	});
	let mut id: uint32_t = (*table).id;
	/* Free resources associated with table */
	ecs_table_free(world, table);
	/* Remove table from sparse set */
	ecs_sparse_remove((*world).store.tables, id as uint64_t);
	/* Don't do generations as we want table ids to remain 32 bit */
	ecs_sparse_set_generation((*world).store.tables, id as uint64_t);
}
unsafe extern "C" fn get_header(
	mut sw: *const ecs_switch_t,
	mut value: uint64_t,
) -> *mut ecs_switch_header_t {
	if value == 0 as libc::c_int as libc::c_ulong {
		return 0 as *mut ecs_switch_header_t;
	}
	let mut index: uint64_t = value.wrapping_sub((*sw).min);
	return &mut *(*sw).headers.offset(index as isize) as *mut ecs_switch_header_t;
}
unsafe extern "C" fn remove_node(
	mut hdr: *mut ecs_switch_header_t,
	mut nodes: *mut ecs_switch_node_t,
	mut node: *mut ecs_switch_node_t,
	mut element: int32_t,
) {
	/* The node is currently assigned to a value */
	if (*hdr).element == element {
		/* If this is the first node, update the header */
		(*hdr).element = (*node).next
	} else {
		/* If this is not the first node, update the previous node */
		let mut prev_node: *mut ecs_switch_node_t =
			&mut *nodes.offset((*node).prev as isize) as *mut ecs_switch_node_t;
		(*prev_node).next = (*node).next
	}
	let mut next: int32_t = (*node).next;
	if next != -(1 as libc::c_int) {
		/* If this is not the last node, update the next node */
		let mut next_node: *mut ecs_switch_node_t =
			&mut *nodes.offset(next as isize) as *mut ecs_switch_node_t;
		(*next_node).prev = (*node).prev
	}
	/* Decrease count of current header */
	(*hdr).count -= 1;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_new(
	mut min: uint64_t,
	mut max: uint64_t,
	mut elements: int32_t,
) -> *mut ecs_switch_t {
	/* Min must be larger than 0, as 0 is an invalid entity id, and should
	 * therefore never occur as case id */
	let mut result: *mut ecs_switch_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_switch_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_switch_t;
	(*result).min = min;
	(*result).max = max;
	let mut count: int32_t = max.wrapping_sub(min) as int32_t + 1 as libc::c_int;
	(*result).headers = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_switch_header_t>() as libc::c_ulong as ecs_size_t * count,
	) as *mut ecs_switch_header_t;
	(*result).nodes = _ecs_vector_new(
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
		elements,
	);
	(*result).values = _ecs_vector_new(
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		elements,
	);
	let mut i: int64_t = 0;
	i = 0 as libc::c_int as int64_t;
	while i < count as libc::c_long {
		(*(*result).headers.offset(i as isize)).element = -(1 as libc::c_int);
		(*(*result).headers.offset(i as isize)).count = 0 as libc::c_int;
		i += 1
	}
	let mut nodes: *mut ecs_switch_node_t = _ecs_vector_first(
		(*result).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_switch_node_t;
	let mut values: *mut uint64_t = _ecs_vector_first(
		(*result).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	i = 0 as libc::c_int as int64_t;
	while i < elements as libc::c_long {
		(*nodes.offset(i as isize)).prev = -(1 as libc::c_int);
		(*nodes.offset(i as isize)).next = -(1 as libc::c_int);
		*values.offset(i as isize) = 0 as libc::c_int as uint64_t;
		i += 1
	}
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_free(mut sw: *mut ecs_switch_t) {
	ecs_os_api.free_.expect("non-null function pointer")((*sw).headers as *mut libc::c_void);
	ecs_vector_free((*sw).nodes);
	ecs_vector_free((*sw).values);
	ecs_os_api.free_.expect("non-null function pointer")(sw as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_add(mut sw: *mut ecs_switch_t) {
	let mut node: *mut ecs_switch_node_t = _ecs_vector_add(
		&mut (*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_switch_node_t;
	let mut value: *mut uint64_t = _ecs_vector_add(
		&mut (*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	(*node).prev = -(1 as libc::c_int);
	(*node).next = -(1 as libc::c_int);
	*value = 0 as libc::c_int as uint64_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_set_count(mut sw: *mut ecs_switch_t, mut count: int32_t) {
	let mut old_count: int32_t = ecs_vector_count((*sw).nodes);
	if old_count == count {
		return;
	}
	_ecs_vector_set_count(
		&mut (*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
		count,
	);
	_ecs_vector_set_count(
		&mut (*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		count,
	);
	let mut nodes: *mut ecs_switch_node_t = _ecs_vector_first(
		(*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_switch_node_t;
	let mut values: *mut uint64_t = _ecs_vector_first(
		(*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	let mut i: int32_t = 0;
	i = old_count;
	while i < count {
		let mut node: *mut ecs_switch_node_t =
			&mut *nodes.offset(i as isize) as *mut ecs_switch_node_t;
		(*node).prev = -(1 as libc::c_int);
		(*node).next = -(1 as libc::c_int);
		*values.offset(i as isize) = 0 as libc::c_int as uint64_t;
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_set_min_count(mut sw: *mut ecs_switch_t, mut count: int32_t) {
	let mut old_count: int32_t = ecs_vector_count((*sw).nodes);
	if old_count >= count {
		return;
	}
	ecs_switch_set_count(sw, count);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_addn(mut sw: *mut ecs_switch_t, mut count: int32_t) {
	let mut old_count: int32_t = ecs_vector_count((*sw).nodes);
	ecs_switch_set_count(sw, old_count + count);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_set(
	mut sw: *mut ecs_switch_t,
	mut element: int32_t,
	mut value: uint64_t,
) {
	let mut values: *mut uint64_t = _ecs_vector_first(
		(*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	let mut cur_value: uint64_t = *values.offset(element as isize);
	/* If the node is already assigned to the value, nothing to be done */
	if cur_value == value {
		return;
	}
	let mut nodes: *mut ecs_switch_node_t = _ecs_vector_first(
		(*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_switch_node_t;
	let mut node: *mut ecs_switch_node_t =
		&mut *nodes.offset(element as isize) as *mut ecs_switch_node_t;
	let mut cur_hdr: *mut ecs_switch_header_t = get_header(sw, cur_value);
	let mut dst_hdr: *mut ecs_switch_header_t = get_header(sw, value);
	if !cur_hdr.is_null() {
		remove_node(cur_hdr, nodes, node, element);
	}
	/* Now update the node itself by adding it as the first node of dst */
	(*node).next = (*dst_hdr).element;
	(*node).prev = -(1 as libc::c_int);
	*values.offset(element as isize) = value;
	/* Also update the dst header */
	let mut first: int32_t = (*dst_hdr).element;
	if first != -(1 as libc::c_int) {
		let mut first_node: *mut ecs_switch_node_t =
			&mut *nodes.offset(first as isize) as *mut ecs_switch_node_t;
		(*first_node).prev = element
	}
	(*dst_hdr).element = element;
	(*dst_hdr).count += 1;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_remove(mut sw: *mut ecs_switch_t, mut element: int32_t) {
	let mut values: *mut uint64_t = _ecs_vector_first(
		(*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	let mut value: uint64_t = *values.offset(element as isize);
	let mut nodes: *mut ecs_switch_node_t = _ecs_vector_first(
		(*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_switch_node_t;
	let mut node: *mut ecs_switch_node_t =
		&mut *nodes.offset(element as isize) as *mut ecs_switch_node_t;
	/* If node is currently assigned to a case, remove it from the list */
	if value != 0 as libc::c_int as libc::c_ulong {
		let mut hdr: *mut ecs_switch_header_t = get_header(sw, value);
		remove_node(hdr, nodes, node, element);
	}
	/* Remove element from arrays */
	_ecs_vector_remove_index(
		(*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
		element,
	);
	_ecs_vector_remove_index(
		(*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
		element,
	);
	if ecs_vector_count((*sw).nodes) != 0 {
		let mut prev: int32_t = (*node).prev;
		if prev != -(1 as libc::c_int) {
			(*nodes.offset(prev as isize)).next = element
		} else {
			let mut hdr_0: *mut ecs_switch_header_t =
				get_header(sw, *values.offset(element as isize));
			if !hdr_0.is_null() && (*hdr_0).element != -(1 as libc::c_int) {
				(*hdr_0).element = element
			}
		}
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_get(
	mut sw: *const ecs_switch_t,
	mut element: int32_t,
) -> uint64_t {
	let mut values: *mut uint64_t = _ecs_vector_first(
		(*sw).values,
		::std::mem::size_of::<uint64_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<uint64_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut uint64_t;
	return *values.offset(element as isize);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_values(mut sw: *const ecs_switch_t) -> *mut ecs_vector_t {
	return (*sw).values;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_case_count(
	mut sw: *const ecs_switch_t,
	mut value: uint64_t,
) -> int32_t {
	let mut hdr: *mut ecs_switch_header_t = get_header(sw, value);
	if hdr.is_null() {
		return 0 as libc::c_int;
	}
	return (*hdr).count;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_first(
	mut sw: *const ecs_switch_t,
	mut value: uint64_t,
) -> int32_t {
	let mut hdr: *mut ecs_switch_header_t = get_header(sw, value);
	return (*hdr).element;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_switch_next(
	mut sw: *const ecs_switch_t,
	mut element: int32_t,
) -> int32_t {
	let mut nodes: *mut ecs_switch_node_t = _ecs_vector_first(
		(*sw).nodes,
		::std::mem::size_of::<ecs_switch_node_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_switch_node_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_switch_node_t;
	return (*nodes.offset(element as isize)).next;
}
/* * @} */
/* *
 * @defgroup filters Filters
 * @{
 */
/* * Return a filter iterator.
 * A filter iterator lets an application iterate over entities that match the
 * specified filter. If NULL is provided for the filter, the iterator will
 * iterate all tables in the world.
 *
 * @param world The world.
 * @param filter The filter.
 * @return An iterator that can be used with ecs_filter_next.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_filter_iter(
	mut world: *mut ecs_world_t,
	mut filter: *const ecs_filter_t,
) -> ecs_iter_t {
	let mut iter: ecs_filter_iter_t = {
		let mut init = ecs_filter_iter_t {
			filter: if !filter.is_null() {
				*filter
			} else {
				let mut init = ecs_filter_t {
					include: 0 as ecs_type_t,
					exclude: 0 as *const ecs_vector_t,
					include_kind: EcsMatchDefault,
					exclude_kind: EcsMatchDefault,
				};
				init
			},
			tables: (*world).store.tables,
			index: 0 as libc::c_int,
			table: ecs_iter_table_t {
				columns: 0 as *mut int32_t,
				table: 0 as *mut ecs_table_t,
				data: 0 as *mut ecs_data_t,
				components: 0 as *mut ecs_entity_t,
				types: 0 as *mut ecs_type_t,
				references: 0 as *mut ecs_ref_t,
			},
		};
		init
	};
	return {
		let mut init = ecs_iter_t {
			world: world,
			system: 0,
			table: 0 as *mut ecs_iter_table_t,
			query: 0 as *mut ecs_query_t,
			table_count: 0,
			inactive_table_count: 0,
			column_count: 0,
			table_columns: 0 as *mut libc::c_void,
			entities: 0 as *mut ecs_entity_t,
			param: 0 as *mut libc::c_void,
			delta_time: 0.,
			delta_system_time: 0.,
			world_time: 0.,
			frame_offset: 0,
			table_offset: 0,
			offset: 0,
			count: 0,
			total_count: 0,
			triggered_by: 0 as *mut ecs_entities_t,
			interrupted_by: 0,
			iter: C2RustUnnamed { filter: iter },
		};
		init
	};
}
/* * Iterate tables matched by filter.
 * This operation progresses the filter iterator to the next table. The
 * iterator must have been initialized with `ecs_filter_iter`. This operation
 * must be invoked at least once before interpreting the contents of the
 * iterator.
 *
 * @param it The iterator
 * @return True if more data is available, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_filter_next(mut it: *mut ecs_iter_t) -> bool {
	let mut iter: *mut ecs_filter_iter_t = &mut (*it).iter.filter;
	let mut tables: *mut ecs_sparse_t = (*iter).tables;
	let mut count: int32_t = ecs_sparse_count(tables);
	let mut i: int32_t = 0;
	i = (*iter).index;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		let mut data: *mut ecs_data_t = ecs_table_get_data(table);
		if !data.is_null() {
			if ecs_table_match_filter((*it).world, table, &mut (*iter).filter) {
				(*iter).table.table = table;
				(*it).table = &mut (*iter).table;
				(*it).table_columns = (*data).columns as *mut libc::c_void;
				(*it).count = ecs_table_count(table);
				(*it).entities = _ecs_vector_first(
					(*data).entities,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				(*iter).index = i + 1 as libc::c_int;
				return 1 as libc::c_int != 0;
			}
		}
		i += 1
	}
	return 0 as libc::c_int != 0;
}
/* Add an extra element to the buffer */
unsafe extern "C" fn ecs_strbuf_grow(mut b: *mut ecs_strbuf_t) {
	/* Allocate new element */
	let mut e: *mut ecs_strbuf_element_embedded =
		ecs_os_api.malloc_.expect("non-null function pointer")(::std::mem::size_of::<
			ecs_strbuf_element_embedded,
		>() as libc::c_ulong as ecs_size_t) as *mut ecs_strbuf_element_embedded;
	(*b).size += (*(*b).current).pos;
	(*(*b).current).next = e as *mut ecs_strbuf_element;
	(*b).current = e as *mut ecs_strbuf_element;
	(*b).elementCount += 1;
	(*e).super_0.buffer_embedded = 1 as libc::c_int != 0;
	(*e).super_0.buf = (*e).buf.as_mut_ptr();
	(*e).super_0.pos = 0 as libc::c_int;
	(*e).super_0.next = 0 as *mut ecs_strbuf_element;
}
/* Add an extra dynamic element */
unsafe extern "C" fn ecs_strbuf_grow_str(
	mut b: *mut ecs_strbuf_t,
	mut str: *mut libc::c_char,
	mut alloc_str: *mut libc::c_char,
	mut size: int32_t,
) {
	/* Allocate new element */
	let mut e: *mut ecs_strbuf_element_str =
		ecs_os_api.malloc_.expect("non-null function pointer")(::std::mem::size_of::<
			ecs_strbuf_element_str,
		>() as libc::c_ulong as ecs_size_t) as *mut ecs_strbuf_element_str;
	(*b).size += (*(*b).current).pos;
	(*(*b).current).next = e as *mut ecs_strbuf_element;
	(*b).current = e as *mut ecs_strbuf_element;
	(*b).elementCount += 1;
	(*e).super_0.buffer_embedded = 0 as libc::c_int != 0;
	(*e).super_0.pos = if size != 0 {
		size
	} else {
		strlen(str) as ecs_size_t
	};
	(*e).super_0.next = 0 as *mut ecs_strbuf_element;
	(*e).super_0.buf = str;
	(*e).alloc_str = alloc_str;
}
unsafe extern "C" fn ecs_strbuf_ptr(mut b: *mut ecs_strbuf_t) -> *mut libc::c_char {
	if !(*b).buf.is_null() {
		return &mut *(*b).buf.offset((*(*b).current).pos as isize) as *mut libc::c_char;
	} else {
		return &mut *(*(*b).current).buf.offset((*(*b).current).pos as isize) as *mut libc::c_char;
	};
}
/* Compute the amount of space left in the current element */
unsafe extern "C" fn ecs_strbuf_memLeftInCurrentElement(mut b: *mut ecs_strbuf_t) -> int32_t {
	if (*(*b).current).buffer_embedded {
		return 511 as libc::c_int - (*(*b).current).pos;
	} else {
		return 0 as libc::c_int;
	};
}
/* Compute the amount of space left */
unsafe extern "C" fn ecs_strbuf_memLeft(mut b: *mut ecs_strbuf_t) -> int32_t {
	if (*b).max != 0 {
		return (*b).max - (*b).size - (*(*b).current).pos;
	} else {
		return 2147483647 as libc::c_int;
	};
}
unsafe extern "C" fn ecs_strbuf_init(mut b: *mut ecs_strbuf_t) {
	/* Initialize buffer structure only once */
	if (*b).elementCount == 0 {
		(*b).size = 0 as libc::c_int;
		(*b).firstElement.super_0.next = 0 as *mut ecs_strbuf_element;
		(*b).firstElement.super_0.pos = 0 as libc::c_int;
		(*b).firstElement.super_0.buffer_embedded = 1 as libc::c_int != 0;
		(*b).firstElement.super_0.buf = (*b).firstElement.buf.as_mut_ptr();
		(*b).elementCount += 1;
		(*b).current =
			&mut (*b).firstElement as *mut ecs_strbuf_element_embedded as *mut ecs_strbuf_element
	};
}
/* Quick custom function to copy a maxium number of characters and
 * simultaneously determine length of source string. */
unsafe extern "C" fn fast_strncpy(
	mut dst: *mut libc::c_char,
	mut src: *const libc::c_char,
	mut n_cpy: libc::c_int,
	mut n: libc::c_int,
) -> int32_t {
	let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
	let mut orig: *const libc::c_char = src;
	let mut ch: libc::c_char = 0;
	ptr = src;
	while (ptr.wrapping_offset_from(orig) as libc::c_long) < n as libc::c_long && {
		ch = *ptr;
		(ch as libc::c_int) != 0
	} {
		if (ptr.wrapping_offset_from(orig) as libc::c_long) < n_cpy as libc::c_long {
			*dst = ch;
			dst = dst.offset(1)
		}
		ptr = ptr.offset(1)
	}
	return ptr.wrapping_offset_from(orig) as libc::c_long as int32_t;
}
/* Append a format string to a buffer */
unsafe extern "C" fn ecs_strbuf_vappend_intern(
	mut b: *mut ecs_strbuf_t,
	mut str: *const libc::c_char,
	mut args: ::std::ffi::VaList,
) -> bool {
	let mut result: bool = 1 as libc::c_int != 0;
	let mut arg_cpy: ::std::ffi::VaListImpl;
	if str.is_null() {
		return result;
	}
	ecs_strbuf_init(b);
	let mut memLeftInElement: int32_t = ecs_strbuf_memLeftInCurrentElement(b);
	let mut memLeft: int32_t = ecs_strbuf_memLeft(b);
	if memLeft == 0 {
		return 0 as libc::c_int != 0;
	}
	/* Compute the memory required to add the string to the buffer. If user
	 * provided buffer, use space left in buffer, otherwise use space left in
	 * current element. */
	let mut max_copy: int32_t = if !(*b).buf.is_null() {
		memLeft
	} else {
		memLeftInElement
	};
	let mut memRequired: int32_t = 0;
	arg_cpy = args.clone();
	memRequired = vsnprintf(
		ecs_strbuf_ptr(b),
		(max_copy + 1 as libc::c_int) as size_t,
		str,
		args.as_va_list(),
	);
	if memRequired <= memLeftInElement {
		/* Element was large enough to fit string */
		(*(*b).current).pos += memRequired
	} else if memRequired - memLeftInElement < memLeft {
		/* If string is a format string, a new buffer of size memRequired is
		 * needed to re-evaluate the format string and only use the part that
		 * wasn't already copied to the previous element */
		if memRequired <= 511 as libc::c_int {
			/* Resulting string fits in standard-size buffer. Note that the
			 * entire string needs to fit, not just the remainder, as the
			 * format string cannot be partially evaluated */
			ecs_strbuf_grow(b);
			/* Copy entire string to new buffer */
			vsprintf(ecs_strbuf_ptr(b), str, arg_cpy.as_va_list());
			/* Ignore the part of the string that was copied into the
			 * previous buffer. The string copied into the new buffer could
			 * be memmoved so that only the remainder is left, but that is
			 * most likely more expensive than just keeping the entire
			 * string. */
			/* Update position in buffer */
			(*(*b).current).pos += memRequired
		} else {
			/* Resulting string does not fit in standard-size buffer.
			 * Allocate a new buffer that can hold the entire string. */
			let mut dst: *mut libc::c_char = ecs_os_api.malloc_.expect("non-null function pointer")(
				memRequired + 1 as libc::c_int,
			) as *mut libc::c_char;
			vsprintf(dst, str, arg_cpy.as_va_list());
			ecs_strbuf_grow_str(b, dst, dst, memRequired);
		}
	} else {
		/* Buffer max has been reached */
		result = 0 as libc::c_int != 0
	}
	return result;
}
unsafe extern "C" fn ecs_strbuf_append_intern(
	mut b: *mut ecs_strbuf_t,
	mut str: *const libc::c_char,
	mut n: libc::c_int,
) -> bool {
	let mut result: bool = 1 as libc::c_int != 0;
	if str.is_null() {
		return result;
	}
	ecs_strbuf_init(b);
	let mut memLeftInElement: int32_t = ecs_strbuf_memLeftInCurrentElement(b);
	let mut memLeft: int32_t = ecs_strbuf_memLeft(b);
	if memLeft == 0 {
		return 0 as libc::c_int != 0;
	}
	/* Compute the memory required to add the string to the buffer. If user
	 * provided buffer, use space left in buffer, otherwise use space left in
	 * current element. */
	let mut max_copy: int32_t = if !(*b).buf.is_null() {
		memLeft
	} else {
		memLeftInElement
	};
	let mut memRequired: int32_t = 0;
	if n < 0 as libc::c_int {
		n = 2147483647 as libc::c_int
	}
	memRequired = fast_strncpy(ecs_strbuf_ptr(b), str, max_copy, n);
	if memRequired <= memLeftInElement {
		/* Element was large enough to fit string */
		(*(*b).current).pos += memRequired
	} else if memRequired - memLeftInElement < memLeft {
		/* Element was not large enough, but buffer still has space */
		(*(*b).current).pos += memLeftInElement;
		memRequired -= memLeftInElement;
		/* Current element was too small, copy remainder into new element */
		if memRequired < 511 as libc::c_int {
			/* A standard-size buffer is large enough for the new string */
			ecs_strbuf_grow(b);
			/* Copy the remainder to the new buffer */
			if n != 0 {
				/* If a max number of characters to write is set, only a
				 * subset of the string should be copied to the buffer */
				strncpy(
					ecs_strbuf_ptr(b),
					str.offset(memLeftInElement as isize),
					memRequired as size_t,
				);
			} else {
				strcpy(ecs_strbuf_ptr(b), str.offset(memLeftInElement as isize));
			}
			/* Update to number of characters copied to new buffer */
			(*(*b).current).pos += memRequired
		} else {
			let mut remainder: *mut libc::c_char =
				ecs_os_api.strdup_.expect("non-null function pointer")(
					str.offset(memLeftInElement as isize),
				);
			ecs_strbuf_grow_str(b, remainder, remainder, memRequired);
		}
	} else {
		/* Buffer max has been reached */
		result = 0 as libc::c_int != 0
	}
	return result;
}
/* Append format string with argument list to a buffer.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_vappend(
	mut b: *mut ecs_strbuf_t,
	mut fmt: *const libc::c_char,
	mut args: ::std::ffi::VaList,
) -> bool {
	let mut result: bool = ecs_strbuf_vappend_intern(b, fmt, args.as_va_list());
	return result;
}
/* Append format string to a buffer.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_append(
	mut b: *mut ecs_strbuf_t,
	mut fmt: *const libc::c_char,
	mut args: ...
) -> bool {
	let mut args_0: ::std::ffi::VaListImpl;
	args_0 = args.clone();
	let mut result: bool = ecs_strbuf_vappend_intern(b, fmt, args_0.as_va_list());
	return result;
}
/* Append n characters to buffer.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_appendstrn(
	mut b: *mut ecs_strbuf_t,
	mut str: *const libc::c_char,
	mut len: int32_t,
) -> bool {
	return ecs_strbuf_append_intern(b, str, len);
}
/* Append string to buffer, transfer ownership to buffer.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_appendstr_zerocpy(
	mut b: *mut ecs_strbuf_t,
	mut str: *mut libc::c_char,
) -> bool {
	ecs_strbuf_init(b);
	ecs_strbuf_grow_str(b, str, str, 0 as libc::c_int);
	return 1 as libc::c_int != 0;
}
/* Append string to buffer, do not free/modify string.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_appendstr_zerocpy_const(
	mut b: *mut ecs_strbuf_t,
	mut str: *const libc::c_char,
) -> bool {
	/* Removes const modifier, but logic prevents changing / delete string */
	ecs_strbuf_init(b);
	ecs_strbuf_grow_str(
		b,
		str as *mut libc::c_char,
		0 as *mut libc::c_char,
		0 as libc::c_int,
	);
	return 1 as libc::c_int != 0;
}
/* Append string to buffer.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_appendstr(
	mut b: *mut ecs_strbuf_t,
	mut str: *const libc::c_char,
) -> bool {
	return ecs_strbuf_append_intern(b, str, -(1 as libc::c_int));
}
/* Append source buffer to destination buffer.
 * Returns false when max is reached, true when there is still space */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_mergebuff(
	mut dst_buffer: *mut ecs_strbuf_t,
	mut src_buffer: *mut ecs_strbuf_t,
) -> bool {
	if (*src_buffer).elementCount != 0 {
		if !(*src_buffer).buf.is_null() {
			return ecs_strbuf_appendstr(dst_buffer, (*src_buffer).buf);
		} else {
			let mut e: *mut ecs_strbuf_element = &mut (*src_buffer).firstElement
				as *mut ecs_strbuf_element_embedded
				as *mut ecs_strbuf_element;
			/* Copy first element as it is inlined in the src buffer */
			ecs_strbuf_appendstrn(dst_buffer, (*e).buf, (*e).pos);
			loop {
				e = (*e).next;
				if e.is_null() {
					break;
				}
				(*(*dst_buffer).current).next = ecs_os_api
					.malloc_
					.expect("non-null function pointer")(
					::std::mem::size_of::<ecs_strbuf_element>() as libc::c_ulong as ecs_size_t,
				) as *mut ecs_strbuf_element;
				*(*(*dst_buffer).current).next = *e
			}
		}
		*src_buffer = {
			let mut init = ecs_strbuf_t {
				buf: 0 as *mut libc::c_char,
				max: 0,
				size: 0,
				elementCount: 0,
				firstElement: ecs_strbuf_element_embedded {
					super_0: ecs_strbuf_element {
						buffer_embedded: false,
						pos: 0,
						buf: 0 as *mut libc::c_char,
						next: 0 as *mut ecs_strbuf_element,
					},
					buf: [0; 512],
				},
				current: 0 as *mut ecs_strbuf_element,
				list_stack: [ecs_strbuf_list_elem {
					count: 0,
					separator: 0 as *const libc::c_char,
				}; 32],
				list_sp: 0,
			};
			init
		}
	}
	return 1 as libc::c_int != 0;
}
/* Return result string (also resets buffer) */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_get(mut b: *mut ecs_strbuf_t) -> *mut libc::c_char {
	let mut result: *mut libc::c_char = 0 as *mut libc::c_char;
	if (*b).elementCount != 0 {
		if !(*b).buf.is_null() {
			result = ecs_os_api.strdup_.expect("non-null function pointer")((*b).buf)
		} else {
			let mut next: *mut libc::c_void = 0 as *mut libc::c_void;
			let mut len: int32_t = (*b).size + (*(*b).current).pos + 1 as libc::c_int;
			let mut e: *mut ecs_strbuf_element = &mut (*b).firstElement
				as *mut ecs_strbuf_element_embedded
				as *mut ecs_strbuf_element;
			result =
				ecs_os_api.malloc_.expect("non-null function pointer")(len) as *mut libc::c_char;
			let mut ptr: *mut libc::c_char = result;
			loop {
				memcpy(
					ptr as *mut libc::c_void,
					(*e).buf as *const libc::c_void,
					(*e).pos as size_t,
				);
				ptr = ptr.offset((*e).pos as isize);
				next = (*e).next as *mut libc::c_void;
				if e != &mut (*b).firstElement.super_0 as *mut ecs_strbuf_element {
					if !(*e).buffer_embedded {
						ecs_os_api.free_.expect("non-null function pointer")(
							(*(e as *mut ecs_strbuf_element_str)).alloc_str as *mut libc::c_void,
						);
					}
					ecs_os_api.free_.expect("non-null function pointer")(e as *mut libc::c_void);
				}
				e = next as *mut ecs_strbuf_element;
				if e.is_null() {
					break;
				}
			}
			*result.offset((len - 1 as libc::c_int) as isize) = '\u{0}' as i32 as libc::c_char
		}
	} else {
		result = 0 as *mut libc::c_char
	}
	(*b).elementCount = 0 as libc::c_int;
	return result;
}
/* Reset buffer without returning a string */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_reset(mut b: *mut ecs_strbuf_t) {
	if (*b).elementCount != 0 && (*b).buf.is_null() {
		let mut next: *mut libc::c_void = 0 as *mut libc::c_void;
		let mut e: *mut ecs_strbuf_element =
			&mut (*b).firstElement as *mut ecs_strbuf_element_embedded as *mut ecs_strbuf_element;
		loop {
			next = (*e).next as *mut libc::c_void;
			if e != &mut (*b).firstElement as *mut ecs_strbuf_element_embedded
				as *mut ecs_strbuf_element
			{
				ecs_os_api.free_.expect("non-null function pointer")(e as *mut libc::c_void);
			}
			e = next as *mut ecs_strbuf_element;
			if e.is_null() {
				break;
			}
		}
	}
	*b = {
		let mut init = ecs_strbuf_t {
			buf: 0 as *mut libc::c_char,
			max: 0,
			size: 0,
			elementCount: 0,
			firstElement: ecs_strbuf_element_embedded {
				super_0: ecs_strbuf_element {
					buffer_embedded: false,
					pos: 0,
					buf: 0 as *mut libc::c_char,
					next: 0 as *mut ecs_strbuf_element,
				},
				buf: [0; 512],
			},
			current: 0 as *mut ecs_strbuf_element,
			list_stack: [ecs_strbuf_list_elem {
				count: 0,
				separator: 0 as *const libc::c_char,
			}; 32],
			list_sp: 0,
		};
		init
	};
}
/* Push a list */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_list_push(
	mut buffer: *mut ecs_strbuf_t,
	mut list_open: *const libc::c_char,
	mut separator: *const libc::c_char,
) {
	(*buffer).list_sp += 1;
	(*buffer).list_stack[(*buffer).list_sp as usize].count = 0 as libc::c_int;
	(*buffer).list_stack[(*buffer).list_sp as usize].separator = separator;
	if !list_open.is_null() {
		ecs_strbuf_appendstr(buffer, list_open);
	};
}
/* Pop a new list */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_list_pop(
	mut buffer: *mut ecs_strbuf_t,
	mut list_close: *const libc::c_char,
) {
	(*buffer).list_sp -= 1;
	if !list_close.is_null() {
		ecs_strbuf_appendstr(buffer, list_close);
	};
}
/* Insert a new element in list */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_list_next(mut buffer: *mut ecs_strbuf_t) {
	let mut list_sp: int32_t = (*buffer).list_sp;
	if (*buffer).list_stack[list_sp as usize].count != 0 as libc::c_int {
		ecs_strbuf_appendstr(buffer, (*buffer).list_stack[list_sp as usize].separator);
	}
	(*buffer).list_stack[list_sp as usize].count += 1;
}
/* Append formatted string as a new element in list */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_list_append(
	mut buffer: *mut ecs_strbuf_t,
	mut fmt: *const libc::c_char,
	mut args: ...
) -> bool {
	ecs_strbuf_list_next(buffer);
	let mut args_0: ::std::ffi::VaListImpl;
	args_0 = args.clone();
	let mut result: bool = ecs_strbuf_vappend_intern(buffer, fmt, args_0.as_va_list());
	return result;
}
/* Append string as a new element in list */
#[no_mangle]
pub unsafe extern "C" fn ecs_strbuf_list_appendstr(
	mut buffer: *mut ecs_strbuf_t,
	mut str: *const libc::c_char,
) -> bool {
	ecs_strbuf_list_next(buffer);
	return ecs_strbuf_appendstr(buffer, str);
}
/* * Skip spaces when parsing signature */
unsafe extern "C" fn skip_space(mut ptr: *const libc::c_char) -> *const libc::c_char {
	while *(*__ctype_b_loc()).offset(*ptr as libc::c_int as isize) as libc::c_int
		& _ISspace as libc::c_int as libc::c_ushort as libc::c_int
		!= 0
	{
		ptr = ptr.offset(1)
	}
	return ptr;
}
#[no_mangle]
pub unsafe extern "C" fn entity_compare(
	mut ptr1: *const libc::c_void,
	mut ptr2: *const libc::c_void,
) -> libc::c_int {
	let mut e1: ecs_entity_t = *(ptr1 as *mut ecs_entity_t);
	let mut e2: ecs_entity_t = *(ptr2 as *mut ecs_entity_t);
	return (e1 > e2) as libc::c_int - (e1 < e2) as libc::c_int;
}
unsafe extern "C" fn vec_add_entity(mut vec: *mut *mut ecs_vector_t, mut entity: ecs_entity_t) {
	let mut e: *mut ecs_entity_t = _ecs_vector_add(
		vec,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	*e = entity;
	/* Keep array sorted so that we can use it in type compare operations */
	_ecs_vector_sort(
		*vec,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		Some(
			entity_compare
				as unsafe extern "C" fn(
					_: *const libc::c_void,
					_: *const libc::c_void,
				) -> libc::c_int,
		),
	);
}
/* -- Private functions -- */
unsafe extern "C" fn valid_identifier_char(mut ch: libc::c_char) -> bool {
	if ch as libc::c_int != 0
		&& (*(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
			& _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
			!= 0 || *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int
			& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
			!= 0 || ch as libc::c_int == '_' as i32
			|| ch as libc::c_int == '.' as i32
			|| ch as libc::c_int == '$' as i32
			|| ch as libc::c_int == '*' as i32)
	{
		return 1 as libc::c_int != 0;
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn valid_operator_char(mut ch: libc::c_char) -> bool {
	if ch as libc::c_int == '?' as i32 || ch as libc::c_int == '!' as i32 {
		return 1 as libc::c_int != 0;
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn parse_identifier(
	mut name: *const libc::c_char,
	mut sig: *const libc::c_char,
	mut column: int64_t,
	mut ptr: *const libc::c_char,
	mut token_out: *mut libc::c_char,
) -> *const libc::c_char {
	ptr = skip_space(ptr);
	let mut tptr: *mut libc::c_char = token_out;
	let mut ch: libc::c_char = *ptr.offset(0 as libc::c_int as isize);
	if !valid_identifier_char(ch) {
		_ecs_parser_error(
			name,
			sig,
			column,
			b"invalid identifier\x00" as *const u8 as *const libc::c_char,
			ptr,
		);
		abort();
	}
	loop {
		ch = *ptr;
		if !(ch != 0) {
			break;
		}
		if !valid_identifier_char(ch) {
			break;
		}
		*tptr.offset(0 as libc::c_int as isize) = ch;
		tptr = tptr.offset(1);
		ptr = ptr.offset(1)
	}
	*tptr.offset(0 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
	return skip_space(ptr);
}
unsafe extern "C" fn parse_role(
	mut name: *const libc::c_char,
	mut sig: *const libc::c_char,
	mut column: int64_t,
	mut token: *const libc::c_char,
) -> ecs_entity_t {
	if strcmp(token, b"CHILDOF\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"INSTANCEOF\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"TRAIT\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"AND\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7b as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"OR\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7a as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"XOR\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x79 as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"NOT\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x78 as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"SWITCH\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"CASE\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else if strcmp(token, b"OWNED\x00" as *const u8 as *const libc::c_char) == 0 {
		return (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x75 as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
	} else {
		_ecs_parser_error(
			name,
			sig,
			column,
			b"invalid role \'%s\'\x00" as *const u8 as *const libc::c_char,
			token,
		);
		abort();
	};
}
unsafe extern "C" fn parse_source(mut token: *const libc::c_char) -> ecs_sig_from_kind_t {
	if strcmp(token, b"PARENT\x00" as *const u8 as *const libc::c_char) == 0 {
		return EcsFromParent;
	} else if strcmp(token, b"SYSTEM\x00" as *const u8 as *const libc::c_char) == 0 {
		return EcsFromSystem;
	} else if strcmp(token, b"ANY\x00" as *const u8 as *const libc::c_char) == 0 {
		return EcsFromAny;
	} else if strcmp(token, b"OWNED\x00" as *const u8 as *const libc::c_char) == 0 {
		return EcsFromOwned;
	} else if strcmp(token, b"SHARED\x00" as *const u8 as *const libc::c_char) == 0 {
		return EcsFromShared;
	} else if strcmp(token, b"CASCADE\x00" as *const u8 as *const libc::c_char) == 0 {
		return EcsCascade;
	} else {
		return EcsFromEntity;
	};
}
unsafe extern "C" fn parse_operator(mut ch: libc::c_char) -> ecs_sig_oper_kind_t {
	if ch as libc::c_int == '?' as i32 {
		return EcsOperOptional;
	} else if ch as libc::c_int == '!' as i32 {
		return EcsOperNot;
	} else {
		_ecs_abort(
			12 as libc::c_int,
			0 as *const libc::c_char,
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			23717 as libc::c_int,
		);
		abort();
	};
}
unsafe extern "C" fn parse_annotation(
	mut name: *const libc::c_char,
	mut sig: *const libc::c_char,
	mut column: int64_t,
	mut ptr: *const libc::c_char,
	mut inout_kind_out: *mut ecs_sig_inout_kind_t,
) -> *const libc::c_char {
	let mut token: [libc::c_char; 256] = [0; 256];
	ptr = parse_identifier(name, sig, column, ptr, token.as_mut_ptr());
	if ptr.is_null() {
		return 0 as *const libc::c_char;
	}
	if strcmp(
		token.as_mut_ptr(),
		b"in\x00" as *const u8 as *const libc::c_char,
	) == 0
	{
		*inout_kind_out = EcsIn
	} else if strcmp(
		token.as_mut_ptr(),
		b"out\x00" as *const u8 as *const libc::c_char,
	) == 0
	{
		*inout_kind_out = EcsOut
	} else if strcmp(
		token.as_mut_ptr(),
		b"inout\x00" as *const u8 as *const libc::c_char,
	) == 0
	{
		*inout_kind_out = EcsInOut
	}
	ptr = skip_space(ptr);
	if *ptr.offset(0 as libc::c_int as isize) as libc::c_int != ']' as i32 {
		_ecs_parser_error(
			name,
			sig,
			column,
			b"expected ]\x00" as *const u8 as *const libc::c_char,
		);
		abort();
	}
	return ptr.offset(1 as libc::c_int as isize);
}
#[no_mangle]
pub unsafe extern "C" fn parse_element(
	mut name: *const libc::c_char,
	mut sig: *const libc::c_char,
	mut elem_out: *mut sig_element_t,
) -> *const libc::c_char {
	let mut current_block: u64;
	let mut explicit_inout: bool = 0 as libc::c_int != 0;
	let mut ptr: *const libc::c_char = sig;
	let mut token: [libc::c_char; 256] = [
		0 as libc::c_int as libc::c_char,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
	];
	let mut elem: sig_element_t = {
		let mut init = sig_element_t {
			role: 0,
			inout_kind: EcsInOut,
			from_kind: EcsFromOwned,
			oper_kind: EcsOperAnd,
			trait_0: 0 as *mut libc::c_char,
			source: 0 as *mut libc::c_char,
			component: 0 as *mut libc::c_char,
			name: 0 as *mut libc::c_char,
		};
		init
	};
	ptr = skip_space(ptr);
	/* Inout specifiers always come first */
	if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == '[' as i32 {
		explicit_inout = 1 as libc::c_int != 0;
		ptr = parse_annotation(
			name,
			sig,
			ptr.wrapping_offset_from(sig) as libc::c_long,
			ptr.offset(1 as libc::c_int as isize),
			&mut elem.inout_kind,
		);
		if ptr.is_null() {
			return 0 as *const libc::c_char;
		}
		ptr = skip_space(ptr)
	}
	if valid_operator_char(*ptr.offset(0 as libc::c_int as isize)) {
		elem.oper_kind = parse_operator(*ptr.offset(0 as libc::c_int as isize));
		ptr = skip_space(ptr.offset(1 as libc::c_int as isize))
	}
	/* If next token is the start of an identifier, it could be either a type
	 * role, source or component identifier */
	if valid_identifier_char(*ptr.offset(0 as libc::c_int as isize)) {
		ptr = parse_identifier(
			name,
			sig,
			ptr.wrapping_offset_from(sig) as libc::c_long,
			ptr,
			token.as_mut_ptr(),
		);
		if ptr.is_null() {
			return 0 as *const libc::c_char;
		}
		/* If next token is the source token, this is an empty source */
		/* Is token a source identifier? */
		if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == ':' as i32 {
			ptr = ptr.offset(1);
			elem.from_kind = parse_source(token.as_mut_ptr());
			if elem.from_kind as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
				elem.source =
					ecs_os_api.strdup_.expect("non-null function pointer")(token.as_mut_ptr())
			}
			ptr = skip_space(ptr);
			if valid_identifier_char(*ptr.offset(0 as libc::c_int as isize)) {
				ptr = parse_identifier(
					name,
					sig,
					ptr.wrapping_offset_from(sig) as libc::c_long,
					ptr,
					token.as_mut_ptr(),
				);
				if ptr.is_null() {
					return 0 as *const libc::c_char;
				}
				/* Is the next token a role? */
				if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == '|' as i32
					&& *ptr.offset(1 as libc::c_int as isize) as libc::c_int != '|' as i32
				{
					ptr = ptr.offset(1);
					current_block = 6160498916146958962;
				} else if strncmp(
					ptr,
					b"FOR\x00" as *const u8 as *const libc::c_char,
					3 as libc::c_int as size_t,
				) == 0
				{
					elem.role = (1 as libc::c_int as uint64_t) << 63 as libc::c_int
						| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
					ptr = ptr.offset(3 as libc::c_int as isize);
					current_block = 6562002266951406060;
				} else {
					/* Is token a trait? (using shorthand notation) */
					/* If not, it's a component */
					current_block = 14333705311057761039;
				}
			} else {
				_ecs_parser_error(
					name,
					sig,
					ptr.wrapping_offset_from(sig) as libc::c_long,
					b"expected identifier after source\x00" as *const u8 as *const libc::c_char,
				);
				abort();
			}
		} else if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == '|' as i32
			&& *ptr.offset(1 as libc::c_int as isize) as libc::c_int != '|' as i32
		{
			ptr = ptr.offset(1);
			current_block = 6160498916146958962;
		} else if strncmp(
			ptr,
			b"FOR\x00" as *const u8 as *const libc::c_char,
			3 as libc::c_int as size_t,
		) == 0
		{
			elem.role = (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
			ptr = ptr.offset(3 as libc::c_int as isize);
			current_block = 6562002266951406060;
		} else {
			/* Is token a type role? */
			/* Is token a trait? (using shorthand notation) */
			/* If it is neither, the next token must be a component */
			current_block = 14333705311057761039;
		}
		match current_block {
			14333705311057761039 => {}
			_ => {
				match current_block {
					6160498916146958962 => {
						elem.role = parse_role(
							name,
							sig,
							ptr.wrapping_offset_from(sig) as libc::c_long,
							token.as_mut_ptr(),
						);
						if elem.role == 0 {
							return 0 as *const libc::c_char;
						}
						ptr = skip_space(ptr);
						/* If next token is the source token, this is an empty source */
						if valid_identifier_char(*ptr.offset(0 as libc::c_int as isize)) {
							ptr = parse_identifier(
								name,
								sig,
								ptr.wrapping_offset_from(sig) as libc::c_long,
								ptr,
								token.as_mut_ptr(),
							);
							if ptr.is_null() {
								return 0 as *const libc::c_char;
							}
							/* Is token a trait? */
							if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == '>' as i32 {
								ptr = ptr.offset(1);
								current_block = 6562002266951406060;
							} else {
								/* If not, it's a component */
								current_block = 14333705311057761039;
							}
						} else {
							_ecs_parser_error(
								name,
								sig,
								ptr.wrapping_offset_from(sig) as libc::c_long,
								b"expected identifier after role\x00" as *const u8
									as *const libc::c_char,
							);
							abort();
						}
					}
					_ => {}
				}
				match current_block {
					14333705311057761039 => {}
					_ => {
						elem.trait_0 = ecs_os_api.strdup_.expect("non-null function pointer")(
							token.as_mut_ptr(),
						);
						ptr = skip_space(ptr);
						if valid_identifier_char(*ptr.offset(0 as libc::c_int as isize)) {
							ptr = parse_identifier(
								name,
								sig,
								ptr.wrapping_offset_from(sig) as libc::c_long,
								ptr,
								token.as_mut_ptr(),
							);
							if ptr.is_null() {
								return 0 as *const libc::c_char;
							}
						} else {
							_ecs_parser_error(
								name,
								sig,
								ptr.wrapping_offset_from(sig) as libc::c_long,
								b"expected identifier after trait\x00" as *const u8
									as *const libc::c_char,
							);
							abort();
						}
					}
				}
			}
		}
	} else if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == ':' as i32 {
		elem.from_kind = EcsFromEmpty;
		ptr = skip_space(ptr.offset(1 as libc::c_int as isize));
		if valid_identifier_char(*ptr.offset(0 as libc::c_int as isize)) {
			ptr = parse_identifier(
				name,
				sig,
				ptr.wrapping_offset_from(sig) as libc::c_long,
				ptr,
				token.as_mut_ptr(),
			);
			if ptr.is_null() {
				return 0 as *const libc::c_char;
			}
		} else {
			_ecs_parser_error(
				name,
				sig,
				ptr.wrapping_offset_from(sig) as libc::c_long,
				b"expected identifier after source operator\x00" as *const u8
					as *const libc::c_char,
			);
			abort();
		}
	/* Nothing else expected here */
	} else {
		_ecs_parser_error(
			name,
			sig,
			ptr.wrapping_offset_from(sig) as libc::c_long,
			b"unexpected character \'%c\'\x00" as *const u8 as *const libc::c_char,
			*ptr.offset(0 as libc::c_int as isize) as libc::c_int,
		);
		abort();
	}
	/* Can only be a component */
	elem.component = ecs_os_api.strdup_.expect("non-null function pointer")(token.as_mut_ptr());
	ptr = skip_space(ptr);
	if valid_identifier_char(*ptr.offset(0 as libc::c_int as isize)) {
		ptr = parse_identifier(
			name,
			sig,
			ptr.wrapping_offset_from(sig) as libc::c_long,
			ptr,
			token.as_mut_ptr(),
		);
		if ptr.is_null() {
			return 0 as *const libc::c_char;
		}
		/* Can only be a name */
		elem.name = ecs_os_api.strdup_.expect("non-null function pointer")(token.as_mut_ptr());
		ptr = skip_space(ptr)
	}
	/* If nothing else, parsing of this element is done */
	if *ptr.offset(0 as libc::c_int as isize) as libc::c_int != ',' as i32
		&& strncmp(
			ptr,
			b"||\x00" as *const u8 as *const libc::c_char,
			2 as libc::c_int as size_t,
		) != 0 && *ptr.offset(0 as libc::c_int as isize) as libc::c_int != 0
	{
		_ecs_parser_error(
			name,
			sig,
			ptr.wrapping_offset_from(sig) as libc::c_long,
			b"expected end of expression or next element\x00" as *const u8 as *const libc::c_char,
		);
		abort();
	}
	if strcmp(elem.component, b"0\x00" as *const u8 as *const libc::c_char) == 0 {
		if *ptr.offset(0 as libc::c_int as isize) != 0 {
			_ecs_parser_error(
				name,
				sig,
				ptr.wrapping_offset_from(sig) as libc::c_long,
				b"unexpected element after 0\x00" as *const u8 as *const libc::c_char,
			);
			abort();
		}
		if elem.from_kind as libc::c_uint != EcsFromOwned as libc::c_int as libc::c_uint {
			_ecs_parser_error(
				name,
				sig,
				ptr.wrapping_offset_from(sig) as libc::c_long,
				b"invalid source modifier for 0\x00" as *const u8 as *const libc::c_char,
			);
			abort();
		}
	}
	if !explicit_inout {
		if elem.from_kind as libc::c_uint != EcsFromOwned as libc::c_int as libc::c_uint {
			elem.inout_kind = EcsIn
		}
	}
	*elem_out = elem;
	return ptr;
}
/* Utility that print a descriptive error string*/
//void ecs_print_error_string(const char *error_description, const char* signature, const char* system_id, const char* component_id);
//void ecs_print_error_string(const char* signature, const char *system_id, const char *error_description, const char *component_id);
/* Utility that parses system signature */
#[no_mangle]
pub unsafe extern "C" fn ecs_parse_expr(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
	mut sig: *const libc::c_char,
	mut action: ecs_parse_action_t,
	mut ctx: *mut libc::c_void,
) -> libc::c_int {
	let mut elem: sig_element_t = sig_element_t {
		role: 0,
		inout_kind: EcsInOut,
		from_kind: EcsFromAny,
		oper_kind: EcsOperAnd,
		trait_0: 0 as *mut libc::c_char,
		source: 0 as *mut libc::c_char,
		component: 0 as *mut libc::c_char,
		name: 0 as *mut libc::c_char,
	};
	let mut is_or: bool = 0 as libc::c_int != 0;
	let mut ptr: *const libc::c_char = sig;
	loop {
		ptr = parse_element(name, ptr, &mut elem);
		if ptr.is_null() {
			break;
		}
		if is_or {
			elem.oper_kind = EcsOperOr
		}
		if action.expect("non-null function pointer")(
			world,
			name,
			sig,
			ptr.wrapping_offset_from(sig) as libc::c_long,
			elem.from_kind,
			elem.oper_kind,
			elem.inout_kind,
			elem.role,
			elem.component,
			elem.source,
			elem.trait_0,
			elem.name,
			ctx,
		) != 0
		{
			if name.is_null() {
				return -(1 as libc::c_int);
			}
			_ecs_abort(
				6 as libc::c_int,
				sig,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				24014 as libc::c_int,
			);
			abort();
		}
		ecs_os_api.free_.expect("non-null function pointer")(elem.component as *mut libc::c_void);
		ecs_os_api.free_.expect("non-null function pointer")(elem.source as *mut libc::c_void);
		ecs_os_api.free_.expect("non-null function pointer")(elem.trait_0 as *mut libc::c_void);
		ecs_os_api.free_.expect("non-null function pointer")(elem.name as *mut libc::c_void);
		is_or = 0 as libc::c_int != 0;
		if strncmp(
			ptr,
			b"||\x00" as *const u8 as *const libc::c_char,
			2 as libc::c_int as libc::c_ulong,
		) == 0
		{
			is_or = 1 as libc::c_int != 0;
			if elem.from_kind as libc::c_uint == EcsFromEmpty as libc::c_int as libc::c_uint {
				_ecs_parser_error(
					name,
					sig,
					ptr.wrapping_offset_from(sig) as libc::c_long,
					b"invalid empty source in or expression\x00" as *const u8
						as *const libc::c_char,
				);
				abort();
			}
			if elem.from_kind as libc::c_uint == EcsFromSystem as libc::c_int as libc::c_uint {
				_ecs_parser_error(
					name,
					sig,
					ptr.wrapping_offset_from(sig) as libc::c_long,
					b"invalid system source in or expression\x00" as *const u8
						as *const libc::c_char,
				);
				abort();
			}
		}
		if *ptr.offset(0 as libc::c_int as isize) != 0 {
			ptr = ptr.offset(1);
			if is_or {
				ptr = ptr.offset(1)
			}
		}
		ptr = skip_space(ptr);
		if *ptr.offset(0 as libc::c_int as isize) == 0 {
			break;
		}
	}
	if ptr.is_null() {
		if name.is_null() {
			return -(1 as libc::c_int);
		}
		_ecs_abort(
			6 as libc::c_int,
			sig,
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			24057 as libc::c_int,
		);
		abort();
	}
	return 0 as libc::c_int;
}
/* * Parse callback that adds component to the components array for a system */
#[no_mangle]
pub unsafe extern "C" fn ecs_parse_signature_action(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
	mut column: int64_t,
	mut from_kind: ecs_sig_from_kind_t,
	mut oper_kind: ecs_sig_oper_kind_t,
	mut inout_kind: ecs_sig_inout_kind_t,
	mut role: ecs_entity_t,
	mut entity_id: *const libc::c_char,
	mut source_id: *const libc::c_char,
	mut trait_id: *const libc::c_char,
	mut arg_name: *const libc::c_char,
	mut data: *mut libc::c_void,
) -> libc::c_int {
	let mut sig: *mut ecs_sig_t = data as *mut ecs_sig_t;
	let mut is_singleton: bool = 0 as libc::c_int != 0;
	if *entity_id.offset(0 as libc::c_int as isize) as libc::c_int == '$' as i32 {
		if from_kind as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
			_ecs_parser_error(
				name,
				expr,
				column,
				b"singleton component \'%s\' cannot have a source\x00" as *const u8
					as *const libc::c_char,
				entity_id,
			);
			abort();
		}
		from_kind = EcsFromEntity;
		is_singleton = 1 as libc::c_int != 0;
		entity_id = entity_id.offset(1)
	}
	/* Lookup component handle by string identifier */
	let mut source: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	let mut component: ecs_entity_t = ecs_lookup_path_w_sep(
		world,
		0 as libc::c_int as ecs_entity_t,
		entity_id,
		b".\x00" as *const u8 as *const libc::c_char,
		0 as *const libc::c_char,
	);
	if component == 0 {
		/* "0" is a valid expression used to indicate that a system matches no
		 * components */
		if strcmp(entity_id, b"0\x00" as *const u8 as *const libc::c_char) == 0 {
			/* No need to add 0 component to signature */
			return 0 as libc::c_int;
		} else {
			_ecs_parser_error(
				name,
				expr,
				column,
				b"unresolved component identifier \'%s\'\x00" as *const u8 as *const libc::c_char,
				entity_id,
			);
			abort();
		}
	}
	if is_singleton {
		source = component
	}
	/* Lookup trait handle by string identifier */
	if !trait_id.is_null() {
		let mut trait_0: ecs_entity_t = ecs_lookup_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			trait_id,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		if trait_0 == 0 {
			_ecs_parser_error(
				name,
				expr,
				column,
				b"unresolved trait identifier \'%s\'\x00" as *const u8 as *const libc::c_char,
				trait_id,
			);
			abort();
		} else {
			component =
				(trait_0 << 32 as libc::c_int).wrapping_add(component as uint32_t as libc::c_ulong)
		}
	}
	component |= role;
	if source == 0 && from_kind as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
		source = ecs_lookup_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			source_id,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		if source == 0 {
			_ecs_parser_error(
				name,
				expr,
				column,
				b"unresolved source identifier \'%s\'\x00" as *const u8 as *const libc::c_char,
				source_id,
			);
			abort();
		}
	}
	return ecs_sig_add(
		world, sig, from_kind, oper_kind, inout_kind, component, source, arg_name,
	);
}
/* * Parse signature. */
#[no_mangle]
pub unsafe extern "C" fn ecs_sig_init(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
	mut sig: *mut ecs_sig_t,
) {
	if !expr.is_null() && strlen(expr) as ecs_size_t != 0 {
		(*sig).expr = ecs_os_api.strdup_.expect("non-null function pointer")(expr)
	} else {
		(*sig).expr = ecs_os_api.strdup_.expect("non-null function pointer")(
			b"0\x00" as *const u8 as *const libc::c_char,
		)
	}
	ecs_parse_expr(
		world,
		name,
		(*sig).expr,
		Some(
			ecs_parse_signature_action
				as unsafe extern "C" fn(
					_: *mut ecs_world_t,
					_: *const libc::c_char,
					_: *const libc::c_char,
					_: int64_t,
					_: ecs_sig_from_kind_t,
					_: ecs_sig_oper_kind_t,
					_: ecs_sig_inout_kind_t,
					_: ecs_entity_t,
					_: *const libc::c_char,
					_: *const libc::c_char,
					_: *const libc::c_char,
					_: *const libc::c_char,
					_: *mut libc::c_void,
				) -> libc::c_int,
		),
		sig as *mut libc::c_void,
	);
}
/* * Release signature resources */
#[no_mangle]
pub unsafe extern "C" fn ecs_sig_deinit(mut sig: *mut ecs_sig_t) {
	let mut column_i: libc::c_int = 0;
	let mut column_count: libc::c_int = ecs_vector_count((*sig).columns);
	let mut column_array: *mut ecs_sig_column_t = _ecs_vector_first(
		(*sig).columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	column_i = 0 as libc::c_int;
	while column_i < column_count {
		let mut column: *mut ecs_sig_column_t =
			&mut *column_array.offset(column_i as isize) as *mut ecs_sig_column_t;
		if (*column).oper_kind as libc::c_uint == EcsOperOr as libc::c_int as libc::c_uint {
			ecs_vector_free((*column).is.type_0);
		}
		ecs_os_api.free_.expect("non-null function pointer")((*column).name as *mut libc::c_void);
		column_i += 1
	}
	ecs_vector_free((*sig).columns);
	ecs_os_api.free_.expect("non-null function pointer")((*sig).expr as *mut libc::c_void);
}
/* * Add column to signature. */
#[no_mangle]
pub unsafe extern "C" fn ecs_sig_add(
	mut world: *mut ecs_world_t,
	mut sig: *mut ecs_sig_t,
	mut from_kind: ecs_sig_from_kind_t,
	mut oper_kind: ecs_sig_oper_kind_t,
	mut inout_kind: ecs_sig_inout_kind_t,
	mut component: ecs_entity_t,
	mut source: ecs_entity_t,
	mut arg_name: *const libc::c_char,
) -> libc::c_int {
	let mut elem: *mut ecs_sig_column_t = 0 as *mut ecs_sig_column_t;
	/* If component has AND role, all components of specified type must match */
	if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7b as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		elem = _ecs_vector_add(
			&mut (*sig).columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		component &= 0xffffffff as libc::c_uint as uint64_t;
		let mut type_0: *const EcsType =
			ecs_get_w_entity(world, component, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
		if type_0.is_null() {
			_ecs_parser_error(
				(*sig).name,
				(*sig).expr,
				0 as libc::c_int as int64_t,
				b"AND flag can only be applied to types\x00" as *const u8 as *const libc::c_char,
			);
			abort();
		}
		(*elem).is.component = component;
		(*elem).from_kind = from_kind;
		(*elem).oper_kind = EcsOperAll;
		(*elem).inout_kind = inout_kind;
		(*elem).source = source
	} else if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7a as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		elem = _ecs_vector_add(
			&mut (*sig).columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		component &= 0xffffffff as libc::c_uint as uint64_t;
		let mut type_1: *const EcsType =
			ecs_get_w_entity(world, component, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
		if type_1.is_null() {
			_ecs_parser_error(
				(*sig).name,
				(*sig).expr,
				0 as libc::c_int as int64_t,
				b"OR flag can only be applied to types\x00" as *const u8 as *const libc::c_char,
			);
			abort();
		}
		(*elem).is.type_0 = _ecs_vector_copy(
			(*type_1).normalized,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		);
		(*elem).from_kind = from_kind;
		(*elem).oper_kind = EcsOperOr;
		(*elem).inout_kind = inout_kind;
		(*elem).source = source
	} else if oper_kind as libc::c_uint != EcsOperOr as libc::c_int as libc::c_uint {
		elem = _ecs_vector_add(
			&mut (*sig).columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		(*elem).from_kind = from_kind;
		(*elem).oper_kind = oper_kind;
		(*elem).inout_kind = inout_kind;
		(*elem).is.component = component;
		(*elem).source = source
	/* If component has OR role, add type as OR column */
	/* AND (default) and optional columns are stored the same way */
	/* OR columns store a type id instead of a single component */
	} else {
		elem = _ecs_vector_last(
			(*sig).columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		if (*elem).oper_kind as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint {
			let mut prev: ecs_entity_t = (*elem).is.component;
			(*elem).is.type_0 = 0 as *mut ecs_vector_t;
			vec_add_entity(&mut (*elem).is.type_0, prev);
			vec_add_entity(&mut (*elem).is.type_0, component);
		} else if (*elem).from_kind as libc::c_uint != from_kind as libc::c_uint {
			/* Cannot mix FromEntity and FromComponent in OR */
			_ecs_parser_error(
				(*sig).name,
				(*sig).expr,
				0 as libc::c_int as int64_t,
				b"cannot mix source kinds in || expression\x00" as *const u8 as *const libc::c_char,
			);
			abort();
		} else {
			if (*elem).oper_kind as libc::c_uint != EcsOperAnd as libc::c_int as libc::c_uint
				&& (*elem).oper_kind as libc::c_uint != EcsOperOr as libc::c_int as libc::c_uint
			{
				_ecs_parser_error(
					(*sig).name,
					(*sig).expr,
					0 as libc::c_int as int64_t,
					b"cannot mix operators in || expression\x00" as *const u8
						as *const libc::c_char,
				);
				abort();
			}
			vec_add_entity(&mut (*elem).is.type_0, component);
		}
		(*elem).from_kind = from_kind;
		(*elem).oper_kind = oper_kind
	}
	if !arg_name.is_null() {
		(*elem).name = ecs_os_api.strdup_.expect("non-null function pointer")(arg_name)
	} else {
		(*elem).name = 0 as *mut libc::c_char
	}
	return 0 as libc::c_int;
}
// //////////////////////////////////////////////////////////////////////////////
// // Signature API
// //////////////////////////////////////////////////////////////////////////////
/* Check if all non-table column constraints are met */
/* Check if system meets constraints of non-table columns */
#[no_mangle]
pub unsafe extern "C" fn ecs_sig_check_constraints(
	mut world: *mut ecs_world_t,
	mut sig: *mut ecs_sig_t,
) -> bool {
	let mut elem_i: libc::c_int = 0;
	let mut elem_count: libc::c_int = ecs_vector_count((*sig).columns);
	let mut elem_array: *mut ecs_sig_column_t = _ecs_vector_first(
		(*sig).columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	elem_i = 0 as libc::c_int;
	while elem_i < elem_count {
		let mut elem: *mut ecs_sig_column_t =
			&mut *elem_array.offset(elem_i as isize) as *mut ecs_sig_column_t;
		let mut from_kind: ecs_sig_from_kind_t = (*elem).from_kind;
		let mut oper_kind: ecs_sig_oper_kind_t = (*elem).oper_kind;
		if from_kind as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
			let mut type_0: ecs_type_t = ecs_get_type(world, (*elem).source);
			if ecs_type_has_entity(world, type_0, (*elem).is.component) {
				if oper_kind as libc::c_uint == EcsOperNot as libc::c_int as libc::c_uint {
					return 0 as libc::c_int != 0;
				}
			} else if oper_kind as libc::c_uint != EcsOperNot as libc::c_int as libc::c_uint {
				return 0 as libc::c_int != 0;
			}
		}
		elem_i += 1
	}
	return 1 as libc::c_int != 0;
}
/* Find entity in prefabs of type */
#[no_mangle]
pub unsafe extern "C" fn ecs_find_entity_in_prefabs(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut type_0: ecs_type_t,
	mut component: ecs_entity_t,
	mut previous: ecs_entity_t,
) -> ecs_entity_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	/* Walk from back to front, as prefabs are always located
	 * at the end of the type. */
	i = count - 1 as libc::c_int;
	while i >= 0 as libc::c_int {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if !(e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
		{
			break;
		}
		let mut prefab: ecs_entity_t =
			e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
		let mut prefab_type: ecs_type_t = ecs_get_type(world, prefab);
		if !(prefab == previous) {
			if ecs_type_owns_entity(world, prefab_type, component, 1 as libc::c_int != 0) {
				return prefab;
			} else {
				prefab = ecs_find_entity_in_prefabs(world, prefab, prefab_type, component, entity);
				if prefab != 0 {
					return prefab;
				}
			}
		}
		i -= 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
/* Test if type_id_1 contains type_id_2 */
/* -- Private functions -- */
/* O(n) algorithm to check whether type 1 is equal or superset of type 2 */
#[no_mangle]
pub unsafe extern "C" fn ecs_type_contains(
	mut world: *mut ecs_world_t,
	mut type_1: ecs_type_t,
	mut type_2: ecs_type_t,
	mut match_all: bool,
	mut match_prefab: bool,
) -> ecs_entity_t {
	ecs_get_stage(&mut world);
	if type_1.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	if type_1 == type_2 {
		return *(_ecs_vector_first(
			type_1,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t);
	}
	let mut i_2: int32_t = 0;
	let mut i_1: int32_t = 0 as libc::c_int;
	let mut e1: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	let mut t1_array: *mut ecs_entity_t = _ecs_vector_first(
		type_1,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut t2_array: *mut ecs_entity_t = _ecs_vector_first(
		type_2,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut t1_count: int32_t = ecs_vector_count(type_1);
	let mut t2_count: int32_t = ecs_vector_count(type_2);
	i_2 = 0 as libc::c_int;
	while i_2 < t2_count {
		let mut e2: ecs_entity_t = *t2_array.offset(i_2 as isize);
		if i_1 >= t1_count {
			return 0 as libc::c_int as ecs_entity_t;
		}
		e1 = *t1_array.offset(i_1 as isize);
		if e2 > e1 {
			loop {
				i_1 += 1;
				if i_1 >= t1_count {
					return 0 as libc::c_int as ecs_entity_t;
				}
				e1 = *t1_array.offset(i_1 as isize);
				if !(e2 > e1) {
					break;
				}
			}
		}
		if e1 != e2 {
			if match_prefab as libc::c_int != 0
				&& e2 != 6 as libc::c_int as libc::c_ulong
				&& e2 != (256 as libc::c_int + 1 as libc::c_int) as libc::c_ulong
				&& e2 != (256 as libc::c_int + 3 as libc::c_int) as libc::c_ulong
			{
				if ecs_find_entity_in_prefabs(
					world,
					0 as libc::c_int as ecs_entity_t,
					type_1,
					e2,
					0 as libc::c_int as ecs_entity_t,
				) != 0
				{
					e1 = e2
				}
			}
			if e1 != e2 {
				if match_all {
					return 0 as libc::c_int as ecs_entity_t;
				}
			} else if !match_all {
				return e1;
			}
		} else {
			if !match_all {
				return e1;
			}
			i_1 += 1;
			if i_1 < t1_count {
				e1 = *t1_array.offset(i_1 as isize)
			}
		}
		i_2 += 1
	}
	if match_all {
		return e1;
	} else {
		return 0 as libc::c_int as ecs_entity_t;
	};
}
/* -- Public API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_type_index_of(
	mut type_0: ecs_type_t,
	mut entity: ecs_entity_t,
) -> int32_t {
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count(type_0);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		if *c_ptr == entity {
			return c_ptr_i;
		}
		c_ptr_i += 1
	}
	return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_merge(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut to_add: ecs_type_t,
	mut to_remove: ecs_type_t,
) -> ecs_type_t {
	ecs_get_stage(&mut world);
	let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
	let mut add_array: ecs_entities_t = ecs_type_to_entities(to_add);
	let mut remove_array: ecs_entities_t = ecs_type_to_entities(to_remove);
	table = ecs_table_traverse_remove(world, table, &mut remove_array, 0 as *mut ecs_entities_t);
	table = ecs_table_traverse_add(world, table, &mut add_array, 0 as *mut ecs_entities_t);
	if table.is_null() {
		return 0 as ecs_type_t;
	} else {
		return (*table).type_0;
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_find(
	mut world: *mut ecs_world_t,
	mut array: *mut ecs_entity_t,
	mut count: int32_t,
) -> ecs_type_t {
	ecs_get_stage(&mut world);
	let mut entities: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: array,
			count: count,
		};
		init
	};
	let mut table: *mut ecs_table_t = ecs_table_find_or_create(world, &mut entities);
	return (*table).type_0;
}
unsafe extern "C" fn has_trait(mut trait_0: ecs_entity_t, mut e: ecs_entity_t) -> bool {
	return trait_0
		== ((e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int))
			>> 32 as libc::c_int) as uint32_t as libc::c_ulong;
}
unsafe extern "C" fn has_case(
	mut world: *mut ecs_world_t,
	mut sw_case: ecs_entity_t,
	mut e: ecs_entity_t,
) -> bool {
	let mut type_ptr: *const EcsType = ecs_get_w_entity(
		world,
		e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
		3 as libc::c_int as ecs_entity_t,
	) as *const EcsType;
	return ecs_type_has_entity(world, (*type_ptr).normalized, sw_case);
}
unsafe extern "C" fn match_entity(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut e: ecs_entity_t,
	mut match_with: ecs_entity_t,
) -> libc::c_int {
	if match_with & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		let mut hi: ecs_entity_t = ((match_with
			& !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int))
			>> 32 as libc::c_int) as uint32_t as ecs_entity_t;
		let mut lo: ecs_entity_t = match_with as uint32_t as ecs_entity_t;
		if lo == (256 as libc::c_int + 27 as libc::c_int) as libc::c_ulong {
			if !(e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
				|| !has_trait(hi, e)
			{
				return 0 as libc::c_int;
			}
			let mut ids: *mut ecs_entity_t = _ecs_vector_first(
				type_0,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			let mut i: int32_t = 0;
			let mut count: int32_t = ecs_vector_count(type_0);
			let mut comp: ecs_entity_t = e as uint32_t as ecs_entity_t;
			i = 0 as libc::c_int;
			while i < count {
				if comp == *ids.offset(i as isize) {
					return 2 as libc::c_int;
				}
				i += 1
			}
			return -(1 as libc::c_int);
		} else {
			if hi == 0 {
				if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
						| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					&& has_trait(lo, e) as libc::c_int != 0
				{
					return 1 as libc::c_int;
				}
			}
		}
	} else if match_with & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		let mut sw_case: ecs_entity_t =
			match_with & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			&& has_case(world, sw_case, e) as libc::c_int != 0
		{
			return 1 as libc::c_int;
		} else {
			return 0 as libc::c_int;
		}
	}
	if e == match_with {
		return 1 as libc::c_int;
	}
	return 0 as libc::c_int;
}
unsafe extern "C" fn search_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut entity: ecs_entity_t,
	mut owned: bool,
) -> bool {
	if type_0.is_null() {
		return 0 as libc::c_int != 0;
	}
	if entity == 0 {
		return 1 as libc::c_int != 0;
	}
	let mut ids: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut matched: libc::c_int = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		let mut ret: libc::c_int = match_entity(world, type_0, *ids.offset(i as isize), entity);
		match ret {
			0 => {}
			1 => return 1 as libc::c_int != 0,
			-1 => return 0 as libc::c_int != 0,
			2 => matched += 1,
			_ => {
				_ecs_abort(
					12 as libc::c_int,
					0 as *const libc::c_char,
					b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
					24578 as libc::c_int,
				);
				abort();
			}
		}
		i += 1
	}
	if matched == 0
		&& !owned
		&& entity != (256 as libc::c_int + 1 as libc::c_int) as libc::c_ulong
		&& entity != (256 as libc::c_int + 3 as libc::c_int) as libc::c_ulong
	{
		i = count - 1 as libc::c_int;
		while i >= 0 as libc::c_int {
			let mut e: ecs_entity_t = *ids.offset(i as isize);
			if !(e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
			{
				break;
			}
			let mut base: ecs_entity_t =
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			let mut base_type: ecs_type_t = ecs_get_type(world, base);
			if search_type(world, base_type, entity, 0 as libc::c_int != 0) {
				return 1 as libc::c_int != 0;
			}
			i -= 1
		}
	}
	return matched != 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_has_entity(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut entity: ecs_entity_t,
) -> bool {
	return search_type(world, type_0, entity, 0 as libc::c_int != 0);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_owns_entity(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut entity: ecs_entity_t,
	mut owned: bool,
) -> bool {
	return search_type(world, type_0, entity, owned);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_has_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut has: ecs_type_t,
) -> bool {
	return ecs_type_contains(
		world,
		type_0,
		has,
		1 as libc::c_int != 0,
		0 as libc::c_int != 0,
	) != 0 as libc::c_int as libc::c_ulong;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_owns_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut has: ecs_type_t,
	mut owned: bool,
) -> bool {
	return ecs_type_contains(world, type_0, has, 1 as libc::c_int != 0, !owned)
		!= 0 as libc::c_int as libc::c_ulong;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_add(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut e: ecs_entity_t,
) -> ecs_type_t {
	ecs_get_stage(&mut world);
	let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
	let mut entities: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut e,
			count: 1 as libc::c_int,
		};
		init
	};
	table = ecs_table_traverse_add(world, table, &mut entities, 0 as *mut ecs_entities_t);
	return (*table).type_0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_remove(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut e: ecs_entity_t,
) -> ecs_type_t {
	ecs_get_stage(&mut world);
	let mut table: *mut ecs_table_t = ecs_table_from_type(world, type_0);
	let mut entities: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut e,
			count: 1 as libc::c_int,
		};
		init
	};
	table = ecs_table_traverse_remove(world, table, &mut entities, 0 as *mut ecs_entities_t);
	return (*table).type_0;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_str(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
) -> *mut libc::c_char {
	if type_0.is_null() {
		return ecs_os_api.strdup_.expect("non-null function pointer")(
			b"\x00" as *const u8 as *const libc::c_char,
		);
	}
	let mut chbuf: *mut ecs_vector_t = _ecs_vector_new(
		::std::mem::size_of::<libc::c_char>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
		} as int16_t,
		32 as libc::c_int,
	);
	let mut dst: *mut libc::c_char = 0 as *mut libc::c_char;
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		let mut buffer: [libc::c_char; 256] = [0; 256];
		let mut len: ecs_size_t = 0;
		if i != 0 {
			*(_ecs_vector_add(
				&mut chbuf,
				::std::mem::size_of::<libc::c_char>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<libc::c_char>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut libc::c_char) = ',' as i32 as libc::c_char
		}
		if e == 1 as libc::c_int as libc::c_ulong {
			strcpy(
				buffer.as_mut_ptr(),
				b"EcsComponent\x00" as *const u8 as *const libc::c_char,
			);
			len = strlen(b"EcsComponent\x00" as *const u8 as *const libc::c_char) as ecs_size_t
		} else {
			len = ecs_from_size_t(ecs_entity_str(
				world,
				e,
				buffer.as_mut_ptr(),
				256 as libc::c_int as size_t,
			))
		}
		dst = _ecs_vector_addn(
			&mut chbuf,
			::std::mem::size_of::<libc::c_char>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
			} as int16_t,
			len,
		) as *mut libc::c_char;
		memcpy(
			dst as *mut libc::c_void,
			buffer.as_mut_ptr() as *const libc::c_void,
			len as size_t,
		);
		i += 1
	}
	*(_ecs_vector_add(
		&mut chbuf,
		::std::mem::size_of::<libc::c_char>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut libc::c_char) = '\u{0}' as i32 as libc::c_char;
	let mut result: *mut libc::c_char =
		ecs_os_api.strdup_.expect("non-null function pointer")(_ecs_vector_first(
			chbuf,
			::std::mem::size_of::<libc::c_char>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<libc::c_char>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut libc::c_char);
	ecs_vector_free(chbuf);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_get_entity_for_xor(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut xor: ecs_entity_t,
) -> ecs_entity_t {
	let mut type_ptr: *const EcsType =
		ecs_get_w_entity(world, xor, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
	let mut xor_type: ecs_type_t = (*type_ptr).normalized;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = 0 as libc::c_int;
	while i < count {
		if ecs_type_owns_entity(
			world,
			xor_type,
			*array.offset(i as isize),
			1 as libc::c_int != 0,
		) {
			return *array.offset(i as isize);
		}
		i += 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_type_trait_index_of(
	mut type_0: ecs_type_t,
	mut start_index: int32_t,
	mut trait_0: ecs_entity_t,
) -> int32_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = start_index;
	while i < count {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			e &= !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			if trait_0 == (e >> 32 as libc::c_int) as uint32_t as libc::c_ulong {
				return i;
			}
		}
		i += 1
	}
	return -(1 as libc::c_int);
}
static mut ecs_os_api_initialized: bool = 0 as libc::c_int != 0;
static mut ecs_os_api_init_count: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ecs_os_api: ecs_os_api_t = ecs_os_api_t {
	init_: None,
	fini_: None,
	malloc_: None,
	realloc_: None,
	calloc_: None,
	free_: None,
	strdup_: None,
	thread_new_: None,
	thread_join_: None,
	ainc_: None,
	adec_: None,
	mutex_new_: None,
	mutex_free_: None,
	mutex_lock_: None,
	mutex_unlock_: None,
	cond_new_: None,
	cond_free_: None,
	cond_signal_: None,
	cond_broadcast_: None,
	cond_wait_: None,
	sleep_: None,
	get_time_: None,
	log_: None,
	log_error_: None,
	log_debug_: None,
	log_warning_: None,
	abort_: None,
	dlopen_: None,
	dlproc_: None,
	dlclose_: None,
	module_to_dl_: None,
	module_to_etc_: None,
};
#[no_mangle]
pub static mut ecs_os_api_malloc_count: int64_t = 0 as libc::c_int as int64_t;
#[no_mangle]
pub static mut ecs_os_api_realloc_count: int64_t = 0 as libc::c_int as int64_t;
#[no_mangle]
pub static mut ecs_os_api_calloc_count: int64_t = 0 as libc::c_int as int64_t;
#[no_mangle]
pub static mut ecs_os_api_free_count: int64_t = 0 as libc::c_int as int64_t;
#[no_mangle]
pub unsafe extern "C" fn ecs_os_set_api(mut os_api: *mut ecs_os_api_t) {
	if !ecs_os_api_initialized {
		ecs_os_api = *os_api;
		ecs_os_api_initialized = 1 as libc::c_int != 0
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_init() {
	if !ecs_os_api_initialized {
		ecs_os_set_api_defaults();
	}
	let fresh30 = ecs_os_api_init_count;
	ecs_os_api_init_count = ecs_os_api_init_count + 1;
	if fresh30 == 0 {
		if ecs_os_api.init_.is_some() {
			ecs_os_api.init_.expect("non-null function pointer")();
		}
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_fini() {
	ecs_os_api_init_count -= 1;
	if ecs_os_api_init_count == 0 {
		if ecs_os_api.fini_.is_some() {
			ecs_os_api.fini_.expect("non-null function pointer")();
		}
	};
}
unsafe extern "C" fn ecs_log(mut fmt: *const libc::c_char, mut args: ::std::ffi::VaList) {
	vfprintf(stdout, fmt, args.as_va_list());
	fprintf(stdout, b"\n\x00" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn ecs_log_error(mut fmt: *const libc::c_char, mut args: ::std::ffi::VaList) {
	vfprintf(stderr, fmt, args.as_va_list());
	fprintf(stderr, b"\n\x00" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn ecs_log_debug(mut fmt: *const libc::c_char, mut args: ::std::ffi::VaList) {
	vfprintf(stdout, fmt, args.as_va_list());
	fprintf(stdout, b"\n\x00" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn ecs_log_warning(mut fmt: *const libc::c_char, mut args: ::std::ffi::VaList) {
	vfprintf(stderr, fmt, args.as_va_list());
	fprintf(stderr, b"\n\x00" as *const u8 as *const libc::c_char);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_dbg(mut fmt: *const libc::c_char, mut args: ...) {}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_warn(mut fmt: *const libc::c_char, mut args: ...) {
	let mut args_0: ::std::ffi::VaListImpl;
	args_0 = args.clone();
	if ecs_os_api.log_warning_.is_some() {
		ecs_os_api.log_warning_.expect("non-null function pointer")(fmt, args_0.as_va_list());
	};
}
/* Time */
/* Logging (use functions to avoid using variadic macro arguments) */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_log(mut fmt: *const libc::c_char, mut args: ...) {
	let mut args_0: ::std::ffi::VaListImpl;
	args_0 = args.clone();
	if ecs_os_api.log_.is_some() {
		ecs_os_api.log_.expect("non-null function pointer")(fmt, args_0.as_va_list());
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_err(mut fmt: *const libc::c_char, mut args: ...) {
	let mut args_0: ::std::ffi::VaListImpl;
	args_0 = args.clone();
	if ecs_os_api.log_error_.is_some() {
		ecs_os_api.log_error_.expect("non-null function pointer")(fmt, args_0.as_va_list());
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_gettime(mut time: *mut ecs_time_t) {
	let mut now: uint64_t = ecs_os_time_now();
	let mut sec: uint64_t = now.wrapping_div(1000000000 as libc::c_int as libc::c_ulong);
	(*time).sec = sec as uint32_t;
	(*time).nanosec =
		now.wrapping_sub(sec.wrapping_mul(1000000000 as libc::c_int as libc::c_ulong)) as uint32_t;
}
unsafe extern "C" fn ecs_os_api_malloc(mut size: ecs_size_t) -> *mut libc::c_void {
	ecs_os_api_malloc_count += 1;
	return malloc(size as size_t);
}
unsafe extern "C" fn ecs_os_api_calloc(mut size: ecs_size_t) -> *mut libc::c_void {
	ecs_os_api_calloc_count += 1;
	return calloc(1 as libc::c_int as libc::c_ulong, size as size_t);
}
unsafe extern "C" fn ecs_os_api_realloc(
	mut ptr: *mut libc::c_void,
	mut size: ecs_size_t,
) -> *mut libc::c_void {
	if !ptr.is_null() {
		ecs_os_api_realloc_count += 1
	} else {
		/* If not actually reallocing, treat as malloc */
		ecs_os_api_malloc_count += 1
	}
	return realloc(ptr, size as size_t);
}
unsafe extern "C" fn ecs_os_api_free(mut ptr: *mut libc::c_void) {
	if !ptr.is_null() {
		ecs_os_api_free_count += 1
	}
	free(ptr);
}
unsafe extern "C" fn ecs_os_api_strdup(mut str: *const libc::c_char) -> *mut libc::c_char {
	let mut len: libc::c_int = strlen(str) as ecs_size_t;
	let mut result: *mut libc::c_char =
		ecs_os_api.malloc_.expect("non-null function pointer")(len + 1 as libc::c_int)
			as *mut libc::c_char;
	strcpy(result, str);
	return result;
}
/* Replace dots with underscores */
unsafe extern "C" fn module_file_base(
	mut module: *const libc::c_char,
	mut sep: libc::c_char,
) -> *mut libc::c_char {
	let mut base: *mut libc::c_char =
		ecs_os_api.strdup_.expect("non-null function pointer")(module);
	let mut i: ecs_size_t = 0;
	let mut len: ecs_size_t = strlen(base) as ecs_size_t;
	i = 0 as libc::c_int;
	while i < len {
		if *base.offset(i as isize) as libc::c_int == '.' as i32 {
			*base.offset(i as isize) = sep
		}
		i += 1
	}
	return base;
}
unsafe extern "C" fn ecs_os_api_module_to_dl(mut module: *const libc::c_char) -> *mut libc::c_char {
	let mut lib: ecs_strbuf_t = {
		let mut init = ecs_strbuf_t {
			buf: 0 as *mut libc::c_char,
			max: 0,
			size: 0,
			elementCount: 0,
			firstElement: ecs_strbuf_element_embedded {
				super_0: ecs_strbuf_element {
					buffer_embedded: false,
					pos: 0,
					buf: 0 as *mut libc::c_char,
					next: 0 as *mut ecs_strbuf_element,
				},
				buf: [0; 512],
			},
			current: 0 as *mut ecs_strbuf_element,
			list_stack: [ecs_strbuf_list_elem {
				count: 0,
				separator: 0 as *const libc::c_char,
			}; 32],
			list_sp: 0,
		};
		init
	};
	/* Best guess, use module name with underscores + OS library extension */
	let mut file_base: *mut libc::c_char = module_file_base(module, '_' as i32 as libc::c_char);
	ecs_strbuf_appendstr(&mut lib, b"lib\x00" as *const u8 as *const libc::c_char);
	ecs_strbuf_appendstr(&mut lib, file_base);
	ecs_strbuf_appendstr(&mut lib, b".so\x00" as *const u8 as *const libc::c_char);
	ecs_os_api.free_.expect("non-null function pointer")(file_base as *mut libc::c_void);
	return ecs_strbuf_get(&mut lib);
}
unsafe extern "C" fn ecs_os_api_module_to_etc(
	mut module: *const libc::c_char,
) -> *mut libc::c_char {
	let mut lib: ecs_strbuf_t = {
		let mut init = ecs_strbuf_t {
			buf: 0 as *mut libc::c_char,
			max: 0,
			size: 0,
			elementCount: 0,
			firstElement: ecs_strbuf_element_embedded {
				super_0: ecs_strbuf_element {
					buffer_embedded: false,
					pos: 0,
					buf: 0 as *mut libc::c_char,
					next: 0 as *mut ecs_strbuf_element,
				},
				buf: [0; 512],
			},
			current: 0 as *mut ecs_strbuf_element,
			list_stack: [ecs_strbuf_list_elem {
				count: 0,
				separator: 0 as *const libc::c_char,
			}; 32],
			list_sp: 0,
		};
		init
	};
	/* Best guess, use module name with dashes + /etc */
	let mut file_base: *mut libc::c_char = module_file_base(module, '-' as i32 as libc::c_char);
	ecs_strbuf_appendstr(&mut lib, file_base);
	ecs_strbuf_appendstr(&mut lib, b"/etc\x00" as *const u8 as *const libc::c_char);
	ecs_os_api.free_.expect("non-null function pointer")(file_base as *mut libc::c_void);
	return ecs_strbuf_get(&mut lib);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_set_api_defaults() {
	/* Don't overwrite if already initialized */
	if ecs_os_api_initialized as libc::c_int != 0 as libc::c_int {
		return;
	}
	ecs_os_time_setup();
	/* Memory management */
	ecs_os_api.malloc_ =
		Some(ecs_os_api_malloc as unsafe extern "C" fn(_: ecs_size_t) -> *mut libc::c_void);
	ecs_os_api.free_ = Some(ecs_os_api_free as unsafe extern "C" fn(_: *mut libc::c_void) -> ());
	ecs_os_api.realloc_ = Some(
		ecs_os_api_realloc
			as unsafe extern "C" fn(_: *mut libc::c_void, _: ecs_size_t) -> *mut libc::c_void,
	);
	ecs_os_api.calloc_ =
		Some(ecs_os_api_calloc as unsafe extern "C" fn(_: ecs_size_t) -> *mut libc::c_void);
	/* Strings */
	ecs_os_api.strdup_ = Some(
		ecs_os_api_strdup as unsafe extern "C" fn(_: *const libc::c_char) -> *mut libc::c_char,
	);
	/* Time */
	ecs_os_api.sleep_ =
		Some(ecs_os_time_sleep as unsafe extern "C" fn(_: int32_t, _: int32_t) -> ());
	ecs_os_api.get_time_ = Some(ecs_os_gettime as unsafe extern "C" fn(_: *mut ecs_time_t) -> ());
	/* Logging */
	ecs_os_api.log_ =
		Some(ecs_log as unsafe extern "C" fn(_: *const libc::c_char, _: ::std::ffi::VaList) -> ());
	ecs_os_api.log_error_ = Some(
		ecs_log_error as unsafe extern "C" fn(_: *const libc::c_char, _: ::std::ffi::VaList) -> (),
	);
	ecs_os_api.log_debug_ = Some(
		ecs_log_debug as unsafe extern "C" fn(_: *const libc::c_char, _: ::std::ffi::VaList) -> (),
	);
	ecs_os_api.log_warning_ = Some(
		ecs_log_warning
			as unsafe extern "C" fn(_: *const libc::c_char, _: ::std::ffi::VaList) -> (),
	);
	/* Modules */
	if ecs_os_api.module_to_dl_.is_none() {
		ecs_os_api.module_to_dl_ = Some(
			ecs_os_api_module_to_dl
				as unsafe extern "C" fn(_: *const libc::c_char) -> *mut libc::c_char,
		)
	}
	if ecs_os_api.module_to_etc_.is_none() {
		ecs_os_api.module_to_etc_ = Some(
			ecs_os_api_module_to_etc
				as unsafe extern "C" fn(_: *const libc::c_char) -> *mut libc::c_char,
		)
	}
	ecs_os_api.abort_ = ::std::mem::transmute::<
		Option<unsafe extern "C" fn() -> !>,
		ecs_os_api_abort_t,
	>(Some(abort as unsafe extern "C" fn() -> !));
}
/* * Are heap functions available? */
/* -- Public functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_has_heap() -> bool {
	return ecs_os_api.malloc_.is_some()
		&& ecs_os_api.calloc_.is_some()
		&& ecs_os_api.realloc_.is_some()
		&& ecs_os_api.free_.is_some();
}
/* * Are threading functions available? */
/* * Are threading functions available? */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_has_threading() -> bool {
	return ecs_os_api.mutex_new_.is_some()
		&& ecs_os_api.mutex_free_.is_some()
		&& ecs_os_api.mutex_lock_.is_some()
		&& ecs_os_api.mutex_unlock_.is_some()
		&& ecs_os_api.cond_new_.is_some()
		&& ecs_os_api.cond_free_.is_some()
		&& ecs_os_api.cond_wait_.is_some()
		&& ecs_os_api.cond_signal_.is_some()
		&& ecs_os_api.cond_broadcast_.is_some()
		&& ecs_os_api.thread_new_.is_some()
		&& ecs_os_api.thread_join_.is_some();
}
/* * Are time functions available? */
/* * Are time functions available? */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_has_time() -> bool {
	return ecs_os_api.get_time_.is_some() && ecs_os_api.sleep_.is_some();
}
/* * Are logging functions available? */
/* * Are logging functions available? */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_has_logging() -> bool {
	return ecs_os_api.log_.is_some()
		&& ecs_os_api.log_error_.is_some()
		&& ecs_os_api.log_debug_.is_some()
		&& ecs_os_api.log_warning_.is_some();
}
/* * Are dynamic library functions available? */
/* * Are dynamic library functions available? */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_has_dl() -> bool {
	return ecs_os_api.dlopen_.is_some()
		&& ecs_os_api.dlproc_.is_some()
		&& ecs_os_api.dlclose_.is_some();
}
/* * Are module path functions available? */
/* * Are module path functions available? */
#[no_mangle]
pub unsafe extern "C" fn ecs_os_has_modules() -> bool {
	return ecs_os_api.module_to_dl_.is_some() && ecs_os_api.module_to_etc_.is_some();
}
unsafe extern "C" fn components_contains(
	mut world: *mut ecs_world_t,
	mut table_type: ecs_type_t,
	mut type_0: ecs_type_t,
	mut entity_out: *mut ecs_entity_t,
	mut match_all: bool,
) -> ecs_entity_t {
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count(table_type);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		table_type,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		let mut entity: ecs_entity_t = *c_ptr;
		if entity & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			entity &= !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			let mut record: *mut ecs_record_t = _ecs_sparse_get_sparse(
				(*world).store.entity_index,
				::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
				entity,
			) as *mut ecs_record_t;
			if !(*record).table.is_null() {
				let mut component: ecs_entity_t = ecs_type_contains(
					world,
					(*(*record).table).type_0,
					type_0,
					match_all,
					1 as libc::c_int != 0,
				);
				if component != 0 {
					if !entity_out.is_null() {
						*entity_out = entity
					}
					return component;
				}
			}
		}
		c_ptr_i += 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
/* Get actual entity on which specified component is stored */
unsafe extern "C" fn get_entity_for_component(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut type_0: ecs_type_t,
	mut component: ecs_entity_t,
) -> ecs_entity_t {
	if entity != 0 {
		let mut record: *mut ecs_record_t = _ecs_sparse_get_sparse(
			(*world).store.entity_index,
			::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
			entity,
		) as *mut ecs_record_t;
		if !(*record).table.is_null() {
			type_0 = (*(*record).table).type_0
		} else {
			type_0 = 0 as ecs_type_t
		}
	}
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count(type_0);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		if *c_ptr == component {
			return entity;
		}
		c_ptr_i += 1
	}
	return ecs_find_entity_in_prefabs(
		world,
		entity,
		type_0,
		component,
		0 as libc::c_int as ecs_entity_t,
	);
}
unsafe extern "C" fn rank_by_depth(
	mut world: *mut ecs_world_t,
	mut rank_by_component: ecs_entity_t,
	mut type_0: ecs_type_t,
) -> int32_t {
	let mut result: int32_t = 0 as libc::c_int;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = count - 1 as libc::c_int;
	while i >= 0 as libc::c_int {
		if *array.offset(i as isize) & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			let mut c_type: ecs_type_t = ecs_get_type(
				world,
				*array.offset(i as isize)
					& !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
			);
			let mut j: int32_t = 0;
			let mut c_count: int32_t = ecs_vector_count(c_type);
			let mut c_array: *mut ecs_entity_t = _ecs_vector_first(
				c_type,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			j = 0 as libc::c_int;
			while j < c_count {
				if *c_array.offset(j as isize) == rank_by_component {
					result += 1;
					result += rank_by_depth(world, rank_by_component, c_type);
					break;
				} else {
					j += 1
				}
			}
			if j != c_count {
				break;
			}
		} else if *array.offset(i as isize)
			& (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== 0
		{
			break;
		}
		i -= 1
	}
	return result;
}
unsafe extern "C" fn table_compare(
	mut t1: *const libc::c_void,
	mut t2: *const libc::c_void,
) -> libc::c_int {
	let mut table_1: *const ecs_matched_table_t = t1 as *const ecs_matched_table_t;
	let mut table_2: *const ecs_matched_table_t = t2 as *const ecs_matched_table_t;
	return (*table_1).rank - (*table_2).rank;
}
unsafe extern "C" fn order_ranked_tables(mut world: *mut ecs_world_t, mut query: *mut ecs_query_t) {
	if (*query).group_table.is_some() {
		_ecs_vector_sort(
			(*query).tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
			Some(
				table_compare
					as unsafe extern "C" fn(
						_: *const libc::c_void,
						_: *const libc::c_void,
					) -> libc::c_int,
			),
		);
	}
	/* Re-register monitors after tables have been reordered. This will update
	 * the table administration with the new matched_table ids, so that when a
	 * monitor is executed we can quickly find the right matched_table. */
	if (*query).flags & 2 as libc::c_int as libc::c_uint != 0 {
		let mut table_i: libc::c_int = 0;
		let mut table_count: libc::c_int = ecs_vector_count((*query).tables);
		let mut table_array: *mut ecs_matched_table_t = _ecs_vector_first(
			(*query).tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_table_t;
		table_i = 0 as libc::c_int;
		while table_i < table_count {
			let mut table: *mut ecs_matched_table_t =
				&mut *table_array.offset(table_i as isize) as *mut ecs_matched_table_t;
			ecs_table_notify(world, (*table).data.table, &mut {
				let mut init = ecs_table_event_t {
					kind: EcsTableQueryMatch,
					query: query,
					matched_table_index: table_i,
					component: 0,
				};
				init
			});
			table_i += 1
		}
	}
	(*query).match_count += 1;
}
unsafe extern "C" fn group_table(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_matched_table_t,
) {
	if (*query).group_table.is_some() {
		(*table).rank = (*query).group_table.expect("non-null function pointer")(
			world,
			(*query).rank_on_component,
			(*(*table).data.table).type_0,
		)
	} else {
		(*table).rank = 0 as libc::c_int
	};
}
/* Rank all tables of query. Only necessary if a new ranking function was
 * provided or if a monitored entity set the component used for ranking. */
unsafe extern "C" fn group_tables(mut world: *mut ecs_world_t, mut query: *mut ecs_query_t) {
	if (*query).group_table.is_some() {
		let mut table_i: libc::c_int = 0;
		let mut table_count: libc::c_int = ecs_vector_count((*query).tables);
		let mut table_array: *mut ecs_matched_table_t = _ecs_vector_first(
			(*query).tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_table_t;
		table_i = 0 as libc::c_int;
		while table_i < table_count {
			let mut table: *mut ecs_matched_table_t =
				&mut *table_array.offset(table_i as isize) as *mut ecs_matched_table_t;
			group_table(world, query, table);
			table_i += 1
		}
		let mut table_i_0: libc::c_int = 0;
		let mut table_count_0: libc::c_int = ecs_vector_count((*query).empty_tables);
		let mut table_array_0: *mut ecs_matched_table_t = _ecs_vector_first(
			(*query).empty_tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_table_t;
		table_i_0 = 0 as libc::c_int;
		while table_i_0 < table_count_0 {
			let mut table_0: *mut ecs_matched_table_t =
				&mut *table_array_0.offset(table_i_0 as isize) as *mut ecs_matched_table_t;
			group_table(world, query, table_0);
			table_i_0 += 1
		}
	};
}
unsafe extern "C" fn has_auto_activation(mut q: *mut ecs_query_t) -> bool {
	/* Only a basic query with no additional features does table activation */
	return (*q).flags & (2 as libc::c_int | 4 as libc::c_int | 8 as libc::c_int) as libc::c_uint
		== 0;
}
unsafe extern "C" fn get_comp_and_src(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table_type: ecs_type_t,
	mut column: *mut ecs_sig_column_t,
	mut op: ecs_sig_oper_kind_t,
	mut from: ecs_sig_from_kind_t,
	mut component_out: *mut ecs_entity_t,
	mut entity_out: *mut ecs_entity_t,
) {
	let mut component: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	let mut entity: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	if op as libc::c_uint == EcsOperNot as libc::c_int as libc::c_uint {
		entity = (*column).source
	}
	/* Column that retrieves data from self or a fixed entity */
	if from as libc::c_uint == EcsFromAny as libc::c_int as libc::c_uint
		|| from as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint
		|| from as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint
		|| from as libc::c_uint == EcsFromShared as libc::c_int as libc::c_uint
	{
		if op as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint
			|| op as libc::c_uint == EcsOperNot as libc::c_int as libc::c_uint
			|| op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint
		{
			component = (*column).is.component
		} else if op as libc::c_uint == EcsOperAll as libc::c_int as libc::c_uint {
			component = (*column).is.component
				& !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
		} else if op as libc::c_uint == EcsOperOr as libc::c_int as libc::c_uint {
			component = ecs_type_contains(
				world,
				table_type,
				(*column).is.type_0 as ecs_type_t,
				0 as libc::c_int != 0,
				1 as libc::c_int != 0,
			)
		}
		if from as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
			entity = (*column).source
		}
	/* Column that just passes a handle to the system (no data) */
	} else if from as libc::c_uint == EcsFromEmpty as libc::c_int as libc::c_uint {
		component = (*column).is.component
	/* Column that retrieves data from a dynamic entity */
	} else if from as libc::c_uint == EcsFromParent as libc::c_int as libc::c_uint
		|| from as libc::c_uint == EcsCascade as libc::c_int as libc::c_uint
	{
		if op as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint
			|| op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint
		{
			component = (*column).is.component;
			entity = ecs_find_in_type(
				world,
				table_type,
				component,
				(1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int,
			)
		} else if op as libc::c_uint == EcsOperOr as libc::c_int as libc::c_uint {
			component = components_contains(
				world,
				table_type,
				(*column).is.type_0 as ecs_type_t,
				&mut entity,
				0 as libc::c_int != 0,
			)
		}
	/* Column that retrieves data from a system */
	} else if from as libc::c_uint == EcsFromSystem as libc::c_int as libc::c_uint {
		if op as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint {
			component = (*column).is.component
		}
		entity = (*query).system
	}
	*component_out = component;
	*entity_out = entity;
}
/* Get index for specified trait. Take into account that a trait can be matched
 * multiple times per table, by keeping an offset of the last found index */
unsafe extern "C" fn get_trait_index(
	mut table_type: ecs_type_t,
	mut component: ecs_entity_t,
	mut column_index: int32_t,
	mut trait_offsets: *mut trait_offset_t,
	mut count: int32_t,
) -> int32_t {
	let mut result: int32_t = 0;
	/* The count variable keeps track of the number of times a trait has been
	 * matched with the current table. Compare the count to check if the index
	 * was already resolved for this iteration */
	if (*trait_offsets.offset(column_index as isize)).count == count {
		/* If it was resolved, return the last stored index. Subtract one as the
		 * index is offset by one, to ensure we're not getting stuck on the same
		 * index. */
		result = (*trait_offsets.offset(column_index as isize)).index - 1 as libc::c_int
	} else {
		/* First time for this iteration that the trait index is resolved, look
		 * it up in the type. */
		result = ecs_type_trait_index_of(
			table_type,
			(*trait_offsets.offset(column_index as isize)).index,
			component,
		);
		(*trait_offsets.offset(column_index as isize)).index = result + 1 as libc::c_int;
		(*trait_offsets.offset(column_index as isize)).count = count
	}
	return result;
}
unsafe extern "C" fn get_component_index(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut table_type: ecs_type_t,
	mut component_out: *mut ecs_entity_t,
	mut column_index: int32_t,
	mut op: ecs_sig_oper_kind_t,
	mut trait_offsets: *mut trait_offset_t,
	mut count: int32_t,
) -> int32_t {
	let mut result: int32_t = 0 as libc::c_int;
	let mut component: ecs_entity_t = *component_out;
	if component != 0 {
		/* If requested component is a case, find the corresponding switch to
		 * lookup in the table */
		if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			result = ecs_table_switch_from_case(world, table, component);
			result += (*table).sw_column_offset
		} else if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			/* If only the lo part of the trait identifier is set, interpret it
			 * as the trait to match. This will match any instance of the trait
			 * on the entity and in a signature looks like "TRAIT | MyTrait". */
			if ((component & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int))
				>> 32 as libc::c_int) as uint32_t
				== 0
			{
				/* Strip the TRAIT role */
				component &= !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
				/* Get index of trait. Start looking from the last trait index
				 * as this may not be the first instance of the trait. */
				result = get_trait_index(table_type, component, column_index, trait_offsets, count);
				if result != -(1 as libc::c_int) {
					/* If component of current column is a trait, get the actual
					 * trait type for the table, so the system can see which
					 * component the trait was applied to */
					let mut trait_0: *mut ecs_entity_t = _ecs_vector_get(
						table_type,
						::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
							as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
						} as int16_t,
						result,
					) as *mut ecs_entity_t;
					*component_out = *trait_0;
					/* Check if the trait is a tag or whether it has data */
					if (ecs_get_w_entity(world, component, 1 as libc::c_int as ecs_entity_t)
						as *const EcsComponent)
						.is_null()
					{
						/* If trait has no data associated with it, use the
						 * component to which the trait has been added */
						component = *trait_0 as uint32_t as ecs_entity_t
					}
				}
			} else {
				/* If trait does have the hi part of the identifier set, this is
				 * a fully qualified trait identifier. In a signature this looks
				 * like "TRAIT | MyTrait > Comp". */
				let mut lo: ecs_entity_t = component as uint32_t as ecs_entity_t;
				if lo == (256 as libc::c_int + 27 as libc::c_int) as libc::c_ulong {
					/* Get id for the trait to lookup by taking the trait from
					 * the high 32 bits, move it to the low 32 bits, and reapply
					 * the TRAIT mask. */
					component = ((component
						& !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int))
						>> 32 as libc::c_int) as uint32_t as ecs_entity_t;
					/* Now lookup the component as usual */
					result =
						get_trait_index(table_type, component, column_index, trait_offsets, count);
					/* If the low part of the identifier is the wildcard entity,
					 * this column is requesting the component to which the
					 * trait is applied. First, find the component identifier */
					/* Type must have the trait, otherwise table would not have
					 * matched */
					/* Get component id at returned index */
					let mut trait_1: *mut ecs_entity_t = _ecs_vector_get(
						table_type,
						::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
							as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
						} as int16_t,
						result,
					) as *mut ecs_entity_t;
					component = *trait_1 as uint32_t as ecs_entity_t;
					*component_out = component
				}
				/* Get the lower part of the trait id. This is the component
				 * we're looking for. */
				/* If the low part is a regular entity (component), then
				 * this query exactly matches a single trait instance. In
				 * this case we can simply do a lookup of the trait
				 * identifier in the table type. */
				result = ecs_type_index_of(table_type, component)
			}
		} else {
			/* Get column index for component */
			result = ecs_type_index_of(table_type, component)
		}
		/* ecs_table_column_offset may return -1 if the component comes
		 * from a prefab. If so, the component will be resolved as a
		 * reference (see below) */
		if result != -(1 as libc::c_int) {
			result += 1;
			/* If column is found, add one to the index, as column zero in
			 * a table is reserved for entity id's */
			/* Check if component is a tag. If it is, set table_data to
			 * zero, so that a system won't try to access the data */
			if !(component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
				&& !(component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
						| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
			{
				component = ecs_component_id_from_id(world, component);
				let mut data: *const EcsComponent =
					ecs_get_w_entity(world, component, 1 as libc::c_int as ecs_entity_t)
						as *const EcsComponent;
				if data.is_null() || (*data).size == 0 {
					result = 0 as libc::c_int
				}
			}
		}
	}
	if op as libc::c_uint == EcsOperAll as libc::c_int as libc::c_uint {
		result = 0 as libc::c_int
	} else if op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint {
		/* If table doesn't have the field, mark it as no data */
		if !ecs_type_has_entity(world, table_type, component) {
			result = 0 as libc::c_int
		}
	}
	return result;
}
unsafe extern "C" fn add_ref(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table_type: ecs_type_t,
	mut references: *mut ecs_vector_t,
	mut component: ecs_entity_t,
	mut entity: ecs_entity_t,
	mut from: ecs_sig_from_kind_t,
) -> *mut ecs_vector_t {
	let mut c_info: *const EcsComponent =
		ecs_get_w_entity(world, component, 1 as libc::c_int as ecs_entity_t) as *const EcsComponent;
	let mut e: ecs_entity_t = 0;
	let mut ref_0: *mut ecs_ref_t = _ecs_vector_add(
		&mut references,
		::std::mem::size_of::<ecs_ref_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_ref_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_ref_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_ref_t;
	/* Find the entity for the component */
	if from as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint
		|| from as libc::c_uint == EcsFromEmpty as libc::c_int as libc::c_uint
	{
		e = entity
	} else if from as libc::c_uint == EcsCascade as libc::c_int as libc::c_uint {
		e = entity
	} else if from as libc::c_uint == EcsFromSystem as libc::c_int as libc::c_uint {
		e = entity
	} else {
		e = get_entity_for_component(world, entity, table_type, component)
	}
	*ref_0 = {
		let mut init = ecs_ref_t {
			entity: 0 as libc::c_int as ecs_entity_t,
			component: 0,
			table: 0 as *mut libc::c_void,
			row: 0,
			alloc_count: 0,
			record: 0 as *mut ecs_record_t,
			ptr: 0 as *const libc::c_void,
		};
		init
	};
	(*ref_0).entity = e;
	(*ref_0).component = component;
	if ecs_has_type(world, component, FLECS__TEcsComponent) {
		if (*c_info).size != 0
			&& from as libc::c_uint != EcsFromEmpty as libc::c_int as libc::c_uint
		{
			if e != 0 {
				ecs_get_ref_w_entity(world, ref_0, e, component);
				ecs_set_watch(world, e);
			}
			(*query).flags |= 64 as libc::c_int as libc::c_uint
		}
	}
	return references;
}
unsafe extern "C" fn is_column_trait(mut column: *mut ecs_sig_column_t) -> ecs_entity_t {
	let mut from_kind: ecs_sig_from_kind_t = (*column).from_kind;
	let mut oper_kind: ecs_sig_oper_kind_t = (*column).oper_kind;
	/* For now traits are only supported on owned columns */
	if from_kind as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint
		&& oper_kind as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint
	{
		let mut c: ecs_entity_t = (*column).is.component;
		if c & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			if ((c & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int))
				>> 32 as libc::c_int) as uint32_t
				== 0
			{
				return c;
			} else {
				if c as uint32_t == (256 as libc::c_int + 27 as libc::c_int) as libc::c_uint {
					return ((c & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int))
						>> 32 as libc::c_int) as uint32_t as ecs_entity_t;
				}
			}
		}
	}
	return 0 as libc::c_int as ecs_entity_t;
}
unsafe extern "C" fn type_trait_count(
	mut type_0: ecs_type_t,
	mut trait_0: ecs_entity_t,
) -> int32_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut result: int32_t = 0 as libc::c_int;
	trait_0 &= !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			e &= !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			if (e >> 32 as libc::c_int) as uint32_t as libc::c_ulong == trait_0 {
				result += 1
			}
		}
		i += 1
	}
	return result;
}
/* For each trait that the query subscribes for, count the occurrences in the
 * table. Cardinality of subscribed for traits must be the same as in the table
 * or else the table won't match. */
unsafe extern "C" fn count_traits(mut query: *mut ecs_query_t, mut type_0: ecs_type_t) -> int32_t {
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*query).sig.columns);
	let mut first_count: int32_t = 0 as libc::c_int;
	let mut trait_count: int32_t = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		let mut trait_0: ecs_entity_t = is_column_trait(&mut *columns.offset(i as isize));
		if trait_0 != 0 {
			trait_count = type_trait_count(type_0, trait_0);
			if first_count == 0 {
				first_count = trait_count
			} else if first_count != trait_count {
				/* The traits that this query subscribed for occur in the
				 * table but don't have the same cardinality. Ignore the
				 * table. This could typically happen for empty tables along
				 * a path in the table graph. */
				return -(1 as libc::c_int);
			}
		}
		i += 1
	}
	return first_count;
}
unsafe extern "C" fn get_column_type(
	mut world: *mut ecs_world_t,
	mut oper_kind: ecs_sig_oper_kind_t,
	mut component: ecs_entity_t,
) -> ecs_type_t {
	if oper_kind as libc::c_uint == EcsOperAll as libc::c_int as libc::c_uint {
		let mut type_0: *const EcsType =
			ecs_get_w_entity(world, component, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
		return (*type_0).normalized;
	} else {
		return ecs_type_from_entity(world, component);
	};
}
/* * Add table to system, compute offsets for system components in table it */
unsafe extern "C" fn add_table(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_table_t,
) {
	let mut columns: *mut ecs_sig_column_t = 0 as *mut ecs_sig_column_t;
	let mut table_elem: *mut ecs_matched_table_t = 0 as *mut ecs_matched_table_t;
	let mut table_type: ecs_type_t = 0 as ecs_type_t;
	let mut c: int32_t = 0;
	let mut column_count: int32_t = ecs_vector_count((*query).sig.columns);
	if !table.is_null() {
		table_type = (*table).type_0
	}
	let mut trait_cur: int32_t = 0 as libc::c_int;
	let mut trait_count: int32_t = count_traits(query, table_type);
	/* If the query has traits, we need to account for the fact that a table may
	 * have multiple components to which the trait is applied, which means the
	 * table has to be registered with the query multiple times, with different
	 * table columns. If so, allocate a small array for each trait in which the
	 * last added table index of the trait is stored, so that in the next
	 * iteration we can start the search from the correct offset type. */
	let mut trait_offsets: *mut trait_offset_t = 0 as *mut trait_offset_t;
	if trait_count != 0 {
		trait_offsets = ecs_os_api.calloc_.expect("non-null function pointer")(
			::std::mem::size_of::<trait_offset_t>() as libc::c_ulong as ecs_size_t * column_count,
		) as *mut trait_offset_t
	}
	/* From here we recurse */
	let mut matched_table_index: int32_t = 0 as libc::c_int;
	let mut table_data: ecs_matched_table_t = ecs_matched_table_t {
		data: ecs_iter_table_t {
			columns: 0 as *mut int32_t,
			table: 0 as *mut ecs_table_t,
			data: 0 as *mut ecs_data_t,
			components: 0 as *mut ecs_entity_t,
			types: 0 as *mut ecs_type_t,
			references: 0 as *mut ecs_ref_t,
		},
		sparse_columns: 0 as *mut ecs_vector_t,
		monitor: 0 as *mut int32_t,
		rank: 0,
	};
	let mut references: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
	loop {
		table_data = {
			let mut init = ecs_matched_table_t {
				data: {
					let mut init = ecs_iter_table_t {
						columns: 0 as *mut int32_t,
						table: table,
						data: 0 as *mut ecs_data_t,
						components: 0 as *mut ecs_entity_t,
						types: 0 as *mut ecs_type_t,
						references: 0 as *mut ecs_ref_t,
					};
					init
				},
				sparse_columns: 0 as *mut ecs_vector_t,
				monitor: 0 as *mut int32_t,
				rank: 0,
			};
			init
		};
		if !table.is_null() {
			table_type = (*table).type_0
		}
		/* If grouping is enabled for query, assign the group rank to the table */
		group_table(world, query, &mut table_data);
		if column_count != 0 {
			/* Array that contains the system column to table column mapping */
			table_data.data.columns = ecs_os_api.malloc_.expect("non-null function pointer")(
				::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t * column_count,
			) as *mut int32_t;
			/* Store the components of the matched table. In the case of OR expressions,
			 * components may differ per matched table. */
			table_data.data.components = ecs_os_api.malloc_.expect("non-null function pointer")(
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * column_count,
			) as *mut ecs_entity_t;
			/* Also cache types, so no lookup is needed while iterating */
			table_data.data.types = ecs_os_api.malloc_.expect("non-null function pointer")(
				::std::mem::size_of::<ecs_type_t>() as libc::c_ulong as ecs_size_t * column_count,
			) as *mut ecs_type_t
		}
		/* Walk columns parsed from the system signature */
		columns = _ecs_vector_first(
			(*query).sig.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		c = 0 as libc::c_int;
		while c < column_count {
			let mut column: *mut ecs_sig_column_t =
				&mut *columns.offset(c as isize) as *mut ecs_sig_column_t;
			let mut entity: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
			let mut component: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
			let mut op: ecs_sig_oper_kind_t = (*column).oper_kind;
			let mut from: ecs_sig_from_kind_t = (*column).from_kind;
			if op as libc::c_uint == EcsOperNot as libc::c_int as libc::c_uint {
				from = EcsFromEmpty
			}
			*table_data.data.columns.offset(c as isize) = 0 as libc::c_int;
			/* Get actual component and component source for current column */
			get_comp_and_src(
				world,
				query,
				table_type,
				column,
				op,
				from,
				&mut component,
				&mut entity,
			);
			/* This column does not retrieve data from a static entity (either
			 * EcsFromSystem or EcsFromParent) and is not just a handle */
			if entity == 0 && from as libc::c_uint != EcsFromEmpty as libc::c_int as libc::c_uint {
				let mut index: int32_t = get_component_index(
					world,
					table,
					table_type,
					&mut component,
					c,
					op,
					trait_offsets,
					trait_cur + 1 as libc::c_int,
				);
				if index == -(1 as libc::c_int) {
					if from as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint
						&& op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint
					{
						index = 0 as libc::c_int
					}
				} else if from as libc::c_uint == EcsFromShared as libc::c_int as libc::c_uint
					&& op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint
				{
					index = 0 as libc::c_int
				}
				*table_data.data.columns.offset(c as isize) = index;
				/* If the column is a case, we should only iterate the entities in
				 * the column for this specific case. Add a sparse column with the
				 * case id so we can find the correct entities when iterating */
				if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
						| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				{
					let mut sc: *mut ecs_sparse_column_t = _ecs_vector_add(
						&mut table_data.sparse_columns,
						::std::mem::size_of::<ecs_sparse_column_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_sparse_column_t>()
							as libc::c_ulong as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_sparse_column_t>() as libc::c_ulong
								as int64_t
						} as int16_t,
					) as *mut ecs_sparse_column_t;
					(*sc).signature_column_index = c;
					(*sc).sw_case =
						component & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
					(*sc).sw_column = 0 as *mut ecs_sw_column_t
				}
			}
			/* Check if a the component is a reference. If 'entity' is set, the
			 * component must be resolved from another entity, which is the case
			 * for FromEntity and FromContainer.
			 *
			 * If no entity is set but the component is not found in the table, it
			 * must come from a prefab. This is guaranteed, as at this point it is
			 * already validated that the table matches with the system.
			 *
			 * If the column from is Cascade, there may not be an entity in case the
			 * current table contains root entities. In that case, still add a
			 * reference field. The application can, after the table has matched,
			 * change the set of components, so that this column will turn into a
			 * reference. Having the reference already linked to the system table
			 * makes changing this administation easier when the change happens.
			 */
			if entity != 0
				|| *table_data.data.columns.offset(c as isize) == -(1 as libc::c_int)
				|| from as libc::c_uint == EcsCascade as libc::c_int as libc::c_uint
			{
				references = add_ref(
					world, query, table_type, references, component, entity, from,
				);
				*table_data.data.columns.offset(c as isize) = -ecs_vector_count(references)
			}
			*table_data.data.components.offset(c as isize) = component;
			let ref mut fresh31 = *table_data.data.types.offset(c as isize);
			*fresh31 = get_column_type(world, op, component);
			c += 1
		}
		/* Initially always add table to inactive group. If the system is registered
		 * with the table and the table is not empty, the table will send an
		 * activate signal to the system. */
		table_elem = 0 as *mut ecs_matched_table_t;
		if !table.is_null() && has_auto_activation(query) as libc::c_int != 0 {
			table_elem = _ecs_vector_add(
				&mut (*query).empty_tables,
				::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_matched_table_t
		} else {
			/* If no table is provided to function, this is a system that contains
			 * no columns that require table matching. In this case, the system will
			 * only have one "dummy" table that caches data from the system columns.
			 * Always add this dummy table to the list of active tables, since it
			 * would never get activated otherwise. */
			table_elem = _ecs_vector_add(
				&mut (*query).tables,
				::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_matched_table_t;
			/* If query doesn't automatically activates/inactivates tables, we can
			 * get the count to determine the current table index. */
			matched_table_index = ecs_vector_count((*query).tables) - 1 as libc::c_int
		}
		if !references.is_null() {
			let mut ref_size: ecs_size_t = ::std::mem::size_of::<ecs_ref_t>() as libc::c_ulong
				as ecs_size_t * ecs_vector_count(references);
			table_data.data.references =
				ecs_os_api.malloc_.expect("non-null function pointer")(ref_size) as *mut ecs_ref_t;
			memcpy(
				table_data.data.references as *mut libc::c_void,
				_ecs_vector_first(
					references,
					::std::mem::size_of::<ecs_ref_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_ref_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_ref_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_ref_t as *const libc::c_void,
				ref_size as size_t,
			);
			ecs_vector_free(references);
			references = 0 as *mut ecs_vector_t
		}
		*table_elem = table_data;
		/* Use tail recursion when adding table for multiple traits */
		trait_cur += 1;
		if !(trait_cur < trait_count) {
			break;
		}
	}
	if !table.is_null() && (*query).flags & 256 as libc::c_int as libc::c_uint == 0 {
		ecs_table_notify(world, table, &mut {
			let mut init = ecs_table_event_t {
				kind: EcsTableQueryMatch,
				query: query,
				matched_table_index: matched_table_index,
				component: 0,
			};
			init
		});
	}
	if !trait_offsets.is_null() {
		ecs_os_api.free_.expect("non-null function pointer")(trait_offsets as *mut libc::c_void);
	};
}
unsafe extern "C" fn match_column(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
	mut from_kind: ecs_sig_from_kind_t,
	mut component: ecs_entity_t,
	mut source: ecs_entity_t,
	mut failure_info: *mut ecs_match_failure_t,
) -> bool {
	if from_kind as libc::c_uint == EcsFromAny as libc::c_int as libc::c_uint {
		(*failure_info).reason = EcsMatchFromSelf;
		return ecs_type_has_entity(world, type_0, component);
	} else if from_kind as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint {
		(*failure_info).reason = EcsMatchFromOwned;
		return ecs_type_owns_entity(world, type_0, component, 1 as libc::c_int != 0);
	} else if from_kind as libc::c_uint == EcsFromShared as libc::c_int as libc::c_uint {
		(*failure_info).reason = EcsMatchFromShared;
		return !ecs_type_owns_entity(world, type_0, component, 1 as libc::c_int != 0)
			&& ecs_type_owns_entity(world, type_0, component, 0 as libc::c_int != 0)
				as libc::c_int != 0;
	} else if from_kind as libc::c_uint == EcsFromParent as libc::c_int as libc::c_uint {
		(*failure_info).reason = EcsMatchFromContainer;
		return ecs_find_in_type(
			world,
			type_0,
			component,
			(1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int,
		) != 0 as libc::c_int as libc::c_ulong;
	} else if from_kind as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
		(*failure_info).reason = EcsMatchFromEntity;
		let mut source_type: ecs_type_t = ecs_get_type(world, source);
		return ecs_type_has_entity(world, source_type, component);
	} else {
		return 1 as libc::c_int != 0;
	};
}
/* Match table with system */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_match(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut query: *mut ecs_query_t,
	mut failure_info: *mut ecs_match_failure_t,
) -> bool {
	/* Prevent having to add if not null checks everywhere */
	let mut tmp_failure_info: ecs_match_failure_t = ecs_match_failure_t {
		reason: EcsMatchOk,
		column: 0,
	};
	if failure_info.is_null() {
		failure_info = &mut tmp_failure_info
	}
	(*failure_info).reason = EcsMatchOk;
	(*failure_info).column = 0 as libc::c_int;
	if (*query).flags & 1 as libc::c_int as libc::c_uint == 0 {
		(*failure_info).reason = EcsMatchSystemIsATask;
		return 0 as libc::c_int != 0;
	}
	let mut type_0: ecs_type_t = 0 as *const ecs_vector_t;
	let mut table_type: ecs_type_t = (*table).type_0;
	/* Don't match disabled entities */
	if (*query).flags & 16 as libc::c_int as libc::c_uint == 0
		&& ecs_type_owns_entity(
			world,
			table_type,
			(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
			1 as libc::c_int != 0,
		) as libc::c_int
			!= 0
	{
		(*failure_info).reason = EcsMatchEntityIsDisabled;
		return 0 as libc::c_int != 0;
	}
	/* Don't match prefab entities */
	if (*query).flags & 32 as libc::c_int as libc::c_uint == 0
		&& ecs_type_owns_entity(
			world,
			table_type,
			(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t,
			1 as libc::c_int != 0,
		) as libc::c_int
			!= 0
	{
		(*failure_info).reason = EcsMatchEntityIsPrefab;
		return 0 as libc::c_int != 0;
	}
	/* Check if trait cardinality matches traits in query, if any */
	if count_traits(query, (*table).type_0) == -(1 as libc::c_int) {
		return 0 as libc::c_int != 0;
	}
	let mut i: int32_t = 0;
	let mut column_count: int32_t = ecs_vector_count((*query).sig.columns);
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	i = 0 as libc::c_int;
	while i < column_count {
		let mut elem: *mut ecs_sig_column_t =
			&mut *columns.offset(i as isize) as *mut ecs_sig_column_t;
		let mut from_kind: ecs_sig_from_kind_t = (*elem).from_kind;
		let mut oper_kind: ecs_sig_oper_kind_t = (*elem).oper_kind;
		(*failure_info).column = i + 1 as libc::c_int;
		if oper_kind as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint {
			if !match_column(
				world,
				table_type,
				from_kind,
				(*elem).is.component,
				(*elem).source,
				failure_info,
			) {
				return 0 as libc::c_int != 0;
			}
		} else if oper_kind as libc::c_uint == EcsOperNot as libc::c_int as libc::c_uint {
			if match_column(
				world,
				table_type,
				from_kind,
				(*elem).is.component,
				(*elem).source,
				failure_info,
			) {
				return 0 as libc::c_int != 0;
			}
		} else if oper_kind as libc::c_uint == EcsOperOr as libc::c_int as libc::c_uint
			|| oper_kind as libc::c_uint == EcsOperAll as libc::c_int as libc::c_uint
		{
			let mut match_all: bool =
				oper_kind as libc::c_uint == EcsOperAll as libc::c_int as libc::c_uint;
			if match_all {
				let mut type_ptr: *const EcsType = ecs_get_w_entity(
					world,
					(*elem).is.component,
					3 as libc::c_int as ecs_entity_t,
				) as *const EcsType;
				type_0 = (*type_ptr).normalized
			} else {
				type_0 = (*elem).is.type_0 as ecs_type_t
			}
			if from_kind as libc::c_uint == EcsFromAny as libc::c_int as libc::c_uint {
				if ecs_type_contains(world, table_type, type_0, match_all, 1 as libc::c_int != 0)
					== 0
				{
					(*failure_info).reason = EcsMatchOrFromSelf;
					return 0 as libc::c_int != 0;
				}
			} else if from_kind as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint {
				if ecs_type_contains(world, table_type, type_0, match_all, 0 as libc::c_int != 0)
					== 0
				{
					(*failure_info).reason = EcsMatchOrFromOwned;
					return 0 as libc::c_int != 0;
				}
			} else if from_kind as libc::c_uint == EcsFromShared as libc::c_int as libc::c_uint {
				if ecs_type_contains(world, table_type, type_0, match_all, 0 as libc::c_int != 0)
					!= 0 || ecs_type_contains(
					world,
					table_type,
					type_0,
					match_all,
					1 as libc::c_int != 0,
				) == 0
				{
					(*failure_info).reason = EcsMatchOrFromShared;
					return 0 as libc::c_int != 0;
				}
			} else if from_kind as libc::c_uint == EcsFromParent as libc::c_int as libc::c_uint {
				if (*table).flags & 8 as libc::c_uint == 0 {
					(*failure_info).reason = EcsMatchOrFromContainer;
					return 0 as libc::c_int != 0;
				}
				if components_contains(world, table_type, type_0, 0 as *mut ecs_entity_t, match_all)
					== 0
				{
					(*failure_info).reason = EcsMatchOrFromContainer;
					return 0 as libc::c_int != 0;
				}
			}
		}
		i += 1
	}
	return 1 as libc::c_int != 0;
}
/* * Match existing tables against system (table is created before system) */
unsafe extern "C" fn match_tables(mut world: *mut ecs_world_t, mut query: *mut ecs_query_t) {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count((*world).store.tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		if ecs_query_match(world, table, query, 0 as *mut ecs_match_failure_t) {
			add_table(world, query, table);
		}
		i += 1
	}
	order_ranked_tables(world, query);
}
/* * Get index of table in system's matched tables */
unsafe extern "C" fn get_table_param_index(
	mut table: *mut ecs_table_t,
	mut tables: *mut ecs_vector_t,
	mut start_index: int32_t,
) -> int32_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(tables);
	let mut table_data: *mut ecs_matched_table_t = _ecs_vector_first(
		tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	i = start_index;
	while i < count {
		if (*table_data.offset(i as isize)).data.table == table {
			break;
		}
		i += 1
	}
	return if i == count { -(1 as libc::c_int) } else { i };
}
/* * Check if a table was matched with the system */
unsafe extern "C" fn table_matched(
	mut tables: *mut ecs_vector_t,
	mut table: *mut ecs_table_t,
) -> int32_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(tables);
	let mut table_data: *mut ecs_matched_table_t = _ecs_vector_first(
		tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	i = 0 as libc::c_int;
	while i < count {
		if (*table_data.offset(i as isize)).data.table == table {
			return i;
		}
		i += 1
	}
	return -(1 as libc::c_int);
}
unsafe extern "C" fn resolve_cascade_container(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table_data_index: int32_t,
	mut table_type: ecs_type_t,
) {
	let mut table_data: *mut ecs_matched_table_t = _ecs_vector_get(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		table_data_index,
	) as *mut ecs_matched_table_t;
	/* Obtain reference index */
	let mut column_indices: *mut int32_t = (*table_data).data.columns;
	let mut column: int32_t = (*query).cascade_by - 1 as libc::c_int;
	let mut ref_index: int32_t = -*column_indices.offset(column as isize) - 1 as libc::c_int;
	/* Obtain pointer to the reference data */
	let mut references: *mut ecs_ref_t = (*table_data).data.references;
	let mut ref_0: *mut ecs_ref_t = &mut *references.offset(ref_index as isize) as *mut ecs_ref_t;
	/* Resolve container entity */
	let mut container: ecs_entity_t = ecs_find_in_type(
		world,
		table_type,
		(*ref_0).component,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int,
	);
	/* If container was found, update the reference */
	if container != 0 {
		(*references.offset(ref_index as isize)).entity = container;
		ecs_get_ref_w_entity(
			world,
			&mut *references.offset(ref_index as isize),
			container,
			(*ref_0).component,
		);
	} else {
		(*references.offset(ref_index as isize)).entity = 0 as libc::c_int as ecs_entity_t
	};
}
unsafe extern "C" fn qsort_partition(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut entities: *mut ecs_entity_t,
	mut ptr: *mut libc::c_void,
	mut elem_size: int32_t,
	mut lo: int32_t,
	mut hi: int32_t,
	mut compare: ecs_compare_action_t,
) -> int32_t {
	let mut p: int32_t = (hi + lo) / 2 as libc::c_int;
	let mut pivot: *mut libc::c_void =
		(ptr as uintptr_t).wrapping_add((elem_size * p) as uintptr_t) as *mut libc::c_void;
	let mut pivot_e: ecs_entity_t = *entities.offset(p as isize);
	let mut i: int32_t = lo - 1 as libc::c_int;
	let mut j: int32_t = hi + 1 as libc::c_int;
	let mut el: *mut libc::c_void = 0 as *mut libc::c_void;
	loop {
		loop {
			i += 1;
			el = (ptr as uintptr_t).wrapping_add((elem_size * i) as uintptr_t) as *mut libc::c_void;
			if !(compare.expect("non-null function pointer")(
				*entities.offset(i as isize),
				el,
				pivot_e,
				pivot,
			) < 0 as libc::c_int)
			{
				break;
			}
		}
		loop {
			j -= 1;
			el = (ptr as uintptr_t).wrapping_add((elem_size * j) as uintptr_t) as *mut libc::c_void;
			if !(compare.expect("non-null function pointer")(
				*entities.offset(j as isize),
				el,
				pivot_e,
				pivot,
			) > 0 as libc::c_int)
			{
				break;
			}
		}
		if i >= j {
			return j;
		}
		ecs_table_swap(world, table, data, i, j);
		if p == i {
			pivot =
				(ptr as uintptr_t).wrapping_add((elem_size * j) as uintptr_t) as *mut libc::c_void;
			pivot_e = *entities.offset(j as isize)
		} else if p == j {
			pivot =
				(ptr as uintptr_t).wrapping_add((elem_size * i) as uintptr_t) as *mut libc::c_void;
			pivot_e = *entities.offset(i as isize)
		}
	}
}
unsafe extern "C" fn qsort_array(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut data: *mut ecs_data_t,
	mut entities: *mut ecs_entity_t,
	mut ptr: *mut libc::c_void,
	mut size: int32_t,
	mut lo: int32_t,
	mut hi: int32_t,
	mut compare: ecs_compare_action_t,
) {
	if hi - lo < 1 as libc::c_int {
		return;
	}
	let mut p: int32_t = qsort_partition(world, table, data, entities, ptr, size, lo, hi, compare);
	qsort_array(world, table, data, entities, ptr, size, lo, p, compare);
	qsort_array(
		world,
		table,
		data,
		entities,
		ptr,
		size,
		p + 1 as libc::c_int,
		hi,
		compare,
	);
}
unsafe extern "C" fn sort_table(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut column_index: int32_t,
	mut compare: ecs_compare_action_t,
) {
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if data.is_null() || (*data).entities.is_null() {
		/* Nothing to sort */
		return;
	}
	let mut count: int32_t = ecs_table_data_count(data);
	if count < 2 as libc::c_int {
		return;
	}
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
	let mut size: int32_t = 0 as libc::c_int;
	if column_index != -(1 as libc::c_int) {
		let mut column: *mut ecs_column_t =
			&mut *(*data).columns.offset(column_index as isize) as *mut ecs_column_t;
		size = (*column).size as int32_t;
		ptr = _ecs_vector_first(
			(*column).data,
			size,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> (*column).alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				(*column).alignment as libc::c_int
			} as int16_t,
		)
	}
	qsort_array(
		world,
		table,
		data,
		entities,
		ptr,
		size,
		0 as libc::c_int,
		count - 1 as libc::c_int,
		compare,
	);
}
unsafe extern "C" fn ptr_from_helper(mut helper: *mut sort_helper_t) -> *mut libc::c_void {
	return ((*helper).ptr as uintptr_t)
		.wrapping_add(((*helper).elem_size * (*helper).row) as uintptr_t) as *mut libc::c_void;
}
unsafe extern "C" fn e_from_helper(mut helper: *mut sort_helper_t) -> ecs_entity_t {
	if (*helper).row < (*helper).count {
		return *(*helper).entities.offset((*helper).row as isize);
	} else {
		return 0 as libc::c_int as ecs_entity_t;
	};
}
unsafe extern "C" fn build_sorted_table_range(
	mut query: *mut ecs_query_t,
	mut start: int32_t,
	mut end: int32_t,
) {
	let mut component: ecs_entity_t = (*query).sort_on_component;
	let mut compare: ecs_compare_action_t = (*query).compare;
	/* Fetch data from all matched tables */
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut helper: *mut sort_helper_t = ecs_os_api.malloc_.expect("non-null function pointer")(
		(end - start) * ::std::mem::size_of::<sort_helper_t>() as libc::c_ulong as ecs_size_t,
	) as *mut sort_helper_t;
	let mut i: libc::c_int = 0;
	let mut to_sort: libc::c_int = 0 as libc::c_int;
	i = start;
	while i < end {
		let mut table_data: *mut ecs_matched_table_t =
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		let mut table: *mut ecs_table_t = (*table_data).data.table;
		let mut data: *mut ecs_data_t = ecs_table_get_data(table);
		let mut entities: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
		if !(data.is_null()
			|| {
				entities = (*data).entities;
				entities.is_null()
			} || ecs_table_count(table) == 0)
		{
			let mut index: int32_t = ecs_type_index_of((*table).type_0, component);
			if index != -(1 as libc::c_int) {
				let mut column: *mut ecs_column_t =
					&mut *(*data).columns.offset(index as isize) as *mut ecs_column_t;
				let mut size: int16_t = (*column).size;
				let mut align: int16_t = (*column).alignment;
				let ref mut fresh32 = (*helper.offset(to_sort as isize)).ptr;
				*fresh32 = _ecs_vector_first(
					(*column).data,
					size as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						> align as libc::c_int
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					} else {
						align as libc::c_int
					} as int16_t,
				);
				(*helper.offset(to_sort as isize)).elem_size = size as int32_t
			} else {
				let ref mut fresh33 = (*helper.offset(to_sort as isize)).ptr;
				*fresh33 = 0 as *mut libc::c_void;
				(*helper.offset(to_sort as isize)).elem_size = 0 as libc::c_int
			}
			let ref mut fresh34 = (*helper.offset(to_sort as isize)).table;
			*fresh34 = table_data;
			let ref mut fresh35 = (*helper.offset(to_sort as isize)).entities;
			*fresh35 = _ecs_vector_first(
				entities,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			(*helper.offset(to_sort as isize)).row = 0 as libc::c_int;
			(*helper.offset(to_sort as isize)).count = ecs_table_count(table);
			to_sort += 1
		}
		i += 1
	}
	let mut cur: *mut ecs_table_slice_t = 0 as *mut ecs_table_slice_t;
	let mut proceed: bool = false;
	loop {
		let mut j: int32_t = 0;
		let mut min: int32_t = 0 as libc::c_int;
		proceed = 1 as libc::c_int != 0;
		let mut e1: ecs_entity_t = 0;
		loop {
			e1 = e_from_helper(&mut *helper.offset(min as isize));
			if !(e1 == 0) {
				break;
			}
			min += 1;
			if !(min == to_sort) {
				continue;
			}
			proceed = 0 as libc::c_int != 0;
			break;
		}
		if !proceed {
			break;
		}
		j = min + 1 as libc::c_int;
		while j < to_sort {
			let mut e2: ecs_entity_t = e_from_helper(&mut *helper.offset(j as isize));
			if !(e2 == 0) {
				let mut ptr1: *mut libc::c_void =
					ptr_from_helper(&mut *helper.offset(min as isize));
				let mut ptr2: *mut libc::c_void = ptr_from_helper(&mut *helper.offset(j as isize));
				if compare.expect("non-null function pointer")(e1, ptr1, e2, ptr2)
					> 0 as libc::c_int
				{
					min = j
				}
			}
			j += 1
		}
		let mut cur_helper: *mut sort_helper_t =
			&mut *helper.offset(min as isize) as *mut sort_helper_t;
		if cur.is_null() || (*cur).table != (*cur_helper).table {
			cur = _ecs_vector_add(
				&mut (*query).table_slices,
				::std::mem::size_of::<ecs_table_slice_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_table_slice_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_table_slice_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_table_slice_t;
			(*cur).table = (*cur_helper).table;
			(*cur).start_row = (*cur_helper).row;
			(*cur).count = 1 as libc::c_int
		} else {
			(*cur).count += 1
		}
		(*cur_helper).row += 1;
		if !proceed {
			break;
		}
	}
	ecs_os_api.free_.expect("non-null function pointer")(helper as *mut libc::c_void);
}
unsafe extern "C" fn build_sorted_tables(mut query: *mut ecs_query_t) {
	/* Clean previous sorted tables */
	ecs_vector_free((*query).table_slices);
	(*query).table_slices = 0 as *mut ecs_vector_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*query).tables);
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut table: *mut ecs_matched_table_t = 0 as *mut ecs_matched_table_t;
	let mut start: int32_t = 0 as libc::c_int;
	let mut rank: int32_t = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		table = &mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		if rank != (*table).rank {
			if start != i {
				build_sorted_table_range(query, start, i);
				start = i
			}
			rank = (*table).rank
		}
		i += 1
	}
	if start != i {
		build_sorted_table_range(query, start, i);
	};
}
unsafe extern "C" fn tables_dirty(mut query: *mut ecs_query_t) -> bool {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*query).tables);
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut is_dirty: bool = 0 as libc::c_int != 0;
	i = 0 as libc::c_int;
	while i < count {
		let mut table_data: *mut ecs_matched_table_t =
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		let mut table: *mut ecs_table_t = (*table_data).data.table;
		if (*table_data).monitor.is_null() {
			(*table_data).monitor = ecs_table_get_monitor(table);
			is_dirty = 1 as libc::c_int != 0
		}
		let mut dirty_state: *mut int32_t = ecs_table_get_dirty_state(table);
		let mut t: int32_t = 0;
		let mut type_count: int32_t = (*table).column_count;
		t = 0 as libc::c_int;
		while t < type_count + 1 as libc::c_int {
			is_dirty = is_dirty as libc::c_int != 0
				|| *dirty_state.offset(t as isize) != *(*table_data).monitor.offset(t as isize);
			t += 1
		}
		i += 1
	}
	is_dirty = is_dirty as libc::c_int != 0 || (*query).match_count != (*query).prev_match_count;
	return is_dirty;
}
unsafe extern "C" fn tables_reset_dirty(mut query: *mut ecs_query_t) {
	(*query).prev_match_count = (*query).match_count;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*query).tables);
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	i = 0 as libc::c_int;
	while i < count {
		let mut table_data: *mut ecs_matched_table_t =
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		let mut table: *mut ecs_table_t = (*table_data).data.table;
		if (*table_data).monitor.is_null() {
			/* If one table doesn't have a monitor, none of the tables will have
			 * a monitor, so early out. */
			return;
		}
		let mut dirty_state: *mut int32_t = ecs_table_get_dirty_state(table);
		let mut t: int32_t = 0;
		let mut type_count: int32_t = (*table).column_count;
		t = 0 as libc::c_int;
		while t < type_count + 1 as libc::c_int {
			*(*table_data).monitor.offset(t as isize) = *dirty_state.offset(t as isize);
			t += 1
		}
		i += 1
	}
}
unsafe extern "C" fn sort_tables(mut world: *mut ecs_world_t, mut query: *mut ecs_query_t) {
	let mut compare: ecs_compare_action_t = (*query).compare;
	if compare.is_none() {
		return;
	}
	let mut sort_on_component: ecs_entity_t = (*query).sort_on_component;
	/* Iterate over active tables. Don't bother with inactive tables, since
	 * they're empty */
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*query).tables);
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut tables_sorted: bool = 0 as libc::c_int != 0;
	i = 0 as libc::c_int;
	while i < count {
		let mut table_data: *mut ecs_matched_table_t =
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		let mut table: *mut ecs_table_t = (*table_data).data.table;
		/* If no monitor had been created for the table yet, create it now */
		let mut is_dirty: bool = 0 as libc::c_int != 0;
		if (*table_data).monitor.is_null() {
			(*table_data).monitor = ecs_table_get_monitor(table);
			/* A new table is always dirty */
			is_dirty = 1 as libc::c_int != 0
		}
		let mut dirty_state: *mut int32_t = ecs_table_get_dirty_state(table);
		is_dirty = is_dirty as libc::c_int != 0
			|| *dirty_state.offset(0 as libc::c_int as isize)
				!= *(*table_data).monitor.offset(0 as libc::c_int as isize);
		let mut index: int32_t = -(1 as libc::c_int);
		if sort_on_component != 0 {
			/* Get index of sorted component. We only care if the component we're
			 * sorting on has changed or if entities have been added / re(moved) */
			index = ecs_type_index_of((*table).type_0, sort_on_component);
			is_dirty = is_dirty as libc::c_int != 0
				|| *dirty_state.offset((index + 1 as libc::c_int) as isize)
					!= *(*table_data)
						.monitor
						.offset((index + 1 as libc::c_int) as isize)
		}
		/* Check both if entities have moved (element 0) or if the component
		 * we're sorting on has changed (index + 1) */
		if is_dirty {
			/* Sort the table */
			sort_table(world, table, index, compare);
			tables_sorted = 1 as libc::c_int != 0
		}
		i += 1
	}
	if tables_sorted as libc::c_int != 0 || (*query).match_count != (*query).prev_match_count {
		build_sorted_tables(query);
		(*query).match_count += 1
		/* Increase version if tables changed */
	};
}
unsafe extern "C" fn has_refs(mut sig: *mut ecs_sig_t) -> bool {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*sig).columns);
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*sig).columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	i = 0 as libc::c_int;
	while i < count {
		let mut from_kind: ecs_sig_from_kind_t = (*columns.offset(i as isize)).from_kind;
		if (*columns.offset(i as isize)).oper_kind as libc::c_uint
			== EcsOperNot as libc::c_int as libc::c_uint
			&& from_kind as libc::c_uint == EcsFromEmpty as libc::c_int as libc::c_uint
		{
			/* Special case: if oper kind is Not and the query contained a
			 * shared expression, the expression is translated to FromId to
			 * prevent resolving the ref */
			return 1 as libc::c_int != 0;
		} else {
			if from_kind as libc::c_uint != EcsFromAny as libc::c_int as libc::c_uint
				&& from_kind as libc::c_uint != EcsFromEmpty as libc::c_int as libc::c_uint
			{
				/* If the component is not from the entity being iterated over, and
				 * the column is not just passing an id, it must be a reference to
				 * another entity. */
				return 1 as libc::c_int != 0;
			}
		}
		i += 1
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn has_traits(mut sig: *mut ecs_sig_t) -> bool {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*sig).columns);
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*sig).columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	i = 0 as libc::c_int;
	while i < count {
		if is_column_trait(&mut *columns.offset(i as isize)) != 0 {
			return 1 as libc::c_int != 0;
		}
		i += 1
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn register_monitors(mut world: *mut ecs_world_t, mut query: *mut ecs_query_t) {
	let mut column_i: libc::c_int = 0;
	let mut column_count: libc::c_int = ecs_vector_count((*query).sig.columns);
	let mut column_array: *mut ecs_sig_column_t = _ecs_vector_first(
		(*query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	column_i = 0 as libc::c_int;
	while column_i < column_count {
		let mut column: *mut ecs_sig_column_t =
			&mut *column_array.offset(column_i as isize) as *mut ecs_sig_column_t;
		/* If component is requested with CASCADE source register component as a
		 * parent monitor. Parent monitors keep track of whether an entity moved
		 * in the hierarchy, which potentially requires the query to reorder its
		 * tables.
		 * Also register a regular component monitor for EcsCascade columns.
		 * This ensures that when the component used in the CASCADE column
		 * is added or removed tables are updated accordingly*/
		if (*column).from_kind as libc::c_uint == EcsCascade as libc::c_int as libc::c_uint {
			if (*column).oper_kind as libc::c_uint != EcsOperOr as libc::c_int as libc::c_uint {
				ecs_component_monitor_register(
					&mut (*world).parent_monitors,
					(*column).is.component,
					query,
				);
				ecs_component_monitor_register(
					&mut (*world).component_monitors,
					(*column).is.component,
					query,
				);
			} else {
				let mut e_ptr_i: libc::c_int = 0;
				let mut e_ptr_count: libc::c_int = ecs_vector_count((*column).is.type_0);
				let mut e_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
					(*column).is.type_0,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				e_ptr_i = 0 as libc::c_int;
				while e_ptr_i < e_ptr_count {
					let mut e_ptr: *mut ecs_entity_t =
						&mut *e_ptr_array.offset(e_ptr_i as isize) as *mut ecs_entity_t;
					ecs_component_monitor_register(&mut (*world).parent_monitors, *e_ptr, query);
					ecs_component_monitor_register(&mut (*world).component_monitors, *e_ptr, query);
					e_ptr_i += 1
				}
			}
		/* FromSelf also requires registering a monitor, as FromSelf columns can
		 * be matched with prefabs. The only column kinds that do not require
		 * registering a monitor are FromOwned and FromNothing. */
		} else if (*column).from_kind as libc::c_uint == EcsFromAny as libc::c_int as libc::c_uint
			|| (*column).from_kind as libc::c_uint == EcsFromShared as libc::c_int as libc::c_uint
			|| (*column).from_kind as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint
			|| (*column).from_kind as libc::c_uint == EcsFromParent as libc::c_int as libc::c_uint
		{
			if (*column).oper_kind as libc::c_uint != EcsOperOr as libc::c_int as libc::c_uint {
				ecs_component_monitor_register(
					&mut (*world).component_monitors,
					(*column).is.component,
					query,
				);
			} else {
				let mut e_ptr_i_0: libc::c_int = 0;
				let mut e_ptr_count_0: libc::c_int = ecs_vector_count((*column).is.type_0);
				let mut e_ptr_array_0: *mut ecs_entity_t = _ecs_vector_first(
					(*column).is.type_0,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				e_ptr_i_0 = 0 as libc::c_int;
				while e_ptr_i_0 < e_ptr_count_0 {
					let mut e_ptr_0: *mut ecs_entity_t =
						&mut *e_ptr_array_0.offset(e_ptr_i_0 as isize) as *mut ecs_entity_t;
					ecs_component_monitor_register(
						&mut (*world).component_monitors,
						*e_ptr_0,
						query,
					);
					e_ptr_i_0 += 1
				}
			}
		}
		column_i += 1
	}
}
unsafe extern "C" fn process_signature(mut world: *mut ecs_world_t, mut query: *mut ecs_query_t) {
	let mut i: libc::c_int = 0;
	let mut count: libc::c_int = ecs_vector_count((*query).sig.columns);
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	i = 0 as libc::c_int;
	while i < count {
		let mut column: *mut ecs_sig_column_t =
			&mut *columns.offset(i as isize) as *mut ecs_sig_column_t;
		let mut op: ecs_sig_oper_kind_t = (*column).oper_kind;
		let mut from: ecs_sig_from_kind_t = (*column).from_kind;
		let mut inout: ecs_sig_inout_kind_t = (*column).inout_kind;
		if inout as libc::c_uint != EcsIn as libc::c_int as libc::c_uint {
			(*query).flags |= 512 as libc::c_int as libc::c_uint
		}
		if op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint {
			(*query).flags |= 1024 as libc::c_int as libc::c_uint
		}
		if (*query).flags & 16 as libc::c_int as libc::c_uint == 0 {
			if op as libc::c_uint == EcsOperOr as libc::c_int as libc::c_uint {
				/* If the signature explicitly indicates interest in EcsDisabled,
				 * signal that disabled entities should be matched. By default,
				 * disabled entities are not matched. */
				if ecs_type_owns_entity(
					world,
					(*column).is.type_0 as ecs_type_t,
					(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
					1 as libc::c_int != 0,
				) {
					(*query).flags |= 16 as libc::c_int as libc::c_uint
				}
			} else if op as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint
				|| op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint
			{
				if (*column).is.component
					== (256 as libc::c_int + 3 as libc::c_int) as libc::c_ulong
				{
					(*query).flags |= 16 as libc::c_int as libc::c_uint
				}
			}
		}
		if (*query).flags & 32 as libc::c_int as libc::c_uint == 0 {
			if op as libc::c_uint == EcsOperOr as libc::c_int as libc::c_uint {
				/* If the signature explicitly indicates interest in EcsPrefab,
				 * signal that disabled entities should be matched. By default,
				 * prefab entities are not matched. */
				if ecs_type_owns_entity(
					world,
					(*column).is.type_0 as ecs_type_t,
					(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t,
					1 as libc::c_int != 0,
				) {
					(*query).flags |= 32 as libc::c_int as libc::c_uint
				}
			} else if op as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint
				|| op as libc::c_uint == EcsOperOptional as libc::c_int as libc::c_uint
			{
				if (*column).is.component
					== (256 as libc::c_int + 1 as libc::c_int) as libc::c_ulong
				{
					(*query).flags |= 32 as libc::c_int as libc::c_uint
				}
			}
		}
		if from as libc::c_uint == EcsFromAny as libc::c_int as libc::c_uint
			|| from as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint
			|| from as libc::c_uint == EcsFromShared as libc::c_int as libc::c_uint
			|| from as libc::c_uint == EcsFromParent as libc::c_int as libc::c_uint
		{
			(*query).flags |= 1 as libc::c_int as libc::c_uint
		}
		if from as libc::c_uint == EcsCascade as libc::c_int as libc::c_uint {
			(*query).cascade_by = i + 1 as libc::c_int;
			(*query).rank_on_component = (*column).is.component
		}
		if from as libc::c_uint == EcsFromEntity as libc::c_int as libc::c_uint {
			ecs_set_watch(world, (*column).source);
		}
		i += 1
	}
	(*query).flags |=
		(has_refs(&mut (*query).sig) as libc::c_int * 64 as libc::c_int) as ecs_flags32_t;
	(*query).flags |=
		(has_traits(&mut (*query).sig) as libc::c_int * 128 as libc::c_int) as ecs_flags32_t;
	register_monitors(world, query);
}
#[no_mangle]
pub unsafe extern "C" fn match_table(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_table_t,
) {
	if ecs_query_match(world, table, query, 0 as *mut ecs_match_failure_t) {
		add_table(world, query, table);
	};
}
/* * Table activation happens when a table was or becomes empty. Deactivated
 * tables are not considered by the system in the main loop. */
#[no_mangle]
pub unsafe extern "C" fn activate_table(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_table_t,
	mut active: bool,
) {
	let mut src_array: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
	let mut dst_array: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
	if active {
		src_array = (*query).empty_tables;
		dst_array = (*query).tables
	} else {
		src_array = (*query).tables;
		dst_array = (*query).empty_tables
	}
	let mut i: int32_t = 0 as libc::c_int;
	let mut activated: int32_t = 0 as libc::c_int;
	loop {
		i = get_table_param_index(table, src_array, i);
		if !(i != -(1 as libc::c_int)) {
			break;
		}
		activated += 1;
		let mut src_count: int32_t = _ecs_vector_move_index(
			&mut dst_array,
			src_array,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
			i,
		);
		if active {
			(*query).tables = dst_array
		} else {
			(*query).empty_tables = dst_array
		}
		/* Activate system if registered with query */
		if (*query).system != 0 {
			let mut dst_count: int32_t = ecs_vector_count(dst_array);
			if active {
				if dst_count == 1 as libc::c_int {
					ecs_system_activate(
						world,
						(*query).system,
						1 as libc::c_int != 0,
						0 as *const EcsSystem,
					);
				}
			} else if src_count == 0 as libc::c_int {
				ecs_system_activate(
					world,
					(*query).system,
					0 as libc::c_int != 0,
					0 as *const EcsSystem,
				);
			}
		}
	}
	if activated == 0 {
		/* Received an activate event for a table we're not matched with. This
		 * can only happen if this is a subquery */
		return;
	}
	order_ranked_tables(world, query);
}
unsafe extern "C" fn add_subquery(
	mut world: *mut ecs_world_t,
	mut parent: *mut ecs_query_t,
	mut subquery: *mut ecs_query_t,
) {
	let mut elem: *mut *mut ecs_query_t = _ecs_vector_add(
		&mut (*parent).subqueries,
		::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_query_t;
	*elem = subquery;
	/* Iterate matched tables, match them with subquery */
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*parent).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*parent).tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_matched_table_t =
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		match_table(world, subquery, (*table).data.table);
		activate_table(world, subquery, (*table).data.table, 1 as libc::c_int != 0);
		i += 1
	}
	/* Do the same for inactive tables */
	tables = _ecs_vector_first(
		(*parent).empty_tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	count = ecs_vector_count((*parent).empty_tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table_0: *mut ecs_matched_table_t =
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t;
		match_table(world, subquery, (*table_0).data.table);
		i += 1
	}
}
unsafe extern "C" fn notify_subqueries(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut event: *mut ecs_query_event_t,
) {
	if !(*query).subqueries.is_null() {
		let mut queries: *mut *mut ecs_query_t = _ecs_vector_first(
			(*query).subqueries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_query_t;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*query).subqueries);
		let mut sub_event: ecs_query_event_t = *event;
		sub_event.parent_query = query;
		i = 0 as libc::c_int;
		while i < count {
			let mut sub: *mut ecs_query_t = *queries.offset(i as isize);
			ecs_query_notify(world, sub, &mut sub_event);
			i += 1
		}
	};
}
unsafe extern "C" fn free_matched_table(mut table: *mut ecs_matched_table_t) {
	ecs_os_api.free_.expect("non-null function pointer")(
		(*table).data.columns as *mut libc::c_void,
	);
	ecs_os_api.free_.expect("non-null function pointer")(
		(*table).data.components as *mut libc::c_void,
	);
	ecs_os_api.free_.expect("non-null function pointer")(
		(*table).data.types as *mut *mut ecs_vector_t as *mut libc::c_void,
	);
	ecs_os_api.free_.expect("non-null function pointer")(
		(*table).data.references as *mut libc::c_void,
	);
	ecs_os_api.free_.expect("non-null function pointer")(
		(*table).sparse_columns as *mut libc::c_void,
	);
	ecs_os_api.free_.expect("non-null function pointer")((*table).monitor as *mut libc::c_void);
}
/* Remove table */
unsafe extern "C" fn remove_table(mut tables: *mut ecs_vector_t, mut index: int32_t) {
	let mut table: *mut ecs_matched_table_t = _ecs_vector_get(
		tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		index,
	) as *mut ecs_matched_table_t;
	free_matched_table(table);
	_ecs_vector_remove_index(
		tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		index,
	);
}
unsafe extern "C" fn unmatch_table_w_index(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_table_t,
	mut match_0: int32_t,
) {
	/* If table no longer matches, remove it */
	if match_0 != -(1 as libc::c_int) {
		remove_table((*query).tables, match_0);
		notify_subqueries(world, query, &mut {
			let mut init = ecs_query_event_t {
				kind: EcsQueryTableUnmatch,
				table: table,
				parent_query: 0 as *mut ecs_query_t,
			};
			init
		});
	} else {
		/* Make sure the table is removed if it was inactive */
		match_0 = table_matched((*query).empty_tables, table);
		if match_0 != -(1 as libc::c_int) {
			remove_table((*query).empty_tables, match_0);
			notify_subqueries(world, query, &mut {
				let mut init = ecs_query_event_t {
					kind: EcsQueryTableUnmatch,
					table: table,
					parent_query: 0 as *mut ecs_query_t,
				};
				init
			});
		}
	};
}
unsafe extern "C" fn unmatch_table(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_table_t,
) {
	unmatch_table_w_index(world, query, table, table_matched((*query).tables, table));
}
unsafe extern "C" fn rematch_table(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut table: *mut ecs_table_t,
) {
	let mut match_0: int32_t = table_matched((*query).tables, table);
	if ecs_query_match(world, table, query, 0 as *mut ecs_match_failure_t) {
		/* If the table matches, and it is not currently matched, add */
		if match_0 == -(1 as libc::c_int) {
			if table_matched((*query).empty_tables, table) == -(1 as libc::c_int) {
				add_table(world, query, table);
			}
		/* If table still matches and has cascade column, reevaluate the
		 * sources of references. This may have changed in case
		 * components were added/removed to container entities */
		} else if (*query).cascade_by != 0 {
			resolve_cascade_container(world, query, match_0, (*table).type_0);
		/* If query has optional columns, it is possible that a column that
		 * previously had data no longer has data, or vice versa. Do a full
		 * rematch to make sure data is consistent. */
		} else if (*query).flags & 1024 as libc::c_int as libc::c_uint != 0 {
			unmatch_table(world, query, table);
			ecs_table_notify(world, table, &mut {
				let mut init = ecs_table_event_t {
					kind: EcsTableQueryUnmatch,
					query: query,
					matched_table_index: 0,
					component: 0,
				};
				init
			});
			add_table(world, query, table);
		}
	} else if match_0 != -(1 as libc::c_int) {
		unmatch_table(world, query, table);
		ecs_table_notify(world, table, &mut {
			let mut init = ecs_table_event_t {
				kind: EcsTableQueryUnmatch,
				query: query,
				matched_table_index: 0,
				component: 0,
			};
			init
		});
	};
}
/* Table no longer matches, remove */
/* Rematch system with tables after a change happened to a watched entity */
unsafe extern "C" fn rematch_tables(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut parent_query: *mut ecs_query_t,
) {
	if !parent_query.is_null() {
		let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
			(*query).tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_table_t;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*query).tables);
		i = 0 as libc::c_int;
		while i < count {
			let mut table: *mut ecs_table_t = (*tables.offset(i as isize)).data.table;
			rematch_table(world, query, table);
			i += 1
		}
		tables = _ecs_vector_first(
			(*query).empty_tables,
			::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_matched_table_t;
		count = ecs_vector_count((*query).empty_tables);
		i = 0 as libc::c_int;
		while i < count {
			let mut table_0: *mut ecs_table_t = (*tables.offset(i as isize)).data.table;
			rematch_table(world, query, table_0);
			i += 1
		}
	} else {
		let mut tables_0: *mut ecs_sparse_t = (*world).store.tables;
		let mut i_0: int32_t = 0;
		let mut count_0: int32_t = ecs_sparse_count(tables_0);
		i_0 = 0 as libc::c_int;
		while i_0 < count_0 {
			/* Is the system currently matched with the table? */
			let mut table_1: *mut ecs_table_t = _ecs_sparse_get(
				tables_0,
				::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
				i_0,
			) as *mut ecs_table_t;
			rematch_table(world, query, table_1);
			i_0 += 1
		}
	}
	group_tables(world, query);
	order_ranked_tables(world, query);
	/* Enable/disable system if constraints are (not) met. If the system is
	 * already dis/enabled this operation has no side effects. */
	if (*query).system != 0 {
		if ecs_sig_check_constraints(world, &mut (*query).sig) {
			ecs_remove_entity(
				world,
				(*query).system,
				(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
			);
		} else {
			ecs_add_entity(
				world,
				(*query).system,
				(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
			);
		}
	};
}
/* -- Private API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_notify(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut event: *mut ecs_query_event_t,
) {
	match (*event).kind as libc::c_uint {
		0 => {
			/* Creation of new table */
			match_table(world, query, (*event).table);
		}
		4 => {
			/* Deletion of table */
			unmatch_table(world, query, (*event).table);
		}
		3 => {
			/* Rematch tables of query */
			rematch_tables(world, query, (*event).parent_query);
		}
		1 => {
			/* Table is empty, deactivate */
			activate_table(world, query, (*event).table, 0 as libc::c_int != 0);
		}
		2 => {
			/* Table is non-empty, activate */
			activate_table(world, query, (*event).table, 1 as libc::c_int != 0);
		}
		_ => {}
	}
	notify_subqueries(world, query, event);
}
/* -- Public API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_new_w_sig_intern(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut sig: *mut ecs_sig_t,
	mut is_subquery: bool,
) -> *mut ecs_query_t {
	let mut result: *mut ecs_query_t = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_query_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_query_t;
	(*result).world = world;
	(*result).sig = *sig;
	(*result).tables = _ecs_vector_new(
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		0 as libc::c_int,
	);
	(*result).empty_tables = _ecs_vector_new(
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		0 as libc::c_int,
	);
	(*result).system = system;
	(*result).prev_match_count = -(1 as libc::c_int);
	process_signature(world, result);
	ecs_log_push();
	if !is_subquery {
		/* Register query with world */
		let mut elem: *mut *mut ecs_query_t = _ecs_vector_add(
			&mut (*world).queries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_query_t;
		*elem = result;
		if (*result).flags & 1 as libc::c_int as libc::c_uint != 0 {
			if ecs_has_entity(
				world,
				system,
				(256 as libc::c_int + 7 as libc::c_int) as ecs_entity_t,
			) {
				(*result).flags |= 2 as libc::c_int as libc::c_uint
			}
			if ecs_has_entity(
				world,
				system,
				(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
			) {
				(*result).flags |= 4 as libc::c_int as libc::c_uint
			}
			if ecs_has_entity(
				world,
				system,
				(256 as libc::c_int + 12 as libc::c_int) as ecs_entity_t,
			) {
				(*result).flags |= 8 as libc::c_int as libc::c_uint
			}
			match_tables(world, result);
		} else {
			/* Add stub table that resolves references (if any) so everything is
			 * preprocessed when the query is evaluated. */
			add_table(world, result, 0 as *mut ecs_table_t);
		}
	} else {
		(*result).flags |= 256 as libc::c_int as libc::c_uint
	}
	if (*result).cascade_by != 0 {
		(*result).group_table = Some(
			rank_by_depth
				as unsafe extern "C" fn(
					_: *mut ecs_world_t,
					_: ecs_entity_t,
					_: ecs_type_t,
				) -> int32_t,
		)
	}
	ecs_log_pop();
	/* Make sure application can't try to free sig resources */
	*sig = {
		let mut init = ecs_sig_t {
			name: 0 as *const libc::c_char,
			expr: 0 as *mut libc::c_char,
			columns: 0 as *mut ecs_vector_t,
		};
		init
	};
	return result;
}
/* * Create query based on signature object. */
// //////////////////////////////////////////////////////////////////////////////
// // Query API
// //////////////////////////////////////////////////////////////////////////////
#[no_mangle]
pub unsafe extern "C" fn ecs_query_new_w_sig(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut sig: *mut ecs_sig_t,
) -> *mut ecs_query_t {
	return ecs_query_new_w_sig_intern(world, system, sig, 0 as libc::c_int != 0);
}
/* * @} */
/* *
 * @defgroup queries Queries
 * @{
 */
/* * Create a query.
 * This operation creates a query. Queries are used to iterate over entities
 * that match a signature expression.
 *
 * Queries are 'persistent' meaning they are registered with
 * the world and continuously matched with new entities (tables). Queries
 * are the fastest way to iterate over entities, as a lot of processing is
 * done when entities are matched, outside of the main loop.
 *
 * Queries are the mechanism used by systems, and as such both accept the
 * same signature expressions, and have similar performance.
 *
 * Queries, like systems, iterate over component data from the main stage.
 * This means that when an application is iterating a query outside of a system,
 * care must be taken when adding/removing components or creating/deleting
 * entities, as this may corrupt the iteration.
 *
 * When a query is iterated over inside a system normal staging applies, and an
 * application can safely update entities.
 *
 * @param world The world.
 * @param sig The query signature expression.
 * @return The new query.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_new(
	mut world: *mut ecs_world_t,
	mut expr: *const libc::c_char,
) -> *mut ecs_query_t {
	let mut sig: ecs_sig_t = {
		let mut init = ecs_sig_t {
			name: 0 as *const libc::c_char,
			expr: 0 as *mut libc::c_char,
			columns: 0 as *mut ecs_vector_t,
		};
		init
	};
	ecs_sig_init(world, 0 as *const libc::c_char, expr, &mut sig);
	return ecs_query_new_w_sig(world, 0 as libc::c_int as ecs_entity_t, &mut sig);
}
/* * Create a subquery.
 * A subquery is just like a regular query, except that it is matched against
 * the matched tables of a parent query. Reducing the number of global (normal)
 * queries can improve performance, as new archetypes have to be matched against
 * fewer queries.
 *
 * Subqueries are cheaper to create than regular queries, because the initial
 * set of tables they have to match against is smaller. This makes subqueries
 * more suitable for creating while the simulation.
 *
 * Subqueries are not registered with tables directly, and instead receive new
 * table notifications from their parent query. This means that there is less
 * administrative overhead associated with subqueries.
 *
 * Subqueries can be nested, which allows for the creation of increasingly more
 * specific query hierarchies that are considerably more efficient than when all
 * queries would be created as global queries.
 *
 * @param world The world.
 * @param parent The parent query.
 * @param sig The query signature expression.
 * @return The new subquery.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_subquery_new(
	mut world: *mut ecs_world_t,
	mut parent: *mut ecs_query_t,
	mut expr: *const libc::c_char,
) -> *mut ecs_query_t {
	let mut sig: ecs_sig_t = {
		let mut init = ecs_sig_t {
			name: 0 as *const libc::c_char,
			expr: 0 as *mut libc::c_char,
			columns: 0 as *mut ecs_vector_t,
		};
		init
	};
	ecs_sig_init(world, 0 as *const libc::c_char, expr, &mut sig);
	let mut result: *mut ecs_query_t = ecs_query_new_w_sig_intern(
		world,
		0 as libc::c_int as ecs_entity_t,
		&mut sig,
		1 as libc::c_int != 0,
	);
	add_subquery(world, parent, result);
	return result;
}
/* * Cleanup a query.
 * This operation frees a query.
 *
 * @param query The query.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_free(mut query: *mut ecs_query_t) {
	let mut world: *mut ecs_world_t = (*query).world;
	let mut table_i: libc::c_int = 0;
	let mut table_count: libc::c_int = ecs_vector_count((*query).empty_tables);
	let mut table_array: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).empty_tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	table_i = 0 as libc::c_int;
	while table_i < table_count {
		let mut table: *mut ecs_matched_table_t =
			&mut *table_array.offset(table_i as isize) as *mut ecs_matched_table_t;
		free_matched_table(table);
		table_i += 1
	}
	let mut table_i_0: libc::c_int = 0;
	let mut table_count_0: libc::c_int = ecs_vector_count((*query).tables);
	let mut table_array_0: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	table_i_0 = 0 as libc::c_int;
	while table_i_0 < table_count_0 {
		let mut table_0: *mut ecs_matched_table_t =
			&mut *table_array_0.offset(table_i_0 as isize) as *mut ecs_matched_table_t;
		free_matched_table(table_0);
		table_i_0 += 1
	}
	ecs_vector_free((*query).subqueries);
	ecs_vector_free((*query).tables);
	ecs_vector_free((*query).empty_tables);
	ecs_vector_free((*query).table_slices);
	ecs_sig_deinit(&mut (*query).sig);
	/* Find query in vector */
	if (*query).flags & 256 as libc::c_int as libc::c_uint == 0 && !(*world).queries.is_null() {
		let mut index: int32_t = -(1 as libc::c_int);
		let mut q_ptr_i: libc::c_int = 0;
		let mut q_ptr_count: libc::c_int = ecs_vector_count((*world).queries);
		let mut q_ptr_array: *mut *mut ecs_query_t = _ecs_vector_first(
			(*world).queries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_query_t;
		q_ptr_i = 0 as libc::c_int;
		while q_ptr_i < q_ptr_count {
			let mut q_ptr: *mut *mut ecs_query_t =
				&mut *q_ptr_array.offset(q_ptr_i as isize) as *mut *mut ecs_query_t;
			if *q_ptr == query {
				index = q_ptr_i
			}
			q_ptr_i += 1
		}
		_ecs_vector_remove_index(
			(*world).queries,
			::std::mem::size_of::<*mut ecs_query_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_query_t>() as libc::c_ulong as int64_t
			} as int16_t,
			index,
		);
	}
	ecs_os_api.free_.expect("non-null function pointer")(query as *mut libc::c_void);
}
/* * Iterate over a query.
 * This operation is similar to ecs_query_iter, but starts iterating from a
 * specified offset, and will not iterate more than limit entities.
 *
 * @param query The query to iterate.
 * @param offset The number of entities to skip.
 * @param limit The maximum number of entities to iterate.
 * @return The query iterator.
 */
/* Create query iterator */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_iter_page(
	mut query: *mut ecs_query_t,
	mut offset: int32_t,
	mut limit: int32_t,
) -> ecs_iter_t {
	sort_tables((*query).world, query);
	tables_reset_dirty(query);
	let mut table_count: int32_t = 0;
	if !(*query).table_slices.is_null() {
		table_count = ecs_vector_count((*query).table_slices)
	} else {
		table_count = ecs_vector_count((*query).tables)
	}
	let mut it: ecs_query_iter_t = {
		let mut init = ecs_query_iter_t {
			query: query,
			page_iter: {
				let mut init = ecs_page_iter_t {
					offset: offset,
					limit: limit,
					remaining: limit,
				};
				init
			},
			index: 0 as libc::c_int,
			sparse_smallest: 0,
			sparse_first: 0,
		};
		init
	};
	return {
		let mut init = ecs_iter_t {
			world: (*query).world,
			system: 0,
			table: 0 as *mut ecs_iter_table_t,
			query: query,
			table_count: table_count,
			inactive_table_count: ecs_vector_count((*query).empty_tables),
			column_count: ecs_vector_count((*query).sig.columns),
			table_columns: 0 as *mut libc::c_void,
			entities: 0 as *mut ecs_entity_t,
			param: 0 as *mut libc::c_void,
			delta_time: 0.,
			delta_system_time: 0.,
			world_time: 0.,
			frame_offset: 0,
			table_offset: 0,
			offset: 0,
			count: 0,
			total_count: 0,
			triggered_by: 0 as *mut ecs_entities_t,
			interrupted_by: 0,
			iter: C2RustUnnamed { query: it },
		};
		init
	};
}
/* * Return a query iterator.
 * A query iterator lets an application iterate over entities that match the
 * specified query. If a sorting function is specified, the query will check
 * whether a resort is required upon creating the iterator.
 *
 * @param query The query to iterate.
 * @return The query iterator.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_iter(mut query: *mut ecs_query_t) -> ecs_iter_t {
	return ecs_query_iter_page(query, 0 as libc::c_int, 0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_query_set_iter(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut it: *mut ecs_iter_t,
	mut table_index: int32_t,
	mut row: int32_t,
	mut count: int32_t,
) {
	let mut table_data: *mut ecs_matched_table_t = _ecs_vector_get(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		table_index,
	) as *mut ecs_matched_table_t;
	let mut table: *mut ecs_table_t = (*table_data).data.table;
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	let mut entity_buffer: *mut ecs_entity_t = _ecs_vector_first(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	(*it).entities = &mut *entity_buffer.offset(row as isize) as *mut ecs_entity_t;
	(*it).world = world;
	(*it).query = query;
	(*it).column_count = ecs_vector_count((*query).sig.columns);
	(*it).table_count = 1 as libc::c_int;
	(*it).inactive_table_count = 0 as libc::c_int;
	(*it).table_columns = (*data).columns as *mut libc::c_void;
	(*it).table = &mut (*table_data).data;
	(*it).offset = row;
	(*it).count = count;
	(*it).total_count = count;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_page_iter_next(
	mut it: *mut ecs_page_iter_t,
	mut cur: *mut ecs_page_cursor_t,
) -> libc::c_int {
	let mut offset: int32_t = (*it).offset;
	let mut limit: int32_t = (*it).limit;
	if !(offset != 0 || limit != 0) {
		return ((*cur).count == 0 as libc::c_int) as libc::c_int;
	}
	let mut count: int32_t = (*cur).count;
	let mut remaining: int32_t = (*it).remaining;
	if offset != 0 {
		if offset > count {
			/* No entities to iterate in current table */
			(*it).offset -= count;
			return 1 as libc::c_int;
		} else {
			(*cur).first += offset;
			(*cur).count -= offset;
			count = (*cur).count;
			(*it).offset = 0 as libc::c_int
		}
	}
	if remaining != 0 {
		if remaining > count {
			(*it).remaining -= count
		} else {
			(*cur).count = remaining;
			count = (*cur).count;
			(*it).remaining = 0 as libc::c_int
		}
	} else if limit != 0 {
		/* Limit hit: no more entities left to iterate */
		return -(1 as libc::c_int);
	}
	return (count == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn find_smallest_column(
	mut table: *mut ecs_table_t,
	mut table_data: *mut ecs_matched_table_t,
	mut sparse_columns: *mut ecs_vector_t,
) -> libc::c_int {
	let mut sparse_column_array: *mut ecs_sparse_column_t = _ecs_vector_first(
		sparse_columns,
		::std::mem::size_of::<ecs_sparse_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sparse_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sparse_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sparse_column_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(sparse_columns);
	let mut min: int32_t = 2147483647 as libc::c_int;
	let mut index: int32_t = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		/* The array with sparse queries for the matched table */
		let mut sparse_column: *mut ecs_sparse_column_t =
			&mut *sparse_column_array.offset(i as isize) as *mut ecs_sparse_column_t;
		/* Pointer to the switch column struct of the table */
		let mut sc: *mut ecs_sw_column_t = (*sparse_column).sw_column;
		/* If the sparse column pointer hadn't been retrieved yet, do it now */
		if sc.is_null() {
			/* Get the table column index from the signature column index */
			let mut table_column_index: int32_t = *(*table_data)
				.data
				.columns
				.offset((*sparse_column).signature_column_index as isize);
			/* Translate the table column index to switch column index */
			table_column_index -= (*table).sw_column_offset;
			/* Get the sparse column */
			let mut data: *mut ecs_data_t = ecs_table_get_data(table);
			(*sparse_column).sw_column = &mut *(*data)
				.sw_columns
				.offset((table_column_index - 1 as libc::c_int) as isize)
				as *mut ecs_sw_column_t;
			sc = (*sparse_column).sw_column
		}
		/* Find the smallest column */
		let mut sw: *mut ecs_switch_t = (*sc).data;
		let mut case_count: int32_t = ecs_switch_case_count(sw, (*sparse_column).sw_case);
		if case_count < min {
			min = case_count;
			index = i + 1 as libc::c_int
		}
		i += 1
	}
	return index;
}
unsafe extern "C" fn sparse_column_next(
	mut table: *mut ecs_table_t,
	mut matched_table: *mut ecs_matched_table_t,
	mut sparse_columns: *mut ecs_vector_t,
	mut iter: *mut ecs_query_iter_t,
	mut cur: *mut ecs_page_cursor_t,
) -> libc::c_int {
	let mut i: int32_t = 0;
	let mut count: int32_t = 0;
	let mut current_block: u64;
	let mut first_iteration: bool = 0 as libc::c_int != 0;
	let mut sparse_smallest: int32_t = 0;
	sparse_smallest = (*iter).sparse_smallest;
	if sparse_smallest == 0 {
		(*iter).sparse_smallest = find_smallest_column(table, matched_table, sparse_columns);
		sparse_smallest = (*iter).sparse_smallest;
		first_iteration = 1 as libc::c_int != 0
	}
	sparse_smallest -= 1 as libc::c_int;
	let mut columns: *mut ecs_sparse_column_t = _ecs_vector_first(
		sparse_columns,
		::std::mem::size_of::<ecs_sparse_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sparse_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sparse_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sparse_column_t;
	let mut column: *mut ecs_sparse_column_t =
		&mut *columns.offset(sparse_smallest as isize) as *mut ecs_sparse_column_t;
	let mut sw: *mut ecs_switch_t = 0 as *mut ecs_switch_t;
	let mut sw_smallest: *mut ecs_switch_t = (*(*column).sw_column).data;
	let mut case_smallest: ecs_entity_t = (*column).sw_case;
	/* Find next entity to iterate in sparse column */
	let mut first: int32_t = 0;
	if first_iteration {
		first = ecs_switch_first(sw_smallest, case_smallest)
	} else {
		first = ecs_switch_next(sw_smallest, (*iter).sparse_first)
	}
	if !(first == -(1 as libc::c_int)) {
		/* Check if entity matches with other sparse columns, if any */
		i = 0;
		count = ecs_vector_count(sparse_columns);
		's_85: loop {
			i = 0 as libc::c_int;
			while i < count {
				if !(i == sparse_smallest) {
					column = &mut *columns.offset(i as isize) as *mut ecs_sparse_column_t;
					sw = (*(*column).sw_column).data;
					if ecs_switch_get(sw, first) != (*column).sw_case {
						first = ecs_switch_next(sw_smallest, first);
						if first == -(1 as libc::c_int) {
							current_block = 6231240541381614269;
							break 's_85;
						}
					}
				}
				/* Already validated this one */
				i += 1
			}
			if !(i != count) {
				current_block = 15925075030174552612;
				break;
			}
		}
		match current_block {
			6231240541381614269 => {}
			_ => {
				(*iter).sparse_first = first;
				(*cur).first = (*iter).sparse_first;
				(*cur).count = 1 as libc::c_int;
				return 0 as libc::c_int;
			}
		}
	}
	/* Iterated all elements in the sparse list, we should move to the
	 * next matched table. */
	(*iter).sparse_smallest = 0 as libc::c_int;
	(*iter).sparse_first = 0 as libc::c_int;
	return -(1 as libc::c_int);
}
unsafe extern "C" fn mark_columns_dirty(
	mut query: *mut ecs_query_t,
	mut table_data: *mut ecs_matched_table_t,
) {
	let mut table: *mut ecs_table_t = (*table_data).data.table;
	if !table.is_null() && !(*table).dirty_state.is_null() {
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*query).sig.columns);
		let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
			(*query).sig.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		i = 0 as libc::c_int;
		while i < count {
			if (*columns.offset(i as isize)).inout_kind as libc::c_uint
				!= EcsIn as libc::c_int as libc::c_uint
			{
				let mut table_column: int32_t = *(*table_data).data.columns.offset(i as isize);
				if table_column > 0 as libc::c_int {
					let ref mut fresh36 = *(*table).dirty_state.offset(table_column as isize);
					*fresh36 += 1
				}
			}
			i += 1
		}
	};
}
/* * Progress the query iterator.
 * This operation progresses the query iterator to the next table. The
 * iterator must have been initialized with `ecs_query_iter`. This operation
 * must be invoked at least once before interpreting the contents of the
 * iterator.
 *
 * @param iter The iterator.
 * @returns True if more data is available, false if not.
 */
/* Return next table */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_next(mut it: *mut ecs_iter_t) -> bool {
	let mut iter: *mut ecs_query_iter_t = &mut (*it).iter.query;
	let mut piter: *mut ecs_page_iter_t = &mut (*iter).page_iter;
	let mut world: *mut ecs_world_t = (*it).world;
	let mut query: *mut ecs_query_t = (*iter).query;
	ecs_get_stage(&mut world);
	let mut slice: *mut ecs_table_slice_t = _ecs_vector_first(
		(*query).table_slices,
		::std::mem::size_of::<ecs_table_slice_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_table_slice_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_table_slice_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_table_slice_t;
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut cur: ecs_page_cursor_t = ecs_page_cursor_t { first: 0, count: 0 };
	let mut table_count: int32_t = (*it).table_count;
	let mut prev_count: int32_t = (*it).total_count;
	let mut i: libc::c_int = 0;
	let mut current_block_30: u64;
	i = (*iter).index;
	while i < table_count {
		let mut table_data: *mut ecs_matched_table_t = if !slice.is_null() {
			(*slice.offset(i as isize)).table
		} else {
			&mut *tables.offset(i as isize) as *mut ecs_matched_table_t
		};
		let mut table: *mut ecs_table_t = (*table_data).data.table;
		let mut data: *mut ecs_data_t = 0 as *mut ecs_data_t;
		(*iter).index = i + 1 as libc::c_int;
		if !table.is_null() {
			let mut sparse_columns: *mut ecs_vector_t = (*table_data).sparse_columns;
			data = ecs_table_get_data(table);
			(*it).table_columns = (*data).columns as *mut libc::c_void;
			if !slice.is_null() {
				cur.first = (*slice.offset(i as isize)).start_row;
				cur.count = (*slice.offset(i as isize)).count
			} else {
				cur.first = 0 as libc::c_int;
				cur.count = ecs_table_count(table)
			}
			if cur.count != 0 {
				if !sparse_columns.is_null() {
					if sparse_column_next(table, table_data, sparse_columns, iter, &mut cur)
						== -(1 as libc::c_int)
					{
						current_block_30 = 3276175668257526147;
					} else {
						(*iter).index = i;
						current_block_30 = 16924917904204750491;
					}
				} else {
					current_block_30 = 16924917904204750491;
				}
				match current_block_30 {
					3276175668257526147 => {}
					_ => {
						let mut ret: libc::c_int = ecs_page_iter_next(piter, &mut cur);
						if ret < 0 as libc::c_int {
							return 0 as libc::c_int != 0;
						} else if ret > 0 as libc::c_int {
							current_block_30 = 3276175668257526147;
						} else {
							let mut entity_buffer: *mut ecs_entity_t = _ecs_vector_first(
								(*data).entities,
								::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong
									as ecs_size_t,
								if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong
									as ecs_size_t as libc::c_long > ::std::mem::align_of::<
									ecs_entity_t,
								>() as libc::c_ulong as int64_t
								{
									::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong
										as ecs_size_t as libc::c_long
								} else {
									::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
										as int64_t
								} as int16_t,
							) as *mut ecs_entity_t;
							(*it).entities =
								&mut *entity_buffer.offset(cur.first as isize) as *mut ecs_entity_t;
							(*it).offset = cur.first;
							(*it).count = cur.count;
							(*it).total_count = cur.count;
							current_block_30 = 11743904203796629665;
						}
					}
				}
			} else {
				current_block_30 = 3276175668257526147;
			}
			match current_block_30 {
				11743904203796629665 => {}
				_ =>
				/* No more elements in sparse column */
				{
					i += 1;
					continue;
				}
			}
		}
		(*it).table = &mut (*table_data).data;
		(*it).frame_offset += prev_count;
		if (*query).flags & 512 as libc::c_int as libc::c_uint != 0 {
			if !table.is_null() {
				mark_columns_dirty(query, table_data);
			}
		}
		return 1 as libc::c_int != 0;
	}
	return 0 as libc::c_int != 0;
}
/* * Progress the query iterator with filter.
 * This operation is the same as ecs_query_next, but accepts a filter as an
 * argument. Entities not matching the filter will be skipped by the iterator.
 *
 * @param iter The iterator.
 * @param filter The filter to apply to the iterator.
 * @returns True if more data is available, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_next_w_filter(
	mut iter: *mut ecs_iter_t,
	mut filter: *const ecs_filter_t,
) -> bool {
	let mut table: *mut ecs_table_t = 0 as *mut ecs_table_t;
	loop {
		if !ecs_query_next(iter) {
			return 0 as libc::c_int != 0;
		}
		table = (*(*iter).table).table;
		if !(!filter.is_null() && !ecs_table_match_filter((*iter).world, table, filter)) {
			break;
		}
	}
	return 1 as libc::c_int != 0;
}
/* * Progress the query iterator for a worker thread.
 * This operation is similar to ecs_query_next, but provides the ability to
 * divide entities up across multiple worker threads. The operation accepts a
 * current thread id and a total thread id, which is used to determine which
 * subset of entities should be assigned to the current thread.
 *
 * Current should be less than total, and there should be as many as total
 * threads. If there are less entities in a table than there are threads, only
 * as many threads as there are entities will iterate that table.
 *
 * @param it The iterator.
 * @param current Thread id of current thread.
 * @param total Total number of threads.
 * @returns True if more data is available, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_next_worker(
	mut it: *mut ecs_iter_t,
	mut current: int32_t,
	mut total: int32_t,
) -> bool {
	let mut per_worker: int32_t = 0;
	let mut first: int32_t = 0;
	let mut prev_offset: int32_t = (*it).offset;
	loop {
		if !ecs_query_next(it) {
			return 0 as libc::c_int != 0;
		}
		let mut count: int32_t = (*it).count;
		per_worker = count / total;
		first = per_worker * current;
		count -= per_worker * total;
		if count != 0 {
			if current < count {
				per_worker += 1;
				first += current
			} else {
				first += count
			}
		}
		if per_worker == 0 && (*(*it).query).flags & 1 as libc::c_int as libc::c_uint == 0 {
			if current == 0 as libc::c_int {
				return 1 as libc::c_int != 0;
			} else {
				return 0 as libc::c_int != 0;
			}
		}
		if !(per_worker == 0) {
			break;
		}
	}
	(*it).frame_offset -= prev_offset;
	(*it).count = per_worker;
	(*it).offset += first;
	(*it).entities = &mut *(*it).entities.offset(first as isize) as *mut ecs_entity_t;
	(*it).frame_offset += first;
	return 1 as libc::c_int != 0;
}
/* * Sort the output of a query.
 * This enables sorting of entities across matched tables. As a result of this
 * operation, the order of entities in the matched tables may be changed.
 * Resorting happens when a query iterator is obtained, and only if the table
 * data has changed.
 *
 * If multiple queries that match the same (sub)set of tables specify different
 * sorting functions, resorting is likely to happen every time an iterator is
 * obtained, which can significantly slow down iterations.
 *
 * The sorting function will be applied to the specified component. Resorting
 * only happens if that component has changed, or when the entity order in the
 * table has changed. If no component is provided, resorting only happens when
 * the entity order changes.
 *
 * @param world The world.
 * @param query The query.
 * @param component The component used to sort.
 * @param compare The compare function used to sort the components.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_order_by(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut sort_component: ecs_entity_t,
	mut compare: ecs_compare_action_t,
) {
	(*query).sort_on_component = sort_component;
	(*query).compare = compare;
	ecs_vector_free((*query).table_slices);
	(*query).table_slices = 0 as *mut ecs_vector_t;
	sort_tables(world, query);
	if (*query).table_slices.is_null() {
		build_sorted_tables(query);
	};
}
/* * Group and sort matched tables.
 * Similar yo ecs_query_order_by, but instead of sorting individual entities, this
 * operation only sorts matched tables. This can be useful of a query needs to
 * enforce a certain iteration order upon the tables it is iterating, for
 * example by giving a certain component or tag a higher priority.
 *
 * The sorting function assigns a "rank" to each type, which is then used to
 * sort the tables. Tables with higher ranks will appear later in the iteration.
 *
 * Resorting happens when a query iterator is obtained, and only if the set of
 * matched tables for a query has changed. If table sorting is enabled together
 * with entity sorting, table sorting takes precedence, and entities will be
 * sorted within each set of tables that are assigned the same rank.
 *
 * @param world The world.
 * @param query The query.
 * @param component The component used to determine the group rank.
 * @param rank_action The rank action.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_group_by(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut sort_component: ecs_entity_t,
	mut group_table_action: ecs_rank_type_action_t,
) {
	(*query).rank_on_component = sort_component;
	(*query).group_table = group_table_action;
	group_tables(world, query);
	order_ranked_tables(world, query);
	build_sorted_tables(query);
}
/* * Returns whether the query data changed since the last iteration.
 * This operation must be invoked before obtaining the iterator, as this will
 * reset the changed state. The operation will return true after:
 * - new entities have been matched with
 * - matched entities were deleted
 * - matched components were changed
 *
 * @param query The query.
 * @return true if entities changed, otherwise false.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_query_changed(mut query: *mut ecs_query_t) -> bool {
	return tables_dirty(query);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_component_id_from_id(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
) -> ecs_entity_t {
	if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		let mut trait_0: ecs_entity_t = ((e & !((0xff as libc::c_int as ecs_entity_t)
			<< 56 as libc::c_int))
			>> 32 as libc::c_int) as uint32_t as ecs_entity_t;
		if ecs_has_type(world, trait_0, FLECS__TEcsComponent) {
			/* This is not a trait tag, trait is the value */
			return trait_0;
		} else {
			/* This is a trait tag, component is the value */
			return e as uint32_t as ecs_entity_t;
		}
	} else {
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int != 0 {
			return 0 as libc::c_int as ecs_entity_t;
		}
	}
	return e;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_component_from_id(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
) -> *const EcsComponent {
	let mut trait_0: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	/* If this is a trait, get the trait component from the identifier */
	if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7c as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		trait_0 = e;
		e = e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
		e = (e >> 32 as libc::c_int) as uint32_t as ecs_entity_t
	}
	let mut component: *const EcsComponent =
		ecs_get_w_entity(world, e, 1 as libc::c_int as ecs_entity_t) as *const EcsComponent;
	if component.is_null() && trait_0 != 0 {
		/* If this is a trait column and the trait is not a component, use
		 * the component type of the component the trait is applied to. */
		e = trait_0 as uint32_t as ecs_entity_t;
		component =
			ecs_get_w_entity(world, e, 1 as libc::c_int as ecs_entity_t) as *const EcsComponent
	}
	return component;
}
/* Count number of columns with data (excluding tags) */
unsafe extern "C" fn data_column_count(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
) -> int32_t {
	let mut count: int32_t = 0 as libc::c_int;
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count((*table).type_0);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		(*table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		let mut component: ecs_entity_t = *c_ptr;
		/* Typically all components will be clustered together at the start of
		 * the type as components are created from a separate id pool, and type
		 * vectors are sorted.
		 * Explicitly check for EcsComponent and EcsName since the ecs_has check
		 * doesn't work during bootstrap. */
		if component == 1 as libc::c_int as libc::c_ulong
			|| component == 6 as libc::c_int as libc::c_ulong
			|| !ecs_component_from_id(world, component).is_null()
		{
			count = c_ptr_i + 1 as libc::c_int
		}
		c_ptr_i += 1
	}
	return count;
}
/* Count number of switch columns */
unsafe extern "C" fn switch_column_count(mut table: *mut ecs_table_t) -> int32_t {
	let mut count: int32_t = 0 as libc::c_int;
	let mut c_ptr_i: libc::c_int = 0;
	let mut c_ptr_count: libc::c_int = ecs_vector_count((*table).type_0);
	let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
		(*table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	c_ptr_i = 0 as libc::c_int;
	while c_ptr_i < c_ptr_count {
		let mut c_ptr: *mut ecs_entity_t =
			&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
		let mut component: ecs_entity_t = *c_ptr;
		if component & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			if count == 0 {
				(*table).sw_column_offset = c_ptr_i
			}
			count += 1
		}
		c_ptr_i += 1
	}
	return count;
}
unsafe extern "C" fn entities_to_type(mut entities: *mut ecs_entities_t) -> ecs_type_t {
	if (*entities).count != 0 {
		let mut result: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
		_ecs_vector_set_count(
			&mut result,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
			(*entities).count,
		);
		let mut array: *mut ecs_entity_t = _ecs_vector_first(
			result,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		memcpy(
			array as *mut libc::c_void,
			(*entities).array as *const libc::c_void,
			(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t
				* (*entities).count) as size_t,
		);
		return result as ecs_type_t;
	} else {
		return 0 as ecs_type_t;
	};
}
unsafe extern "C" fn register_child_table(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut parent: ecs_entity_t,
) {
	/* Register child table with parent */
	let mut child_tables: *mut ecs_vector_t =
		_ecs_map_get_ptr((*world).child_tables, parent) as *mut ecs_vector_t;
	if child_tables.is_null() {
		child_tables = _ecs_vector_new(
			::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
			1 as libc::c_int,
		)
	}
	let mut el: *mut *mut ecs_table_t = _ecs_vector_add(
		&mut child_tables,
		::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_table_t;
	*el = table;
	if (*world).child_tables.is_null() {
		(*world).child_tables = _ecs_map_new(
			::std::mem::size_of::<*mut ecs_vector_t>() as libc::c_ulong as ecs_size_t,
			::std::mem::align_of::<*mut ecs_vector_t>() as libc::c_ulong as int64_t as ecs_size_t,
			1 as libc::c_int,
		)
	}
	_ecs_map_set(
		(*world).child_tables,
		::std::mem::size_of::<*mut ecs_vector_t>() as libc::c_ulong as ecs_size_t,
		parent,
		&mut child_tables as *mut *mut ecs_vector_t as *const libc::c_void,
	);
}
unsafe extern "C" fn init_edges(mut world: *mut ecs_world_t, mut table: *mut ecs_table_t) {
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		(*table).type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut count: int32_t = ecs_vector_count((*table).type_0);
	(*table).lo_edges = ecs_os_api.calloc_.expect("non-null function pointer")(
		(::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong)
			.wrapping_mul(256 as libc::c_int as libc::c_ulong) as ecs_size_t,
	) as *mut ecs_edge_t;
	(*table).hi_edges = _ecs_map_new(
		::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<ecs_edge_t>() as libc::c_ulong as int64_t as ecs_size_t,
		0 as libc::c_int,
	);
	let ref mut fresh37 = (*(*table).lo_edges.offset(0 as libc::c_int as isize)).add;
	*fresh37 = table;
	/* Make add edges to own components point to self */
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		if e >= 256 as libc::c_int as libc::c_ulong {
			let mut edge: ecs_edge_t = {
				let mut init = ecs_edge_t {
					add: table,
					remove: 0 as *mut ecs_table_t,
				};
				init
			};
			if count == 1 as libc::c_int {
				edge.remove = &mut (*world).store.root
			}
			_ecs_map_set(
				(*table).hi_edges,
				::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t,
				e,
				&mut edge as *mut ecs_edge_t as *const libc::c_void,
			);
		} else {
			let ref mut fresh38 = (*(*table).lo_edges.offset(e as isize)).add;
			*fresh38 = table;
			if count == 1 as libc::c_int {
				let ref mut fresh39 = (*(*table).lo_edges.offset(e as isize)).remove;
				*fresh39 = &mut (*world).store.root
			} else {
				let ref mut fresh40 = (*(*table).lo_edges.offset(e as isize)).remove;
				*fresh40 = 0 as *mut ecs_table_t
			}
		}
		/* As we're iterating over the table components, also set the table
		 * flags. These allow us to quickly determine if the table contains
		 * data that needs to be handled in a special way, like prefabs or
		 * containers */
		if e <= 5 as libc::c_int as libc::c_ulong {
			(*table).flags |= 1 as libc::c_uint
		}
		if e == (256 as libc::c_int + 1 as libc::c_int) as libc::c_ulong {
			(*table).flags |= 2 as libc::c_uint;
			(*table).flags |= 64 as libc::c_uint
		}
		if e == (256 as libc::c_int + 3 as libc::c_int) as libc::c_ulong {
			(*table).flags |= 64 as libc::c_uint
		}
		if e == 1 as libc::c_int as libc::c_ulong {
			(*table).flags |= 16 as libc::c_uint
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x79 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			(*table).flags |= 32 as libc::c_uint
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			(*table).flags |= 4 as libc::c_uint
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x76 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			(*table).flags |= 65536 as libc::c_uint
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			let mut parent: ecs_entity_t =
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			(*table).flags |= 8 as libc::c_uint;
			register_child_table(world, table, parent);
		}
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			|| e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			ecs_set_watch(
				world,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
			);
		}
		i += 1
	}
	/* Register component info flags for all columns */
	ecs_table_notify(world, table, &mut {
		let mut init = ecs_table_event_t {
			kind: EcsTableComponentInfo,
			query: 0 as *mut ecs_query_t,
			matched_table_index: 0,
			component: 0,
		};
		init
	});
	/* Register as root table */
	if (*table).flags & 8 as libc::c_uint == 0 {
		register_child_table(world, table, 0 as libc::c_int as ecs_entity_t);
	};
}
unsafe extern "C" fn init_table(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut entities: *mut ecs_entities_t,
) {
	(*table).type_0 = entities_to_type(entities);
	(*table).c_info = 0 as *mut *mut ecs_c_info_t;
	(*table).data = 0 as *mut ecs_data_t;
	(*table).flags = 0 as libc::c_int as ecs_flags32_t;
	(*table).dirty_state = 0 as *mut int32_t;
	(*table).monitors = 0 as *mut ecs_vector_t;
	(*table).on_set = 0 as *mut *mut ecs_vector_t;
	(*table).on_set_all = 0 as *mut ecs_vector_t;
	(*table).on_set_override = 0 as *mut ecs_vector_t;
	(*table).un_set_all = 0 as *mut ecs_vector_t;
	(*table).alloc_count = 0 as libc::c_int;
	(*table).queries = 0 as *mut ecs_vector_t;
	(*table).column_count = data_column_count(world, table);
	(*table).sw_column_count = switch_column_count(table);
	init_edges(world, table);
}
unsafe extern "C" fn create_table(
	mut world: *mut ecs_world_t,
	mut entities: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	let mut result: *mut ecs_table_t = _ecs_sparse_add(
		(*world).store.tables,
		::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_table_t;
	(*result).id = ecs_to_u32(ecs_sparse_last_id((*world).store.tables));
	init_table(world, result, entities);
	ecs_log_push();
	ecs_notify_queries(world, &mut {
		let mut init = ecs_query_event_t {
			kind: EcsQueryTableMatch,
			table: result,
			parent_query: 0 as *mut ecs_query_t,
		};
		init
	});
	ecs_log_pop();
	return result;
}
unsafe extern "C" fn add_entity_to_type(
	mut type_0: ecs_type_t,
	mut add: ecs_entity_t,
	mut replace: ecs_entity_t,
	mut out: *mut ecs_entities_t,
) {
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut added: bool = 0 as libc::c_int != 0;
	let mut i: int32_t = 0;
	let mut el: int32_t = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if !(e == replace) {
			if e > add && !added {
				let fresh41 = el;
				el = el + 1;
				*(*out).array.offset(fresh41 as isize) = add;
				added = 1 as libc::c_int != 0
			}
			let fresh42 = el;
			el = el + 1;
			*(*out).array.offset(fresh42 as isize) = e
		}
		i += 1
	}
	if !added {
		let fresh43 = el;
		el = el + 1;
		*(*out).array.offset(fresh43 as isize) = add
	}
	(*out).count = el;
}
unsafe extern "C" fn remove_entity_from_type(
	mut type_0: ecs_type_t,
	mut remove: ecs_entity_t,
	mut out: *mut ecs_entities_t,
) {
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut el: int32_t = 0 as libc::c_int;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if e != remove {
			let fresh44 = el;
			el = el + 1;
			*(*out).array.offset(fresh44 as isize) = e
		}
		i += 1
	}
	(*out).count = el;
}
unsafe extern "C" fn get_edge(mut node: *mut ecs_table_t, mut e: ecs_entity_t) -> *mut ecs_edge_t {
	let mut edge: *mut ecs_edge_t = 0 as *mut ecs_edge_t;
	if e < 256 as libc::c_int as libc::c_ulong {
		edge = &mut *(*node).lo_edges.offset(e as isize) as *mut ecs_edge_t
	} else {
		edge = _ecs_map_get(
			(*node).hi_edges,
			::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t,
			e,
		) as *mut ecs_edge_t;
		if edge.is_null() {
			let mut new_edge: ecs_edge_t = {
				let mut init = ecs_edge_t {
					add: 0 as *mut ecs_table_t,
					remove: 0 as *mut ecs_table_t,
				};
				init
			};
			_ecs_map_set(
				(*node).hi_edges,
				::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t,
				e,
				&mut new_edge as *mut ecs_edge_t as *const libc::c_void,
			);
			edge = _ecs_map_get(
				(*node).hi_edges,
				::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t,
				e,
			) as *mut ecs_edge_t
		}
	}
	return edge;
}
unsafe extern "C" fn create_backlink_after_add(
	mut next: *mut ecs_table_t,
	mut prev: *mut ecs_table_t,
	mut add: ecs_entity_t,
) {
	let mut edge: *mut ecs_edge_t = get_edge(next, add);
	if (*edge).remove.is_null() {
		(*edge).remove = prev
	};
}
unsafe extern "C" fn create_backlink_after_remove(
	mut next: *mut ecs_table_t,
	mut prev: *mut ecs_table_t,
	mut add: ecs_entity_t,
) {
	let mut edge: *mut ecs_edge_t = get_edge(next, add);
	if (*edge).add.is_null() {
		(*edge).add = prev
	};
}
unsafe extern "C" fn find_xor_replace(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut type_0: ecs_type_t,
	mut add: ecs_entity_t,
) -> ecs_entity_t {
	if (*table).flags & 32 as libc::c_uint != 0 {
		let mut array: *mut ecs_entity_t = _ecs_vector_first(
			type_0,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		let mut i: int32_t = 0;
		let mut type_count: int32_t = ecs_vector_count(type_0);
		let mut xor_type: ecs_type_t = 0 as ecs_type_t;
		i = type_count - 1 as libc::c_int;
		while i >= 0 as libc::c_int {
			let mut e: ecs_entity_t = *array.offset(i as isize);
			if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x79 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			{
				let mut e_type: ecs_entity_t =
					e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
				let mut type_ptr: *const EcsType =
					ecs_get_w_entity(world, e_type, 3 as libc::c_int as ecs_entity_t)
						as *const EcsType;
				if ecs_type_owns_entity(world, (*type_ptr).normalized, add, 1 as libc::c_int != 0) {
					xor_type = (*type_ptr).normalized
				}
			} else if !xor_type.is_null() {
				if ecs_type_owns_entity(world, xor_type, e, 1 as libc::c_int != 0) {
					return e;
				}
			}
			i -= 1
		}
	}
	return 0 as libc::c_int as ecs_entity_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_switch_from_case(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut add: ecs_entity_t,
) -> int32_t {
	let mut type_0: ecs_type_t = (*table).type_0;
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = (*table).sw_column_count;
	add = add & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
	let mut sw_columns: *mut ecs_sw_column_t = 0 as *mut ecs_sw_column_t;
	if !data.is_null() && {
		sw_columns = (*data).sw_columns;
		!sw_columns.is_null()
	} {
		/* Fast path, we can get the switch type from the column data */
		i = 0 as libc::c_int;
		while i < count {
			let mut sw_type: ecs_type_t = (*sw_columns.offset(i as isize)).type_0;
			if ecs_type_owns_entity(world, sw_type, add, 1 as libc::c_int != 0) {
				return i;
			}
			i += 1
		}
	} else {
		/* Slow path, table is empty, so we'll have to get the switch types by
		 * actually inspecting the switch type entities. */
		i = 0 as libc::c_int;
		while i < count {
			let mut e: ecs_entity_t = *array.offset((i + (*table).sw_column_offset) as isize);
			e = e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			let mut type_ptr: *const EcsType =
				ecs_get_w_entity(world, e, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
			if ecs_type_owns_entity(world, (*type_ptr).normalized, add, 1 as libc::c_int != 0) {
				return i;
			}
			i += 1
		}
	}
	/* If a table was not found, this is an invalid switch case */
	_ecs_abort(
		46 as libc::c_int,
		0 as *const libc::c_char,
		b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
		28043 as libc::c_int,
	);
	abort();
}
unsafe extern "C" fn find_or_create_table_include(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut add: ecs_entity_t,
) -> *mut ecs_table_t {
	/* If table has one or more switches and this is a case, return self */
	if add & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
	{
		return node;
	} else {
		let mut type_0: ecs_type_t = (*node).type_0;
		let mut count: int32_t = ecs_vector_count(type_0);
		let mut entities: ecs_entities_t = ecs_entities_t {
			array: 0 as *mut ecs_entity_t,
			count: 0,
		};
		let mut fresh45 = ::std::vec::from_elem(
			0,
			(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t
				* (count + 1 as libc::c_int)) as size_t as usize,
		);
		entities.array = fresh45.as_mut_ptr() as *mut ecs_entity_t;
		entities.count = count + 1 as libc::c_int;
		/* If table has a XOR column, check if the entity that is being added to
		 * the table is part of the XOR type, and if it is, find the current
		 * entity in the table type matching the XOR type. This entity must be
		 * replaced in the new table, to ensure the XOR constraint isn't
		 * violated. */
		let mut replace: ecs_entity_t = find_xor_replace(world, node, type_0, add);
		add_entity_to_type(type_0, add, replace, &mut entities);
		let mut result: *mut ecs_table_t = ecs_table_find_or_create(world, &mut entities);
		if result != node {
			create_backlink_after_add(result, node, add);
		}
		return result;
	};
}
unsafe extern "C" fn find_or_create_table_exclude(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut remove: ecs_entity_t,
) -> *mut ecs_table_t {
	let mut type_0: ecs_type_t = (*node).type_0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut entities: ecs_entities_t = ecs_entities_t {
		array: 0 as *mut ecs_entity_t,
		count: 0,
	};
	let mut fresh46 = ::std::vec::from_elem(
		0,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * count) as size_t
			as usize,
	);
	entities.array = fresh46.as_mut_ptr() as *mut ecs_entity_t;
	entities.count = count;
	remove_entity_from_type(type_0, remove, &mut entities);
	let mut result: *mut ecs_table_t = ecs_table_find_or_create(world, &mut entities);
	if result.is_null() {
		return 0 as *mut ecs_table_t;
	}
	if result != node {
		create_backlink_after_remove(result, node, remove);
	}
	return result;
}
unsafe extern "C" fn traverse_remove_hi_edges(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut i: int32_t,
	mut to_remove: *mut ecs_entities_t,
	mut removed: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	let mut count: int32_t = (*to_remove).count;
	let mut entities: *mut ecs_entity_t = (*to_remove).array;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		let mut next_e: ecs_entity_t = e;
		let mut next: *mut ecs_table_t = 0 as *mut ecs_table_t;
		let mut edge: *mut ecs_edge_t = 0 as *mut ecs_edge_t;
		edge = get_edge(node, e);
		next = (*edge).remove;
		if next.is_null() {
			next = find_or_create_table_exclude(world, node, next_e);
			if next.is_null() {
				return 0 as *mut ecs_table_t;
			}
			(*edge).remove = next
		}
		if !removed.is_null() && node != next {
			let fresh47 = (*removed).count;
			(*removed).count = (*removed).count + 1;
			*(*removed).array.offset(fresh47 as isize) = e
		}
		node = next;
		i += 1
	}
	return node;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_traverse_remove(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut to_remove: *mut ecs_entities_t,
	mut removed: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = (*to_remove).count;
	let mut entities: *mut ecs_entity_t = (*to_remove).array;
	node = if !node.is_null() {
		node
	} else {
		&mut (*world).store.root
	};
	let mut current_block_13: u64;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		/* If the array is not a simple component array, use a function that
		 * handles all cases, but is slower */
		if e >= 256 as libc::c_int as libc::c_ulong {
			return traverse_remove_hi_edges(world, node, i, to_remove, removed);
		}
		let mut edge: *mut ecs_edge_t =
			&mut *(*node).lo_edges.offset(e as isize) as *mut ecs_edge_t;
		let mut next: *mut ecs_table_t = (*edge).remove;
		if next.is_null() {
			if (*edge).add == node {
				/* Find table with all components of node except 'e' */
				next = find_or_create_table_exclude(world, node, e);
				if next.is_null() {
					return 0 as *mut ecs_table_t;
				}
				(*edge).remove = next;
				current_block_13 = 12039483399334584727;
			} else {
				current_block_13 = 14155750587950065367;
			}
		} else {
			current_block_13 = 12039483399334584727;
		}
		match current_block_13 {
			12039483399334584727 => {
				if !removed.is_null() {
					let fresh48 = (*removed).count;
					(*removed).count = (*removed).count + 1;
					*(*removed).array.offset(fresh48 as isize) = e
				}
				node = next
			}
			_ => {}
		}
		/* If the add edge does not point to self, the table
		 * does not have the entity in to_remove. */
		i += 1
	}
	return node;
}
unsafe extern "C" fn find_owned_components(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut base: ecs_entity_t,
	mut owned: *mut ecs_entities_t,
) {
	/* If we're adding an INSTANCEOF relationship, check if the base
	 * has OWNED components that need to be added to the instance */
	let mut t: ecs_type_t = ecs_get_type(world, base);
	let mut i: libc::c_int = 0;
	let mut count: libc::c_int = ecs_vector_count(t);
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		t,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			find_owned_components(
				world,
				node,
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int),
				owned,
			);
		} else if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x75 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			e = e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			/* If entity is a type, add each component in the type */
			let mut t_ptr: *const EcsType =
				ecs_get_w_entity(world, e, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
			if !t_ptr.is_null() {
				let mut n: ecs_type_t = (*t_ptr).normalized;
				let mut j: int32_t = 0;
				let mut n_count: int32_t = ecs_vector_count(n);
				let mut n_entities: *mut ecs_entity_t = _ecs_vector_first(
					n,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				j = 0 as libc::c_int;
				while j < n_count {
					let fresh49 = (*owned).count;
					(*owned).count = (*owned).count + 1;
					*(*owned).array.offset(fresh49 as isize) = *n_entities.offset(j as isize);
					j += 1
				}
			} else {
				let fresh50 = (*owned).count;
				(*owned).count = (*owned).count + 1;
				*(*owned).array.offset(fresh50 as isize) =
					e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int)
			}
		}
		i += 1
	}
}
unsafe extern "C" fn traverse_add_hi_edges(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut i: int32_t,
	mut to_add: *mut ecs_entities_t,
	mut added: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	let mut count: int32_t = (*to_add).count;
	let mut entities: *mut ecs_entity_t = (*to_add).array;
	let mut owned_array: [ecs_entity_t; 32] = [0; 32];
	let mut owned: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: owned_array.as_mut_ptr(),
			count: 0 as libc::c_int,
		};
		init
	};
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		let mut next_e: ecs_entity_t = e;
		let mut next: *mut ecs_table_t = 0 as *mut ecs_table_t;
		let mut edge: *mut ecs_edge_t = 0 as *mut ecs_edge_t;
		edge = get_edge(node, e);
		next = (*edge).add;
		if next.is_null() {
			next = find_or_create_table_include(world, node, next_e);
			(*edge).add = next
		}
		let mut has_case_0: bool = e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int;
		if !added.is_null() && (node != next || has_case_0 as libc::c_int != 0) {
			/* If this is a case, find switch and encode it in added id */
			if has_case_0 {
				let mut s_case: int32_t = ecs_table_switch_from_case(world, node, e);
				e = (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x77 as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					| ((s_case as uint64_t) << 32 as libc::c_int)
						.wrapping_add(e as uint32_t as libc::c_ulong)
			}
			let fresh51 = (*added).count;
			(*added).count = (*added).count + 1;
			*(*added).array.offset(fresh51 as isize) = e
		}
		if node != next
			&& e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			find_owned_components(
				world,
				next,
				!((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int) & e,
				&mut owned,
			);
		}
		node = next;
		i += 1
	}
	/* In case OWNED components were found, add them as well */
	if owned.count != 0 {
		node = ecs_table_traverse_add(world, node, &mut owned, added)
	}
	return node;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_traverse_add(
	mut world: *mut ecs_world_t,
	mut node: *mut ecs_table_t,
	mut to_add: *mut ecs_entities_t,
	mut added: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = (*to_add).count;
	let mut entities: *mut ecs_entity_t = (*to_add).array;
	node = if !node.is_null() {
		node
	} else {
		&mut (*world).store.root
	};
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		let mut next: *mut ecs_table_t = 0 as *mut ecs_table_t;
		/* If the array is not a simple component array, use a function that
		 * handles all cases, but is slower */
		if e >= 256 as libc::c_int as libc::c_ulong {
			return traverse_add_hi_edges(world, node, i, to_add, added);
		}
		/* There should always be an edge for adding */
		let mut edge: *mut ecs_edge_t =
			&mut *(*node).lo_edges.offset(e as isize) as *mut ecs_edge_t;
		next = (*edge).add;
		if next.is_null() {
			next = find_or_create_table_include(world, node, e);
			(*edge).add = next
		}
		if !added.is_null() && node != next {
			let fresh52 = (*added).count;
			(*added).count = (*added).count + 1;
			*(*added).array.offset(fresh52 as isize) = e
		}
		node = next;
		i += 1
	}
	return node;
}
unsafe extern "C" fn ecs_entity_compare(
	mut e1: *const libc::c_void,
	mut e2: *const libc::c_void,
) -> libc::c_int {
	let mut v1: ecs_entity_t = *(e1 as *mut ecs_entity_t);
	let mut v2: ecs_entity_t = *(e2 as *mut ecs_entity_t);
	if v1 < v2 {
		return -(1 as libc::c_int);
	} else if v1 > v2 {
		return 1 as libc::c_int;
	} else {
		return 0 as libc::c_int;
	};
}
unsafe extern "C" fn ecs_entity_array_is_ordered(mut entities: *mut ecs_entities_t) -> bool {
	let mut prev: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	let mut array: *mut ecs_entity_t = (*entities).array;
	let mut i: int32_t = 0;
	let mut count: int32_t = (*entities).count;
	i = 0 as libc::c_int;
	while i < count {
		if !(*array.offset(i as isize) == 0 && prev == 0) {
			if *array.offset(i as isize) <= prev {
				return 0 as libc::c_int != 0;
			}
			prev = *array.offset(i as isize)
		}
		i += 1
	}
	return 1 as libc::c_int != 0;
}
unsafe extern "C" fn ecs_entity_array_dedup(
	mut array: *mut ecs_entity_t,
	mut count: int32_t,
) -> int32_t {
	let mut j: int32_t = 0;
	let mut k: int32_t = 0;
	let mut prev: ecs_entity_t = *array.offset(0 as libc::c_int as isize);
	j = 1 as libc::c_int;
	k = j;
	while k < count {
		let mut e: ecs_entity_t = *array.offset(k as isize);
		if e == prev {
			k += 1
		}
		*array.offset(j as isize) = e;
		prev = e;
		j += 1;
		k += 1
	}
	return count - (k - j);
}
unsafe extern "C" fn find_or_create(
	mut world: *mut ecs_world_t,
	mut entities: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	/* Make sure array is ordered and does not contain duplicates */
	let mut type_count: int32_t = (*entities).count;
	let mut ordered: *mut ecs_entity_t = 0 as *mut ecs_entity_t;
	if type_count == 0 {
		return &mut (*world).store.root;
	}
	if !ecs_entity_array_is_ordered(entities) {
		let mut size: ecs_size_t =
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * type_count;
		let mut fresh53 = ::std::vec::from_elem(0, size as size_t as usize);
		ordered = fresh53.as_mut_ptr() as *mut ecs_entity_t;
		memcpy(
			ordered as *mut libc::c_void,
			(*entities).array as *const libc::c_void,
			size as size_t,
		);
		qsort(
			ordered as *mut libc::c_void,
			type_count as size_t,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong,
			Some(
				ecs_entity_compare
					as unsafe extern "C" fn(
						_: *const libc::c_void,
						_: *const libc::c_void,
					) -> libc::c_int,
			),
		);
		type_count = ecs_entity_array_dedup(ordered, type_count)
	} else {
		ordered = (*entities).array
	}
	/* Iterate tables, look if a table matches the type */
	let mut tables: *mut ecs_sparse_t = (*world).store.tables;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_sparse_count(tables);
	i = 0 as libc::c_int;
	while i < count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			i,
		) as *mut ecs_table_t;
		let mut type_0: ecs_type_t = (*table).type_0;
		let mut table_type_count: int32_t = ecs_vector_count(type_0);
		/* If types do not contain same number of entities, table won't match */
		if !(table_type_count != type_count) {
			/* Memcmp the types, as they must match exactly */
			let mut type_array: *mut ecs_entity_t = _ecs_vector_first(
				type_0,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			if memcmp(
				ordered as *const libc::c_void,
				type_array as *const libc::c_void,
				(type_count * ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t)
					as size_t,
			) == 0
			{
				/* Table found */
				return table;
			}
		}
		i += 1
	}
	let mut ordered_entities: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: ordered,
			count: type_count,
		};
		init
	};
	/* If we get here, the table has not been found. It has to be created. */
	let mut result: *mut ecs_table_t = create_table(world, &mut ordered_entities);
	return result;
}
/* * Find or create table for a set of components */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_find_or_create(
	mut world: *mut ecs_world_t,
	mut components: *mut ecs_entities_t,
) -> *mut ecs_table_t {
	return find_or_create(world, components);
}
/* * Find or create table for a type */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_from_type(
	mut world: *mut ecs_world_t,
	mut type_0: ecs_type_t,
) -> *mut ecs_table_t {
	let mut components: ecs_entities_t = ecs_type_to_entities(type_0);
	return ecs_table_find_or_create(world, &mut components);
}
// //////////////////////////////////////////////////////////////////////////////
// // Table API
// //////////////////////////////////////////////////////////////////////////////
/* Initialize root table */
#[no_mangle]
pub unsafe extern "C" fn ecs_init_root_table(mut world: *mut ecs_world_t) {
	let mut entities: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: 0 as *mut ecs_entity_t,
			count: 0 as libc::c_int,
		};
		init
	};
	init_table(world, &mut (*world).store.root, &mut entities);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_table_clear_edges(mut table: *mut ecs_table_t) {
	let mut i: uint32_t = 0;
	i = 0 as libc::c_int as uint32_t;
	while i < 256 as libc::c_int as libc::c_uint {
		let mut e: *mut ecs_edge_t = &mut *(*table).lo_edges.offset(i as isize) as *mut ecs_edge_t;
		let mut add: *mut ecs_table_t = (*e).add;
		let mut remove: *mut ecs_table_t = (*e).remove;
		if !add.is_null() {
			let ref mut fresh54 = (*(*add).lo_edges.offset(i as isize)).remove;
			*fresh54 = 0 as *mut ecs_table_t
		}
		if !remove.is_null() {
			let ref mut fresh55 = (*(*remove).lo_edges.offset(i as isize)).add;
			*fresh55 = 0 as *mut ecs_table_t
		}
		i = i.wrapping_add(1)
	}
	let mut it: ecs_map_iter_t = ecs_map_iter((*table).hi_edges);
	let mut edge: *mut ecs_edge_t = 0 as *mut ecs_edge_t;
	let mut component: ecs_map_key_t = 0;
	loop {
		edge = _ecs_map_next(
			&mut it,
			::std::mem::size_of::<ecs_edge_t>() as libc::c_ulong as ecs_size_t,
			&mut component,
		) as *mut ecs_edge_t;
		if edge.is_null() {
			break;
		}
		let mut add_0: *mut ecs_table_t = (*edge).add;
		let mut remove_0: *mut ecs_table_t = (*edge).remove;
		if !add_0.is_null() {
			let mut e_0: *mut ecs_edge_t = get_edge(add_0, component);
			(*e_0).remove = 0 as *mut ecs_table_t;
			if (*e_0).add.is_null() {
				ecs_map_remove((*add_0).hi_edges, component);
			}
		}
		if !remove_0.is_null() {
			let mut e_1: *mut ecs_edge_t = get_edge(remove_0, component);
			(*e_1).add = 0 as *mut ecs_table_t;
			if (*e_1).remove.is_null() {
				ecs_map_remove((*remove_0).hi_edges, component);
			}
		}
	}
}
unsafe extern "C" fn next_pow_of_2(mut n: int32_t) -> int32_t {
	n -= 1;
	n |= n >> 1 as libc::c_int;
	n |= n >> 2 as libc::c_int;
	n |= n >> 4 as libc::c_int;
	n |= n >> 8 as libc::c_int;
	n |= n >> 16 as libc::c_int;
	n += 1;
	return n;
}
unsafe extern "C" fn get_bucket_count(mut element_count: int32_t) -> int32_t {
	return next_pow_of_2((element_count as libc::c_float as libc::c_double * 1.5f64) as int32_t);
}
unsafe extern "C" fn get_bucket_id(mut bucket_count: int32_t, mut key: ecs_map_key_t) -> uint64_t {
	let mut result: uint64_t =
		key & (bucket_count as uint64_t).wrapping_sub(1 as libc::c_int as libc::c_ulong);
	return result;
}
unsafe extern "C" fn find_bucket(
	mut map: *const ecs_map_t,
	mut key: ecs_map_key_t,
) -> *mut ecs_bucket_t {
	let mut buckets: *mut ecs_sparse_t = (*map).buckets;
	let mut bucket_count: int32_t = (*map).bucket_count;
	if bucket_count == 0 {
		return 0 as *mut ecs_bucket_t;
	}
	let mut bucket_id: uint64_t = get_bucket_id(bucket_count, key);
	return _ecs_sparse_get_sparse(buckets, 0 as libc::c_int, bucket_id) as *mut ecs_bucket_t;
}
unsafe extern "C" fn find_or_create_bucket(
	mut map: *mut ecs_map_t,
	mut key: ecs_map_key_t,
) -> *mut ecs_bucket_t {
	let mut buckets: *mut ecs_sparse_t = (*map).buckets;
	let mut bucket_count: int32_t = (*map).bucket_count;
	if bucket_count == 0 {
		ecs_sparse_set_size(buckets, 8 as libc::c_int);
		bucket_count = 8 as libc::c_int
	}
	let mut bucket_id: uint64_t = get_bucket_id(bucket_count, key);
	return _ecs_sparse_get_or_create(buckets, 0 as libc::c_int, bucket_id) as *mut ecs_bucket_t;
}
unsafe extern "C" fn remove_bucket(mut map: *mut ecs_map_t, mut key: ecs_map_key_t) {
	let mut bucket_count: int32_t = (*map).bucket_count;
	let mut bucket_id: uint64_t = get_bucket_id(bucket_count, key);
	ecs_sparse_remove((*map).buckets, bucket_id);
	ecs_sparse_set_generation((*map).buckets, bucket_id);
}
unsafe extern "C" fn add_to_bucket(
	mut bucket: *mut ecs_bucket_t,
	mut elem_size: ecs_size_t,
	mut offset: int32_t,
	mut key: ecs_map_key_t,
	mut payload: *mut libc::c_void,
) -> int32_t {
	let mut array: *mut libc::c_void =
		(bucket as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
	let mut elem: *mut ecs_map_key_t = (array as uintptr_t).wrapping_add(
		((::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t + elem_size)
			* (*bucket).count) as uintptr_t,
	) as *mut libc::c_void as *mut ecs_map_key_t;
	*elem = key;
	memcpy(
		(elem as uintptr_t).wrapping_add(
			::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t as uintptr_t
		) as *mut libc::c_void,
		payload,
		elem_size as size_t,
	);
	(*bucket).count += 1;
	return (*bucket).count;
}
unsafe extern "C" fn remove_from_bucket(
	mut bucket: *mut ecs_bucket_t,
	mut key: ecs_map_key_t,
	mut elem_size: ecs_size_t,
	mut offset: int32_t,
	mut index: int32_t,
) {
	(*bucket).count -= 1;
	if index != (*bucket).count {
		let mut array: *mut libc::c_void =
			(bucket as uintptr_t).wrapping_add(offset as uintptr_t) as *mut libc::c_void;
		let mut elem: *mut ecs_map_key_t = (array as uintptr_t).wrapping_add(
			((::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t + elem_size)
				* index) as uintptr_t,
		) as *mut libc::c_void as *mut ecs_map_key_t;
		let mut last_elem: *mut ecs_map_key_t = (array as uintptr_t).wrapping_add(
			((::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t + elem_size)
				* (*bucket).count) as uintptr_t,
		) as *mut libc::c_void as *mut ecs_map_key_t;
		memcpy(
			elem as *mut libc::c_void,
			last_elem as *const libc::c_void,
			(::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t + elem_size)
				as size_t,
		);
	};
}
unsafe extern "C" fn rehash(mut map: *mut ecs_map_t, mut bucket_count: int32_t) {
	let mut rehash_again: bool = false;
	loop {
		rehash_again = 0 as libc::c_int != 0;
		let mut buckets: *mut ecs_sparse_t = (*map).buckets;
		let mut elem_size: ecs_size_t = (*map).elem_size;
		let mut offset: int32_t = (*map).offset;
		ecs_sparse_set_size(buckets, bucket_count);
		(*map).bucket_count = bucket_count;
		/* Only iterate over old buckets with elements */
		let mut b: int32_t = 0;
		let mut filled_bucket_count: int32_t = ecs_sparse_count(buckets);
		let mut indices: *const uint64_t = ecs_sparse_ids(buckets);
		/* Iterate backwards as elements could otherwise be moved to existing
		 * buckets which could temporarily cause the number of elements in a
		 * bucket to exceed BUCKET_COUNT. */
		b = filled_bucket_count - 1 as libc::c_int;
		while b >= 0 as libc::c_int {
			let mut bucket_id: uint64_t = *indices.offset(b as isize);
			let mut bucket: *mut ecs_bucket_t =
				_ecs_sparse_get_sparse(buckets, 0 as libc::c_int, bucket_id) as *mut ecs_bucket_t;
			let mut i: libc::c_int = 0;
			let mut count: libc::c_int = (*bucket).count;
			let mut array: *mut ecs_map_key_t = (bucket as uintptr_t)
				.wrapping_add(offset as uintptr_t)
				as *mut libc::c_void as *mut ecs_map_key_t;
			i = 0 as libc::c_int;
			while i < count {
				let mut elem: *mut ecs_map_key_t = (array as uintptr_t).wrapping_add(
					((::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
						+ elem_size) * i) as uintptr_t,
				) as *mut libc::c_void as *mut ecs_map_key_t;
				let mut key: ecs_map_key_t = *elem;
				let mut new_bucket_id: uint64_t = get_bucket_id(bucket_count, key);
				if new_bucket_id != bucket_id {
					let mut new_bucket: *mut ecs_bucket_t =
						_ecs_sparse_get_or_create(buckets, 0 as libc::c_int, new_bucket_id)
							as *mut ecs_bucket_t;
					indices = ecs_sparse_ids(buckets);
					if add_to_bucket(
						new_bucket,
						elem_size,
						offset,
						key,
						(elem as uintptr_t)
							.wrapping_add(::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong
								as ecs_size_t as uintptr_t) as *mut libc::c_void,
					) == 8 as libc::c_int
					{
						rehash_again = 1 as libc::c_int != 0
					}
					remove_from_bucket(bucket, key, elem_size, offset, i);
					count -= 1;
					i -= 1
				}
				i += 1
			}
			b -= 1
		}
		bucket_count *= 2 as libc::c_int;
		if !rehash_again {
			break;
		}
	}
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_new(
	mut elem_size: ecs_size_t,
	mut alignment: ecs_size_t,
	mut element_count: int32_t,
) -> *mut ecs_map_t {
	let mut result: *mut ecs_map_t = ecs_os_api.calloc_.expect("non-null function pointer")(
		::std::mem::size_of::<ecs_map_t>() as libc::c_ulong as ecs_size_t * 1 as libc::c_int,
	) as *mut ecs_map_t;
	let mut bucket_count: int32_t = get_bucket_count(element_count);
	(*result).count = 0 as libc::c_int;
	(*result).type_elem_size = elem_size;
	if elem_size < ::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t {
		(*result).elem_size = ::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
	} else {
		(*result).elem_size = elem_size
	}
	if alignment < ::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t {
		(*result).offset = ::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
	} else {
		(*result).offset = alignment
	}
	(*result).bucket_count = bucket_count;
	(*result).buckets = _ecs_sparse_new(
		(*result).offset
			+ 8 as libc::c_int
				* (::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
					+ elem_size),
	);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_free(mut map: *mut ecs_map_t) {
	if !map.is_null() {
		ecs_sparse_free((*map).buckets);
		ecs_os_api.free_.expect("non-null function pointer")(map as *mut libc::c_void);
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_get(
	mut map: *const ecs_map_t,
	mut elem_size: ecs_size_t,
	mut key: ecs_map_key_t,
) -> *mut libc::c_void {
	if map.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut bucket: *mut ecs_bucket_t = find_bucket(map, key);
	if bucket.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut elem: *mut ecs_map_key_t = (bucket as uintptr_t)
		.wrapping_add((*map).offset as uintptr_t)
		as *mut libc::c_void as *mut ecs_map_key_t;
	let mut i: uint8_t = 0 as libc::c_int as uint8_t;
	loop {
		let fresh56 = i;
		i = i.wrapping_add(1);
		if !((fresh56 as libc::c_int) < (*bucket).count) {
			break;
		}
		if *elem == key {
			return (elem as uintptr_t).wrapping_add(
				::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t as uintptr_t
			) as *mut libc::c_void;
		}
		elem = (elem as uintptr_t).wrapping_add(
			(::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
				+ (*map).elem_size) as uintptr_t,
		) as *mut libc::c_void as *mut ecs_map_key_t
	}
	return 0 as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_has(
	mut map: *const ecs_map_t,
	mut elem_size: ecs_size_t,
	mut key: ecs_map_key_t,
	mut payload: *mut libc::c_void,
) -> bool {
	let mut result: *const libc::c_void = _ecs_map_get(map, elem_size, key);
	if !result.is_null() {
		memcpy(payload, result, elem_size as size_t);
		return 1 as libc::c_int != 0;
	} else {
		return 0 as libc::c_int != 0;
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_get_ptr(
	mut map: *const ecs_map_t,
	mut key: ecs_map_key_t,
) -> *mut libc::c_void {
	let mut ptr_ptr: *mut libc::c_void = _ecs_map_get(
		map,
		::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as ecs_size_t,
		key,
	);
	if !ptr_ptr.is_null() {
		return *(ptr_ptr as *mut *mut libc::c_void);
	} else {
		return 0 as *mut libc::c_void;
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_set(
	mut map: *mut ecs_map_t,
	mut elem_size: ecs_size_t,
	mut key: ecs_map_key_t,
	mut payload: *const libc::c_void,
) {
	let mut bucket: *mut ecs_bucket_t = find_or_create_bucket(map, key);
	let mut bucket_count: int32_t = (*bucket).count;
	let mut array: *mut libc::c_void =
		(bucket as uintptr_t).wrapping_add((*map).offset as uintptr_t) as *mut libc::c_void;
	let mut elem: *mut ecs_map_key_t = array as *mut ecs_map_key_t;
	let mut found: *mut ecs_map_key_t = 0 as *mut ecs_map_key_t;
	let mut i: uint8_t = 0 as libc::c_int as uint8_t;
	loop {
		let fresh57 = i;
		i = i.wrapping_add(1);
		if !((fresh57 as libc::c_int) < bucket_count) {
			break;
		}
		if *elem == key {
			found = elem;
			break;
		} else {
			elem = (elem as uintptr_t).wrapping_add(
				(::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
					+ (*map).elem_size) as uintptr_t,
			) as *mut libc::c_void as *mut ecs_map_key_t
		}
	}
	if found.is_null() {
		if (*bucket).count == 8 as libc::c_int {
			/* Can't fit in current bucket, need to grow the map first */
			rehash(map, (*map).bucket_count * 2 as libc::c_int);
			_ecs_map_set(map, elem_size, key, payload);
		} else {
			(*bucket).count += 1;
			bucket_count = (*bucket).count;
			(*map).count += 1;
			let mut map_count: int32_t = (*map).count;
			*elem = key;
			memcpy(
				(elem as uintptr_t).wrapping_add(::std::mem::size_of::<ecs_map_key_t>()
					as libc::c_ulong as ecs_size_t as uintptr_t) as *mut libc::c_void,
				payload,
				elem_size as size_t,
			);
			let mut target_bucket_count: int32_t = get_bucket_count(map_count);
			let mut map_bucket_count: int32_t = (*map).bucket_count;
			if bucket_count == 8 as libc::c_int {
				rehash(map, map_bucket_count * 2 as libc::c_int);
			} else if target_bucket_count > map_bucket_count {
				rehash(map, target_bucket_count);
			}
		}
	} else {
		*found = key;
		memcpy(
			(found as uintptr_t).wrapping_add(
				::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t as uintptr_t
			) as *mut libc::c_void,
			payload,
			elem_size as size_t,
		);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_remove(mut map: *mut ecs_map_t, mut key: ecs_map_key_t) {
	let mut bucket: *mut ecs_bucket_t = find_bucket(map, key);
	if bucket.is_null() {
		return;
	}
	let mut elem_size: ecs_size_t = (*map).elem_size;
	let mut array: *mut libc::c_void =
		(bucket as uintptr_t).wrapping_add((*map).offset as uintptr_t) as *mut libc::c_void;
	let mut elem: *mut ecs_map_key_t = array as *mut ecs_map_key_t;
	let mut bucket_count: int32_t = (*bucket).count;
	if bucket_count == 0 {
		return;
	}
	let mut i: uint8_t = 0 as libc::c_int as uint8_t;
	loop {
		if *elem == key {
			let mut last_elem: *mut ecs_map_key_t = (array as uintptr_t).wrapping_add(
				((::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
					+ elem_size) * (bucket_count - 1 as libc::c_int)) as uintptr_t,
			) as *mut libc::c_void as *mut ecs_map_key_t;
			if last_elem > elem {
				memcpy(
					elem as *mut libc::c_void,
					last_elem as *const libc::c_void,
					(::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
						+ elem_size) as size_t,
				);
			}
			(*map).count -= 1;
			(*bucket).count -= 1;
			if (*bucket).count == 0 {
				remove_bucket(map, key);
			}
			break;
		} else {
			elem = (elem as uintptr_t).wrapping_add(
				(::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t + elem_size)
					as uintptr_t,
			) as *mut libc::c_void as *mut ecs_map_key_t;
			i = i.wrapping_add(1);
			if !((i as libc::c_int) < bucket_count) {
				break;
			}
		}
	}
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_count(mut map: *const ecs_map_t) -> int32_t {
	return if !map.is_null() {
		(*map).count
	} else {
		0 as libc::c_int
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_bucket_count(mut map: *const ecs_map_t) -> int32_t {
	return if !map.is_null() {
		(*map).bucket_count
	} else {
		0 as libc::c_int
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_clear(mut map: *mut ecs_map_t) {
	ecs_sparse_clear((*map).buckets);
	(*map).count = 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_iter(mut map: *const ecs_map_t) -> ecs_map_iter_t {
	return {
		let mut init = ecs_map_iter_t {
			map: map,
			bucket: 0 as *mut ecs_bucket_t,
			bucket_index: 0 as libc::c_int,
			element_index: 0 as libc::c_int,
			payload: 0 as *mut libc::c_void,
		};
		init
	};
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_next(
	mut iter: *mut ecs_map_iter_t,
	mut elem_size: ecs_size_t,
	mut key_out: *mut ecs_map_key_t,
) -> *mut libc::c_void {
	let mut map: *const ecs_map_t = (*iter).map;
	let mut bucket: *mut ecs_bucket_t = (*iter).bucket;
	let mut element_index: int32_t = (*iter).element_index;
	elem_size = (*map).elem_size;
	loop {
		if bucket.is_null() {
			let mut bucket_index: int32_t = (*iter).bucket_index;
			let mut buckets: *mut ecs_sparse_t = (*map).buckets;
			if bucket_index < ecs_sparse_count(buckets) {
				bucket =
					_ecs_sparse_get(buckets, 0 as libc::c_int, bucket_index) as *mut ecs_bucket_t;
				(*iter).bucket = bucket;
				element_index = 0 as libc::c_int;
				(*iter).element_index = 0 as libc::c_int
			} else {
				return 0 as *mut libc::c_void;
			}
		}
		if element_index < (*bucket).count {
			(*iter).element_index = element_index + 1 as libc::c_int;
			break;
		} else {
			bucket = 0 as *mut ecs_bucket_t;
			(*iter).bucket_index += 1
		}
	}
	let mut array: *mut libc::c_void =
		(bucket as uintptr_t).wrapping_add((*map).offset as uintptr_t) as *mut libc::c_void;
	let mut elem: *mut ecs_map_key_t = (array as uintptr_t).wrapping_add(
		((::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t + elem_size)
			* element_index) as uintptr_t,
	) as *mut libc::c_void as *mut ecs_map_key_t;
	if !key_out.is_null() {
		*key_out = *elem
	}
	return (elem as uintptr_t).wrapping_add(
		::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t as uintptr_t
	) as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn _ecs_map_next_ptr(
	mut iter: *mut ecs_map_iter_t,
	mut key_out: *mut ecs_map_key_t,
) -> *mut libc::c_void {
	let mut result: *mut libc::c_void = _ecs_map_next(
		iter,
		::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as ecs_size_t,
		key_out,
	);
	if !result.is_null() {
		return *(result as *mut *mut libc::c_void);
	} else {
		return 0 as *mut libc::c_void;
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_grow(mut map: *mut ecs_map_t, mut element_count: int32_t) {
	let mut target_count: int32_t = (*map).count + element_count;
	let mut bucket_count: int32_t = get_bucket_count(target_count);
	if bucket_count > (*map).bucket_count {
		rehash(map, bucket_count);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_set_size(mut map: *mut ecs_map_t, mut element_count: int32_t) {
	let mut bucket_count: int32_t = get_bucket_count(element_count);
	if bucket_count != 0 {
		rehash(map, bucket_count);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_memory(
	mut map: *mut ecs_map_t,
	mut allocd: *mut int32_t,
	mut used: *mut int32_t,
) {
	ecs_sparse_memory((*map).buckets, allocd, 0 as *mut int32_t);
	if !used.is_null() {
		*used = (*map).count
			* (::std::mem::size_of::<ecs_map_key_t>() as libc::c_ulong as ecs_size_t
				+ (*map).elem_size)
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_map_copy(mut src: *const ecs_map_t) -> *mut ecs_map_t {
	if src.is_null() {
		return 0 as *mut ecs_map_t;
	}
	let mut dst: *mut ecs_map_t = ecs_os_memdup(
		src as *const libc::c_void,
		::std::mem::size_of::<ecs_map_t>() as libc::c_ulong as ecs_size_t,
	) as *mut ecs_map_t;
	(*dst).buckets = ecs_sparse_copy((*src).buckets);
	return dst;
}
unsafe extern "C" fn get_owned_column_ptr(
	mut it: *const ecs_iter_t,
	mut size: ecs_size_t,
	mut table_column: int32_t,
	mut row: int32_t,
) -> *mut libc::c_void {
	let mut column: *mut ecs_column_t = &mut *((*it).table_columns as *mut ecs_column_t)
		.offset((table_column - 1 as libc::c_int) as isize)
		as *mut ecs_column_t;
	let mut buffer: *mut libc::c_void = _ecs_vector_first(
		(*column).data,
		(*column).size as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			> (*column).alignment as libc::c_int
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
		} else {
			(*column).alignment as libc::c_int
		} as int16_t,
	);
	return (buffer as uintptr_t)
		.wrapping_add(((*column).size as libc::c_int * ((*it).offset + row)) as uintptr_t)
		as *mut libc::c_void;
}
unsafe extern "C" fn get_shared_column(
	mut it: *const ecs_iter_t,
	mut size: ecs_size_t,
	mut table_column: int32_t,
) -> *const libc::c_void {
	let mut refs: *mut ecs_ref_t = (*(*it).table).references;
	let mut ref_0: *mut ecs_ref_t =
		&mut *refs.offset((-table_column - 1 as libc::c_int) as isize) as *mut ecs_ref_t;
	return ecs_get_ref_w_entity((*it).world, ref_0, (*ref_0).entity, (*ref_0).component)
		as *mut libc::c_void;
}
unsafe extern "C" fn get_table_column(
	mut it: *const ecs_iter_t,
	mut column: int32_t,
	mut table_column_out: *mut int32_t,
) -> bool {
	let mut table_column: int32_t = 0 as libc::c_int;
	if column != 0 as libc::c_int {
		table_column = *(*(*it).table)
			.columns
			.offset((column - 1 as libc::c_int) as isize);
		if table_column == 0 {
			/* column is not set */
			return 0 as libc::c_int != 0;
		}
	}
	*table_column_out = table_column;
	return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_column(
	mut it: *const ecs_iter_t,
	mut size: ecs_size_t,
	mut column: int32_t,
	mut row: int32_t,
) -> *mut libc::c_void {
	let mut table_column: int32_t = 0;
	if column == 0 {
		return (*it).entities as *mut libc::c_void;
	}
	if !get_table_column(it, column, &mut table_column) {
		return 0 as *mut libc::c_void;
	}
	if table_column < 0 as libc::c_int {
		return get_shared_column(it, size, table_column) as *mut libc::c_void;
	} else {
		return get_owned_column_ptr(it, size, table_column, row);
	};
}
/* * @} */
/* *
 * @defgroup iterator Iterators
 * @{
 */
/* * Obtain column data.
 * This operation is to be used to obtain a component array for a specific
 * column in the system or query signature. The column is identified by the
 * provided index. For example, if this is the provided signature:
 *
 * Position, Velocity
 *
 * Position is at index 1, and Velocity is at index 2.
 *
 * This operation may return NULL if the column is optional, and the current
 * table does not have the data. Additionally, if the column points to a shared
 * component or a reference, the returned value should be interpreted as a
 * pointer instead of an array.
 *
 * The provided size must match the size of the component, otherwise the
 * function may fail.
 *
 * @param it The iterator.
 * @param size The size of the component.
 * @param column The index identifying the column in a signature.
 * @return A pointer to the column data.
 */
/* --- Public API --- */
#[no_mangle]
pub unsafe extern "C" fn ecs_column_w_size(
	mut it: *const ecs_iter_t,
	mut size: size_t,
	mut column: int32_t,
) -> *mut libc::c_void {
	return get_column(it, ecs_from_size_t(size), column, 0 as libc::c_int);
}
/* * Obtain a single element.
 * This operation is similar to ecs_column, but instead of an array it obtains
 * a single element from a component array. The advantage of using ecs_element
 * is that a system can be agnostic towards whether a component is owned or not,
 * at the cost of some additional performance overhead.
 *
 * @param it The iterator.
 * @param size The component size.
 * @param column The index identifying the column in a signature.
 * @param row The current row in the table.
 * @return A pointer to the current element.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_element_w_size(
	mut it: *const ecs_iter_t,
	mut size: size_t,
	mut column: int32_t,
	mut row: int32_t,
) -> *mut libc::c_void {
	return get_column(it, ecs_from_size_t(size), column, row);
}
/* * Test if column is owned or not.
 * The following signature shows an example of one owned components and two
 * components that are not owned by the current entity:
 *
 * Position, PARENT:Velocity, MyEntity:Mass
 *
 * Position is an owned component. Velocity and Mass both belong to a different
 * entity. This operation will return false for Position, and true for Velocity
 * and Mass. If a component is matched from a prefab, this operation will also
 * return false.
 *
 * @param it The it parameter passed into the system.
 * @param index The index identifying the column in a system signature.
 * @return True if column is owned, false if column is not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_is_owned(mut it: *const ecs_iter_t, mut column: int32_t) -> bool {
	let mut table_column: int32_t = 0;
	if !get_table_column(it, column, &mut table_column) {
		return 1 as libc::c_int != 0;
	}
	return table_column >= 0 as libc::c_int;
}
/* * Is the column readonly.
 * This operation returns if the column is a readonly column. Readonly columns
 * are marked in the system signature with the [in] modifier.
 *
 * @param it Pointer to the it object passed into the system callback.
 * @param column An index identifying the column.
 * @return True if the column is readonly, false otherwise. */
#[no_mangle]
pub unsafe extern "C" fn ecs_is_readonly(mut it: *const ecs_iter_t, mut column: int32_t) -> bool {
	let mut query: *mut ecs_query_t = (*it).query;
	if !query.is_null() {
		let mut column_data: *mut ecs_sig_column_t = _ecs_vector_get(
			(*(*it).query).sig.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
			column - 1 as libc::c_int,
		) as *mut ecs_sig_column_t;
		return (*column_data).inout_kind as libc::c_uint == EcsIn as libc::c_int as libc::c_uint;
	} else {
		return 1 as libc::c_int != 0;
	};
}
/* * Obtain a single element.
 * Same as ecs_element_w_size, but allows specifying a typename instead of a
 * size.
 *
 * @param it The iterator.
 * @param type The column type.
 * @param column The index identifying the column in a signature.
 * @param row The current row in the table.
 * @return A pointer to the current element.
 */
/* * Obtain the source of a signature column.
 * This operation returns the source of a signature column. By default this will
 * return 0 for regular columns, but for columns where the components are
 * provided by entities other than the entity being iterated over, this will
 * return the source of the component.
 *
 * @param it Pointer to the it object passed into the system callback.
 * @param column The index identifying the column in a signature.
 * @return The source entity for the column.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_column_source(
	mut it: *const ecs_iter_t,
	mut index: int32_t,
) -> ecs_entity_t {
	let mut table: *mut ecs_iter_table_t = (*it).table;
	let mut table_column: int32_t = *(*table).columns.offset((index - 1 as libc::c_int) as isize);
	if table_column >= 0 as libc::c_int {
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut ref_0: *mut ecs_ref_t = &mut *(*table)
		.references
		.offset((-table_column - 1 as libc::c_int) as isize)
		as *mut ecs_ref_t;
	return (*ref_0).entity;
}
/* * Obtain the type of a column from inside a system.
 * This operation is equivalent to ecs_column_entity, except that it returns
 * a type, instead of an entity handle. Invoking this function is the same as
 * doing:
 *
 * ecs_type_from_entity( ecs_column_entity(it, index));
 *
 * @param it The iterator.
 * @param column The index identifying the column in a signature.
 * @return The type for the specified column, or NULL if failed.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_column_type(
	mut it: *const ecs_iter_t,
	mut index: int32_t,
) -> ecs_type_t {
	return *(*(*it).table)
		.types
		.offset((index - 1 as libc::c_int) as isize);
}
/* * Obtain the entity id of the signature column.
 * This operation returns the entity id of the component or tag used in the
 * system signature. For example, when provided this signature:
 *
 * Position, Velocity
 *
 * ecs_column_entity(world, 1) will return the component handle for Position and
 * ecs_column_entity(world, 2) will return the componnet handle for Velocity.
 *
 * @param it The iterator.
 * @param column The index identifying the column in a signature.
 * @return The entity id of the signature column.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_column_entity(
	mut it: *const ecs_iter_t,
	mut index: int32_t,
) -> ecs_entity_t {
	return *(*(*it).table)
		.components
		.offset((index - 1 as libc::c_int) as isize);
}
/* * Get the size of the component of the specified column.
 *
 * @param it The iterator.
 * @param column The column for which to obtain the size.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_column_size(
	mut it: *const ecs_iter_t,
	mut index: int32_t,
) -> ecs_entity_t {
	let mut table_column: int32_t = *(*(*it).table)
		.columns
		.offset((index - 1 as libc::c_int) as isize);
	return ecs_table_column_size(it, table_column - 1 as libc::c_int);
}
/* * Get column index by name.
 * This function obtains a column index by name. This function can only be used
 * if a query signature contains names.
 *
 * @param it The iterator.
 * @param name The column name.
 * @return Index of the column (to be used with ecs_column_* functions).
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_column_index_from_name(
	mut it: *const ecs_iter_t,
	mut name: *const libc::c_char,
) -> int32_t {
	let mut column: *mut ecs_sig_column_t = 0 as *mut ecs_sig_column_t;
	if !(*it).query.is_null() {
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*(*it).query).sig.columns);
		i = 0 as libc::c_int;
		while i < count {
			column = _ecs_vector_get(
				(*(*it).query).sig.columns,
				::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
				} as int16_t,
				i,
			) as *mut ecs_sig_column_t;
			if !(*column).name.is_null() {
				if strcmp(name, (*column).name) == 0 {
					return i + 1 as libc::c_int;
				}
			}
			i += 1
		}
	}
	return 0 as libc::c_int;
}
/* * Get type of table that system is currently iterating over.
 * This will return the type for all entities that are currently being iterated
 * over, until ecs_iter_next is invoked.
 *
 * @param it The iterator.
 * @return The type of the current table.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_iter_type(mut it: *const ecs_iter_t) -> ecs_type_t {
	let mut table: *mut ecs_table_t = (*(*it).table).table;
	return (*table).type_0;
}
/* * Get the index of the table column for a component.
 *
 * @param it The iterator.
 * @param component The component for which to obtain the index.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_component_index(
	mut it: *const ecs_iter_t,
	mut component: ecs_entity_t,
) -> int32_t {
	return ecs_type_index_of((*(*(*it).table).table).type_0, component);
}
/* * Get component array from table.
 * In some cases an application may require access to the table component arrays
 * directly instead of going through the signature to table mapping. A typical
 * scenario where this would be used is when using a filter iterator, where
 * there is no signature, and thus ecs_column cannot be used.
 *
 * @param it The iterator.
 * @param column The index identifying the column in a table.
 * @return The component array corresponding to the column index.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_column(
	mut it: *const ecs_iter_t,
	mut column_index: int32_t,
) -> *mut libc::c_void {
	let mut table: *mut ecs_table_t = (*(*it).table).table;
	if (*table).column_count < column_index {
		return 0 as *mut libc::c_void;
	}
	let mut columns: *mut ecs_column_t = (*it).table_columns as *mut ecs_column_t;
	let mut column: *mut ecs_column_t =
		&mut *columns.offset(column_index as isize) as *mut ecs_column_t;
	return _ecs_vector_first(
		(*column).data,
		(*column).size as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			> (*column).alignment as libc::c_int
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
		} else {
			(*column).alignment as libc::c_int
		} as int16_t,
	);
}
/* * Get the size of a table column.
 *
 * @param it The iterator.
 * @param column The column for which to obtain the size.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_table_column_size(
	mut it: *const ecs_iter_t,
	mut column_index: int32_t,
) -> size_t {
	let mut table: *mut ecs_table_t = (*(*it).table).table;
	if (*table).column_count < column_index {
		return 0 as libc::c_int as size_t;
	}
	let mut columns: *mut ecs_column_t = (*it).table_columns as *mut ecs_column_t;
	let mut column: *mut ecs_column_t =
		&mut *columns.offset(column_index as isize) as *mut ecs_column_t;
	return ecs_to_size_t((*column).size as int64_t);
}
// //////////////////////////////////////////////////////////////////////////////
// // Utilities
// //////////////////////////////////////////////////////////////////////////////
/* Convert 64 bit signed integer to 16 bit */
#[no_mangle]
pub unsafe extern "C" fn ecs_to_i8(mut v: int64_t) -> int8_t {
	return v as int8_t;
}
/* Convert 64 bit signed integer to 16 bit */
#[no_mangle]
pub unsafe extern "C" fn ecs_to_i16(mut v: int64_t) -> int16_t {
	return v as int16_t;
}
/* Convert 64 bit signed integer to 32 bit */
#[no_mangle]
pub unsafe extern "C" fn ecs_to_i32(mut v: int64_t) -> int32_t {
	return v as int32_t;
}
/* Convert 64 bit unsigned integer to 32 bit */
#[no_mangle]
pub unsafe extern "C" fn ecs_to_u32(mut v: uint64_t) -> uint32_t {
	return v as uint32_t;
}
/* Convert signed integer to size_t */
#[no_mangle]
pub unsafe extern "C" fn ecs_to_size_t(mut size: int64_t) -> size_t {
	return size as size_t;
}
/* Convert size_t to ecs_size_t */
#[no_mangle]
pub unsafe extern "C" fn ecs_from_size_t(mut size: size_t) -> ecs_size_t {
	return size as ecs_size_t;
}
/* Convert int64_t to entity */
#[no_mangle]
pub unsafe extern "C" fn ecs_to_entity(mut v: int64_t) -> ecs_entity_t {
	return v as ecs_entity_t;
}
/* Convert int64_t from entity */
#[no_mangle]
pub unsafe extern "C" fn ecs_from_entity(mut v: ecs_entity_t) -> int64_t {
	return v as int64_t;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_from_entity_to_i32(mut v: ecs_entity_t) -> int32_t {
	return v as int32_t;
}
/* Convert time value to a double */
/* * Convert time to double */
#[no_mangle]
pub unsafe extern "C" fn ecs_time_to_double(mut t: ecs_time_t) -> libc::c_double {
	let mut result: libc::c_double = 0.;
	result = t.sec as libc::c_double;
	return result + t.nanosec as libc::c_double / 1000000000 as libc::c_int as libc::c_double;
}
/* Calculate difference between two timestamps */
#[no_mangle]
pub unsafe extern "C" fn ecs_time_sub(mut t1: ecs_time_t, mut t2: ecs_time_t) -> ecs_time_t {
	let mut result: ecs_time_t = ecs_time_t { sec: 0, nanosec: 0 };
	if t1.nanosec >= t2.nanosec {
		result.nanosec = t1.nanosec.wrapping_sub(t2.nanosec);
		result.sec = t1.sec.wrapping_sub(t2.sec)
	} else {
		result.nanosec = t1
			.nanosec
			.wrapping_sub(t2.nanosec)
			.wrapping_add(1000000000 as libc::c_int as libc::c_uint);
		result.sec = t1
			.sec
			.wrapping_sub(t2.sec)
			.wrapping_sub(1 as libc::c_int as libc::c_uint)
	}
	return result;
}
/* Sleep with floating point time */
#[no_mangle]
pub unsafe extern "C" fn ecs_sleepf(mut t: libc::c_double) {
	if t > 0 as libc::c_int as libc::c_double {
		let mut sec: libc::c_int = t as libc::c_int;
		let mut nsec: libc::c_int = ((t - sec as libc::c_double)
			* 1000000000 as libc::c_int as libc::c_double) as libc::c_int;
		ecs_os_api.sleep_.expect("non-null function pointer")(sec, nsec);
	};
}
/* Measure time since provided timestamp */
#[no_mangle]
pub unsafe extern "C" fn ecs_time_measure(mut start: *mut ecs_time_t) -> libc::c_double {
	let mut stop: ecs_time_t = ecs_time_t { sec: 0, nanosec: 0 };
	let mut temp: ecs_time_t = ecs_time_t { sec: 0, nanosec: 0 };
	ecs_os_api.get_time_.expect("non-null function pointer")(&mut stop);
	temp = stop;
	stop = ecs_time_sub(stop, *start);
	*start = temp;
	return ecs_time_to_double(stop);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_memdup(
	mut src: *const libc::c_void,
	mut size: ecs_size_t,
) -> *mut libc::c_void {
	if src.is_null() {
		return 0 as *mut libc::c_void;
	}
	let mut dst: *mut libc::c_void = ecs_os_api.malloc_.expect("non-null function pointer")(size);
	memcpy(dst, src, size as size_t);
	return dst;
}
/*
	This code was taken from sokol_time.h

	zlib/libpng license
	Copyright (c) 2018 Andre Weissflog
	This software is provided 'as-is', without any express or implied warranty.
	In no event will the authors be held liable for any damages arising from the
	use of this software.
	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:
		1. The origin of this software must not be misrepresented; you must not
		claim that you wrote the original software. If you use this software in a
		product, an acknowledgment in the product documentation would be
		appreciated but is not required.
		2. Altered source versions must be plainly marked as such, and must not
		be misrepresented as being the original software.
		3. This notice may not be removed or altered from any source
		distribution.
*/
static mut ecs_os_time_initialized: libc::c_int = 0;
/* anything else, this will need more care for non-Linux platforms */
static mut _ecs_os_time_posix_start: uint64_t = 0;
// //////////////////////////////////////////////////////////////////////////////
// // Time API
// //////////////////////////////////////////////////////////////////////////////
/* prevent 64-bit overflow when computing relative timestamp
	see https://gist.github.com/jspohr/3dc4f00033d79ec5bdaf67bc46c813e3
*/
#[no_mangle]
pub unsafe extern "C" fn ecs_os_time_setup() {
	if ecs_os_time_initialized != 0 {
		return;
	}
	ecs_os_time_initialized = 1 as libc::c_int;
	let mut ts: timespec = timespec {
		tv_sec: 0,
		tv_nsec: 0,
	};
	clock_gettime(1 as libc::c_int, &mut ts);
	_ecs_os_time_posix_start = (ts.tv_sec as uint64_t)
		.wrapping_mul(1000000000 as libc::c_int as libc::c_ulong)
		.wrapping_add(ts.tv_nsec as uint64_t);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_time_now() -> uint64_t {
	let mut now: uint64_t = 0;
	let mut ts: timespec = timespec {
		tv_sec: 0,
		tv_nsec: 0,
	};
	clock_gettime(1 as libc::c_int, &mut ts);
	now = (ts.tv_sec as uint64_t)
		.wrapping_mul(1000000000 as libc::c_int as libc::c_ulong)
		.wrapping_add(ts.tv_nsec as uint64_t);
	return now;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_os_time_sleep(mut sec: int32_t, mut nanosec: int32_t) {
	let mut sleepTime: timespec = timespec {
		tv_sec: 0,
		tv_nsec: 0,
	};
	sleepTime.tv_sec = sec as __time_t;
	sleepTime.tv_nsec = nanosec as __syscall_slong_t;
	if nanosleep(&mut sleepTime, 0 as *mut timespec) != 0 {
		ecs_os_err(b"nanosleep failed\x00" as *const u8 as *const libc::c_char);
	};
}
/* Increase or reset timer resolution (Windows only) */
#[no_mangle]
pub unsafe extern "C" fn ecs_increase_timer_resolution(mut enable: bool) {}
/* Worker thread */
unsafe extern "C" fn worker(mut arg: *mut libc::c_void) -> *mut libc::c_void {
	let mut thread: *mut ecs_thread_t = arg as *mut ecs_thread_t;
	let mut world: *mut ecs_world_t = (*thread).world;
	/* Start worker thread, increase counter so main thread knows how many
	 * workers are ready */
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).sync_mutex);
	(*world).workers_running += 1;
	if !(*world).quit_workers {
		ecs_os_api.cond_wait_.expect("non-null function pointer")(
			(*world).worker_cond,
			(*world).sync_mutex,
		);
	}
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).sync_mutex);
	while !(*world).quit_workers {
		let mut old_scope: ecs_entity_t =
			ecs_set_scope(thread as *mut ecs_world_t, 0 as libc::c_int as ecs_entity_t);
		ecs_pipeline_progress(
			thread as *mut ecs_world_t,
			(*world).pipeline,
			(*world).stats.delta_time,
		);
		ecs_set_scope(thread as *mut ecs_world_t, old_scope);
	}
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).sync_mutex);
	(*world).workers_running -= 1;
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).sync_mutex);
	return 0 as *mut libc::c_void;
}
/* Start threads */
unsafe extern "C" fn start_workers(mut world: *mut ecs_world_t, mut threads: int32_t) {
	(*world).workers = _ecs_vector_new(
		::std::mem::size_of::<ecs_thread_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
		} as int16_t,
		threads,
	); /* 0 and 1 are reserved for main and temp */
	(*world).worker_stages = _ecs_vector_new(
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		} as int16_t,
		threads,
	);
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < threads {
		let mut thread: *mut ecs_thread_t = _ecs_vector_add(
			&mut (*world).workers,
			::std::mem::size_of::<ecs_thread_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_thread_t;
		(*thread).magic = 0x65637374 as libc::c_int;
		(*thread).world = world;
		(*thread).thread = 0 as libc::c_int as ecs_os_thread_t;
		(*thread).index = i;
		(*thread).stage = _ecs_vector_add(
			&mut (*world).worker_stages,
			::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_stage_t;
		ecs_stage_init(world, (*thread).stage);
		(*(*thread).stage).id = 2 as libc::c_int + i;
		(*(*thread).stage).world = thread as *mut ecs_world_t;
		(*thread).thread = ecs_os_api.thread_new_.expect("non-null function pointer")(
			Some(worker as unsafe extern "C" fn(_: *mut libc::c_void) -> *mut libc::c_void),
			thread as *mut libc::c_void,
		);
		i += 1
	}
}
/* Wait until all workers are running */
unsafe extern "C" fn wait_for_workers(mut world: *mut ecs_world_t) {
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	let mut wait: bool = 1 as libc::c_int != 0;
	loop {
		ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).sync_mutex);
		if (*world).workers_running == thread_count {
			wait = 0 as libc::c_int != 0
		}
		ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).sync_mutex);
		if !wait {
			break;
		}
	}
}
/* Synchronize worker threads */
unsafe extern "C" fn sync_worker(mut world: *mut ecs_world_t) {
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	/* Signal that thread is waiting */
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).sync_mutex);
	(*world).workers_waiting += 1;
	if (*world).workers_waiting == thread_count {
		/* Only signal main thread when all threads are waiting */
		ecs_os_api.cond_signal_.expect("non-null function pointer")((*world).sync_cond);
	}
	/* Wait until main thread signals that thread can continue */
	ecs_os_api.cond_wait_.expect("non-null function pointer")(
		(*world).worker_cond,
		(*world).sync_mutex,
	);
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).sync_mutex);
}
/* Wait until all threads are waiting on sync point */
unsafe extern "C" fn wait_for_sync(mut world: *mut ecs_world_t) {
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).sync_mutex);
	if (*world).workers_waiting != thread_count {
		ecs_os_api.cond_wait_.expect("non-null function pointer")(
			(*world).sync_cond,
			(*world).sync_mutex,
		);
	}
	/* We should have been signalled unless all workers are waiting on sync */
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).sync_mutex);
}
/* Signal workers that they can start/resume work */
unsafe extern "C" fn signal_workers(mut world: *mut ecs_world_t) {
	ecs_os_api.mutex_lock_.expect("non-null function pointer")((*world).sync_mutex);
	ecs_os_api
		.cond_broadcast_
		.expect("non-null function pointer")((*world).worker_cond);
	ecs_os_api.mutex_unlock_.expect("non-null function pointer")((*world).sync_mutex);
}
/* * Stop worker threads */
unsafe extern "C" fn ecs_stop_threads(mut world: *mut ecs_world_t) {
	(*world).quit_workers = 1 as libc::c_int != 0;
	signal_workers(world);
	let mut thr_i: libc::c_int = 0;
	let mut thr_count: libc::c_int = ecs_vector_count((*world).workers);
	let mut thr_array: *mut ecs_thread_t = _ecs_vector_first(
		(*world).workers,
		::std::mem::size_of::<ecs_thread_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_thread_t;
	thr_i = 0 as libc::c_int;
	while thr_i < thr_count {
		let mut thr: *mut ecs_thread_t =
			&mut *thr_array.offset(thr_i as isize) as *mut ecs_thread_t;
		ecs_os_api.thread_join_.expect("non-null function pointer")((*thr).thread);
		ecs_stage_deinit(world, (*thr).stage);
		thr_i += 1
	}
	ecs_vector_free((*world).workers);
	ecs_vector_free((*world).worker_stages);
	(*world).worker_stages = 0 as *mut ecs_vector_t;
	(*world).workers = 0 as *mut ecs_vector_t;
	(*world).quit_workers = 0 as libc::c_int != 0;
}
// //////////////////////////////////////////////////////////////////////////////
// // Worker API
// //////////////////////////////////////////////////////////////////////////////
/* -- Private functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_worker_begin(mut world: *mut ecs_world_t) {
	if (*world).magic == 0x65637377 as libc::c_int {
		ecs_staging_begin(world);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_worker_sync(mut world: *mut ecs_world_t) -> bool {
	let mut build_count: int32_t = (*world).stats.pipeline_build_count_total;
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	if thread_count == 0 {
		ecs_staging_end(world);
		ecs_pipeline_update(world, (*world).pipeline);
		ecs_staging_begin(world);
	} else {
		sync_worker(world);
	}
	return (*world).stats.pipeline_build_count_total != build_count;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_worker_end(mut world: *mut ecs_world_t) {
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	if thread_count == 0 {
		ecs_staging_end(world);
	} else {
		sync_worker(world);
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_workers_progress(mut world: *mut ecs_world_t) {
	let mut pipeline: ecs_entity_t = (*world).pipeline;
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	let mut start: ecs_time_t = {
		let mut init = ecs_time_t {
			sec: 0 as libc::c_int as uint32_t,
			nanosec: 0,
		};
		init
	};
	if (*world).measure_frame_time {
		ecs_time_measure(&mut start);
	}
	(*world).stats.systems_ran_frame = 0 as libc::c_int;
	if thread_count <= 1 as libc::c_int {
		ecs_pipeline_begin(world, pipeline);
		let mut old_scope: ecs_entity_t = ecs_set_scope(world, 0 as libc::c_int as ecs_entity_t);
		ecs_pipeline_progress(world, pipeline, (*world).stats.delta_time);
		ecs_set_scope(world, old_scope);
		ecs_pipeline_end(world);
	} else {
		let mut i: int32_t = 0;
		let mut sync_count: int32_t = ecs_pipeline_begin(world, pipeline);
		/* Make sure workers are running and ready */
		wait_for_workers(world);
		/* Synchronize n times for each op in the pipeline */
		i = 0 as libc::c_int;
		while i < sync_count {
			ecs_staging_begin(world);
			/* Signal workers that they should start running systems */
			(*world).workers_waiting = 0 as libc::c_int;
			signal_workers(world);
			/* Wait until all workers are waiting on sync point */
			wait_for_sync(world);
			/* Merge */
			ecs_staging_end(world);
			let mut update_count: int32_t = 0;
			update_count = ecs_pipeline_update(world, pipeline);
			if update_count != 0 {
				/* The number of operations in the pipeline could have changed
				 * as result of the merge */
				sync_count = update_count
			}
			i += 1
		}
		ecs_pipeline_end(world);
	}
	if (*world).measure_frame_time {
		(*world).stats.system_time_total += ecs_time_measure(&mut start) as libc::c_float
	};
}
// //////////////////////////////////////////////////////////////////////////////
// // Threading
// //////////////////////////////////////////////////////////////////////////////
/* * Set number of worker threads.
 * Setting this value to a value higher than 1 will start as many threads and
 * will cause systems to evenly distribute matched entities across threads. The
 * operation may be called multiple times to reconfigure the number of threads
 * used, but never while running a system / pipeline. */
/* -- Public functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_threads(mut world: *mut ecs_world_t, mut threads: int32_t) {
	let mut thread_count: int32_t = ecs_vector_count((*world).workers);
	if (*world).arg_threads == 0 && thread_count != threads {
		/* Stop existing threads */
		if ecs_vector_count((*world).workers) != 0 {
			ecs_stop_threads(world);
			ecs_os_api.cond_free_.expect("non-null function pointer")((*world).worker_cond);
			ecs_os_api.cond_free_.expect("non-null function pointer")((*world).sync_cond);
			ecs_os_api.mutex_free_.expect("non-null function pointer")((*world).sync_mutex);
		}
		/* Start threads if number of threads > 1 */
		if threads > 1 as libc::c_int {
			(*world).worker_cond = ecs_os_api.cond_new_.expect("non-null function pointer")();
			(*world).sync_cond = ecs_os_api.cond_new_.expect("non-null function pointer")();
			(*world).sync_mutex = ecs_os_api.mutex_new_.expect("non-null function pointer")();
			(*world).stage_count = 2 as libc::c_int + threads;
			start_workers(world, threads);
		}
		/* Iterate tables, make sure the ecs_data_t arrays are large enough */
		let mut table_i: libc::c_int = 0;
		let mut table_count: libc::c_int = ecs_sparse_count((*world).store.tables);
		table_i = 0 as libc::c_int;
		while table_i < table_count {
			let mut table: *mut ecs_table_t = _ecs_sparse_get(
				(*world).store.tables,
				::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
				table_i,
			) as *mut ecs_table_t;
			ecs_table_get_data(table);
			table_i += 1
		}
	};
}
#[no_mangle]
pub static mut FLECS__TEcsPipelineQuery: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsPipelineQuery_value as *const C2RustUnnamed_8 as *mut C2RustUnnamed_8
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsPipelineQuery_value: C2RustUnnamed_8 = {
	let mut init = C2RustUnnamed_8 {
		header: C2RustUnnamed_9 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
static mut __EcsPipelineQuery: ecs_entity_t = 13 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub unsafe extern "C" fn EcsPipelineQuery_ctor(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut entity_ptr: *const ecs_entity_t,
	mut _ptr: *mut libc::c_void,
	mut _size: size_t,
	mut _count: int32_t,
	mut ctx: *mut libc::c_void,
) {
	let mut i: int32_t = 0 as libc::c_int;
	while i < _count {
		let mut entity: ecs_entity_t = *entity_ptr.offset(i as isize);
		let mut ptr: *mut EcsPipelineQuery =
			&mut *(_ptr as *mut EcsPipelineQuery).offset(i as isize) as *mut EcsPipelineQuery;
		memset(ptr as *mut libc::c_void, 0 as libc::c_int, _size);
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn EcsPipelineQuery_dtor(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut entity_ptr: *const ecs_entity_t,
	mut _ptr: *mut libc::c_void,
	mut _size: size_t,
	mut _count: int32_t,
	mut ctx: *mut libc::c_void,
) {
	let mut i: int32_t = 0 as libc::c_int;
	while i < _count {
		let mut entity: ecs_entity_t = *entity_ptr.offset(i as isize);
		let mut ptr: *mut EcsPipelineQuery =
			&mut *(_ptr as *mut EcsPipelineQuery).offset(i as isize) as *mut EcsPipelineQuery;
		ecs_vector_free((*ptr).ops);
		i += 1
	}
}
unsafe extern "C" fn compare_entity(
	mut e1: ecs_entity_t,
	mut ptr1: *mut libc::c_void,
	mut e2: ecs_entity_t,
	mut ptr2: *mut libc::c_void,
) -> libc::c_int {
	return (e1 > e2) as libc::c_int - (e1 < e2) as libc::c_int;
}
unsafe extern "C" fn rank_phase(
	mut world: *mut ecs_world_t,
	mut rank_component: ecs_entity_t,
	mut type_0: ecs_type_t,
) -> libc::c_int {
	let mut pipeline_type: *const EcsType =
		ecs_get_w_entity(world, rank_component, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
	/* Find tag in system that belongs to pipeline */
	let mut sys_comps: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut c: int32_t = 0;
	let mut t: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut tags: *mut ecs_entity_t = _ecs_vector_first(
		(*pipeline_type).normalized,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut tag_count: int32_t = ecs_vector_count((*pipeline_type).normalized);
	let mut result: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	c = 0 as libc::c_int;
	while c < count {
		let mut comp: ecs_entity_t = *sys_comps.offset(c as isize);
		t = 0 as libc::c_int;
		while t < tag_count {
			if comp == *tags.offset(t as isize) {
				result = comp;
				break;
			} else {
				t += 1
			}
		}
		if result != 0 {
			break;
		}
		c += 1
	}
	return result as libc::c_int;
}
unsafe extern "C" fn get_write_state(
	mut write_state: *mut ecs_map_t,
	mut component: ecs_entity_t,
) -> int32_t {
	let mut ptr: *mut int32_t = _ecs_map_get(
		write_state,
		::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t,
		component,
	) as *mut int32_t;
	if !ptr.is_null() {
		return *ptr;
	} else {
		return 0 as libc::c_int;
	};
}
unsafe extern "C" fn set_write_state(
	mut write_state: *mut write_state_t,
	mut component: ecs_entity_t,
	mut value: int32_t,
) {
	if component == (256 as libc::c_int + 27 as libc::c_int) as libc::c_ulong {
		(*write_state).wildcard = 1 as libc::c_int != 0
	} else {
		_ecs_map_set(
			(*write_state).components,
			::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t,
			component,
			&mut value as *mut int32_t as *const libc::c_void,
		);
	};
}
unsafe extern "C" fn reset_write_state(mut write_state: *mut write_state_t) {
	ecs_map_clear((*write_state).components);
	(*write_state).wildcard = 0 as libc::c_int != 0;
}
unsafe extern "C" fn check_column_component(
	mut column: *mut ecs_sig_column_t,
	mut is_active: bool,
	mut component: ecs_entity_t,
	mut write_state: *mut write_state_t,
) -> bool {
	let mut state: int32_t = get_write_state((*write_state).components, component);
	if ((*column).from_kind as libc::c_uint == EcsFromAny as libc::c_int as libc::c_uint
		|| (*column).from_kind as libc::c_uint == EcsFromOwned as libc::c_int as libc::c_uint)
		&& (*column).oper_kind as libc::c_uint != EcsOperNot as libc::c_int as libc::c_uint
	{
		let mut current_block_8: u64;
		match (*column).inout_kind as libc::c_uint {
			0 | 1 => {
				if state == WriteToStage as libc::c_int {
					return 1 as libc::c_int != 0;
				} else {
					if (*write_state).wildcard {
						return 1 as libc::c_int != 0;
					}
				}
				current_block_8 = 18410374216165738068;
			}
			2 => {
				current_block_8 = 18410374216165738068;
			}
			_ => {
				current_block_8 = 2968425633554183086;
			}
		}
		match current_block_8 {
			18410374216165738068 =>
			// fall through
			{
				if is_active as libc::c_int != 0
					&& (*column).inout_kind as libc::c_uint != EcsIn as libc::c_int as libc::c_uint
				{
					set_write_state(write_state, component, WriteToMain as libc::c_int);
				}
			}
			_ => {}
		}
	} else if (*column).from_kind as libc::c_uint == EcsFromEmpty as libc::c_int as libc::c_uint
		|| (*column).oper_kind as libc::c_uint == EcsOperNot as libc::c_int as libc::c_uint
	{
		match (*column).inout_kind as libc::c_uint {
			0 | 2 => {
				if is_active {
					set_write_state(write_state, component, WriteToStage as libc::c_int);
				}
			}
			_ => {}
		}
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn check_column(
	mut column: *mut ecs_sig_column_t,
	mut is_active: bool,
	mut write_state: *mut write_state_t,
) -> bool {
	if (*column).oper_kind as libc::c_uint != EcsOperOr as libc::c_int as libc::c_uint {
		return check_column_component(column, is_active, (*column).is.component, write_state);
	}
	return 0 as libc::c_int != 0;
}
unsafe extern "C" fn build_pipeline(
	mut world: *mut ecs_world_t,
	mut pipeline: ecs_entity_t,
	mut pq: *mut EcsPipelineQuery,
) -> bool {
	ecs_query_iter((*pq).query);
	if (*pq).match_count == (*(*pq).query).match_count {
		/* No need to rebuild the pipeline */
		return 0 as libc::c_int != 0;
	}
	(*world).stats.pipeline_build_count_total += 1;
	let mut ws: write_state_t = {
		let mut init = write_state_t {
			components: _ecs_map_new(
				::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t,
				::std::mem::align_of::<int32_t>() as libc::c_ulong as int64_t as ecs_size_t,
				256 as libc::c_int,
			),
			wildcard: 0 as libc::c_int != 0,
		};
		init
	};
	let mut op: *mut ecs_pipeline_op_t = 0 as *mut ecs_pipeline_op_t;
	let mut ops: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
	let mut query: *mut ecs_query_t = (*pq).build_query;
	if !(*pq).ops.is_null() {
		ecs_vector_free((*pq).ops);
	}
	/* Iterate systems in pipeline, add ops for running / merging */
	let mut it: ecs_iter_t = ecs_query_iter(query);
	while ecs_query_next(&mut it) {
		let mut sys: *mut EcsSystem = ecs_column_w_size(
			&mut it,
			::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
			1 as libc::c_int,
		) as *mut EcsSystem;
		let mut i: libc::c_int = 0;
		i = 0 as libc::c_int;
		while i < it.count {
			let mut q: *mut ecs_query_t = (*sys.offset(i as isize)).query;
			if !q.is_null() {
				let mut needs_merge: bool = 0 as libc::c_int != 0;
				let mut is_active: bool = !ecs_has_entity(
					world,
					*it.entities.offset(i as isize),
					(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
				);
				let mut column_i: libc::c_int = 0;
				let mut column_count: libc::c_int = ecs_vector_count((*q).sig.columns);
				let mut column_array: *mut ecs_sig_column_t = _ecs_vector_first(
					(*q).sig.columns,
					::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_sig_column_t;
				column_i = 0 as libc::c_int;
				while column_i < column_count {
					let mut column: *mut ecs_sig_column_t =
						&mut *column_array.offset(column_i as isize) as *mut ecs_sig_column_t;
					needs_merge |= check_column(column, is_active, &mut ws);
					column_i += 1
				}
				if needs_merge {
					/* After merge all components will be merged, so reset state */
					reset_write_state(&mut ws);
					op = 0 as *mut ecs_pipeline_op_t;
					/* Re-evaluate columns to set write flags if system is active.
					 * If system is inactive, it can't write anything and so it
					 * should not insert unnecessary merges.  */
					needs_merge = 0 as libc::c_int != 0;
					if is_active {
						let mut column_i_0: libc::c_int = 0;
						let mut column_count_0: libc::c_int = ecs_vector_count((*q).sig.columns);
						let mut column_array_0: *mut ecs_sig_column_t = _ecs_vector_first(
							(*q).sig.columns,
							::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong
								as ecs_size_t,
							if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long > ::std::mem::align_of::<ecs_sig_column_t>()
								as libc::c_ulong as int64_t
							{
								::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
									as libc::c_long
							} else {
								::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong
									as int64_t
							} as int16_t,
						) as *mut ecs_sig_column_t;
						column_i_0 = 0 as libc::c_int;
						while column_i_0 < column_count_0 {
							let mut column_0: *mut ecs_sig_column_t = &mut *column_array_0
								.offset(column_i_0 as isize)
								as *mut ecs_sig_column_t;
							needs_merge |= check_column(column_0, 1 as libc::c_int != 0, &mut ws);
							column_i_0 += 1
						}
					}
				}
				if op.is_null() {
					op = _ecs_vector_add(
						&mut ops,
						::std::mem::size_of::<ecs_pipeline_op_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_pipeline_op_t>()
							as libc::c_ulong as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
						} as int16_t,
					) as *mut ecs_pipeline_op_t;
					(*op).count = 0 as libc::c_int
				}
				/* Don't increase count for inactive systems, as they are ignored by
				 * the query used to run the pipeline. */
				if is_active {
					(*op).count += 1
				}
			}
			i += 1
		}
	}
	ecs_map_free(ws.components);
	/* Force sort of query as this could increase the match_count */
	(*pq).match_count = (*(*pq).query).match_count;
	(*pq).ops = ops;
	return 1 as libc::c_int != 0;
}
unsafe extern "C" fn iter_reset(
	mut pq: *const EcsPipelineQuery,
	mut iter_out: *mut ecs_iter_t,
	mut op_out: *mut *mut ecs_pipeline_op_t,
	mut move_to: ecs_entity_t,
) -> int32_t {
	let mut op: *mut ecs_pipeline_op_t = _ecs_vector_first(
		(*pq).ops,
		::std::mem::size_of::<ecs_pipeline_op_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_pipeline_op_t;
	let mut ran_since_merge: int32_t = 0 as libc::c_int;
	let mut it: ecs_iter_t = ecs_query_iter((*pq).query);
	while ecs_query_next(&mut it) {
		let mut i: int32_t = 0;
		i = 0 as libc::c_int;
		while i < it.count {
			let mut e: ecs_entity_t = *it.entities.offset(i as isize);
			ran_since_merge += 1;
			if ran_since_merge == (*op).count {
				ran_since_merge = 0 as libc::c_int;
				op = op.offset(1)
			}
			if e == move_to {
				*iter_out = it;
				*op_out = op;
				return i;
			}
			i += 1
		}
	}
	_ecs_abort(
		35 as libc::c_int,
		0 as *const libc::c_char,
		b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
		30361 as libc::c_int,
	);
	abort();
}
// //////////////////////////////////////////////////////////////////////////////
// // Pipeline API
// //////////////////////////////////////////////////////////////////////////////
#[no_mangle]
pub unsafe extern "C" fn ecs_pipeline_update(
	mut world: *mut ecs_world_t,
	mut pipeline: ecs_entity_t,
) -> int32_t {
	let mut pq: *mut EcsPipelineQuery = ecs_get_mut_w_entity(
		world,
		pipeline,
		13 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsPipelineQuery;
	if build_pipeline(world, pipeline, pq) {
		return ecs_vector_count((*pq).ops);
	} else {
		return 0 as libc::c_int;
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_pipeline_begin(
	mut world: *mut ecs_world_t,
	mut pipeline: ecs_entity_t,
) -> int32_t {
	ecs_eval_component_monitors(world);
	let mut pq: *mut EcsPipelineQuery = ecs_get_mut_w_entity(
		world,
		pipeline,
		13 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsPipelineQuery;
	build_pipeline(world, pipeline, pq);
	return ecs_vector_count((*pq).ops);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_pipeline_end(mut world: *mut ecs_world_t) {}
#[no_mangle]
pub unsafe extern "C" fn ecs_pipeline_progress(
	mut world: *mut ecs_world_t,
	mut pipeline: ecs_entity_t,
	mut delta_time: libc::c_float,
) {
	let mut pq: *const EcsPipelineQuery =
		ecs_get_w_entity(world, pipeline, 13 as libc::c_int as ecs_entity_t)
			as *const EcsPipelineQuery;
	let mut ops: *mut ecs_vector_t = (*pq).ops;
	let mut op: *mut ecs_pipeline_op_t = _ecs_vector_first(
		ops,
		::std::mem::size_of::<ecs_pipeline_op_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_pipeline_op_t;
	let mut op_last: *mut ecs_pipeline_op_t = _ecs_vector_last(
		ops,
		::std::mem::size_of::<ecs_pipeline_op_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_pipeline_op_t;
	let mut ran_since_merge: int32_t = 0 as libc::c_int;
	ecs_worker_begin(world);
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut it: ecs_iter_t = ecs_query_iter((*pq).query);
	while ecs_query_next(&mut it) {
		let mut sys: *mut EcsSystem = ecs_column_w_size(
			&mut it,
			::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
			1 as libc::c_int,
		) as *mut EcsSystem;
		let mut i: int32_t = 0;
		i = 0 as libc::c_int;
		while i < it.count {
			let mut e: ecs_entity_t = *it.entities.offset(i as isize);
			ecs_run_intern(
				world,
				stage,
				e,
				&mut *sys.offset(i as isize),
				delta_time,
				0 as libc::c_int,
				0 as libc::c_int,
				0 as *const ecs_filter_t,
				0 as *mut libc::c_void,
				0 as libc::c_int != 0,
			);
			ran_since_merge += 1;
			(*world).stats.systems_ran_frame += 1;
			if op != op_last && ran_since_merge == (*op).count {
				ran_since_merge = 0 as libc::c_int;
				op = op.offset(1);
				/* If the set of matched systems changed as a result of the
				 * merge, we have to reset the iterator and move it to our
				 * current position (system). If there are a lot of systems
				 * in the pipeline this can be an expensive operation, but
				 * should happen infrequently. */
				if ecs_worker_sync(world) {
					i = iter_reset(pq, &mut it, &mut op, e);
					op_last = _ecs_vector_last(
						(*pq).ops,
						::std::mem::size_of::<ecs_pipeline_op_t>() as libc::c_ulong as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long > ::std::mem::align_of::<ecs_pipeline_op_t>()
							as libc::c_ulong as int64_t
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long
						} else {
							::std::mem::align_of::<ecs_pipeline_op_t>() as libc::c_ulong as int64_t
						} as int16_t,
					) as *mut ecs_pipeline_op_t;
					sys = ecs_column_w_size(
						&mut it,
						::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
						1 as libc::c_int,
					) as *mut EcsSystem
				}
			}
			i += 1
		}
	}
	ecs_worker_end(world);
}
unsafe extern "C" fn add_pipeline_tags_to_sig(
	mut world: *mut ecs_world_t,
	mut sig: *mut ecs_sig_t,
	mut type_0: ecs_type_t,
) {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(type_0);
	let mut entities: *mut ecs_entity_t = _ecs_vector_first(
		type_0,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	i = 0 as libc::c_int;
	while i < count {
		if i == 0 {
			ecs_sig_add(
				world,
				sig,
				EcsFromAny,
				EcsOperAnd,
				EcsIn,
				*entities.offset(i as isize),
				0 as libc::c_int as ecs_entity_t,
				0 as *const libc::c_char,
			);
		} else {
			ecs_sig_add(
				world,
				sig,
				EcsFromAny,
				EcsOperOr,
				EcsIn,
				*entities.offset(i as isize),
				0 as libc::c_int as ecs_entity_t,
				0 as *const libc::c_char,
			);
		}
		i += 1
	}
}
unsafe extern "C" fn EcsOnAddPipeline(mut it: *mut ecs_iter_t) {
	let mut world: *mut ecs_world_t = (*it).world;
	let mut entities: *mut ecs_entity_t = (*it).entities;
	let mut i: int32_t = 0;
	i = (*it).count - 1 as libc::c_int;
	while i >= 0 as libc::c_int {
		let mut pipeline: ecs_entity_t = *entities.offset(i as isize);
		let mut sig: ecs_sig_t = {
			let mut init = ecs_sig_t {
				name: 0 as *const libc::c_char,
				expr: 0 as *mut libc::c_char,
				columns: 0 as *mut ecs_vector_t,
			};
			init
		};
		let mut type_ptr: *const EcsType =
			ecs_get_w_entity(world, pipeline, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
		ecs_log_push();
		/* Build signature for pipeline quey that matches EcsSystems, has the
		 * pipeline as a XOR column, and ignores systems with EcsInactive and
		 * EcsDisabledIntern. Note that EcsDisabled is automatically ignored by
		 * the regular query matching */
		ecs_sig_add(
			world,
			&mut sig,
			EcsFromAny,
			EcsOperAnd,
			EcsIn,
			5 as libc::c_int as ecs_entity_t,
			0 as libc::c_int as ecs_entity_t,
			0 as *const libc::c_char,
		);
		ecs_sig_add(
			world,
			&mut sig,
			EcsFromAny,
			EcsOperNot,
			EcsIn,
			(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
			0 as libc::c_int as ecs_entity_t,
			0 as *const libc::c_char,
		);
		ecs_sig_add(
			world,
			&mut sig,
			EcsFromAny,
			EcsOperNot,
			EcsIn,
			(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
			0 as libc::c_int as ecs_entity_t,
			0 as *const libc::c_char,
		);
		add_pipeline_tags_to_sig(world, &mut sig, (*type_ptr).normalized);
		/* Create the query. Sort the query by system id and phase */
		let mut query: *mut ecs_query_t =
			ecs_query_new_w_sig(world, 0 as libc::c_int as ecs_entity_t, &mut sig);
		ecs_query_order_by(
			world,
			query,
			0 as libc::c_int as ecs_entity_t,
			Some(
				compare_entity
					as unsafe extern "C" fn(
						_: ecs_entity_t,
						_: *mut libc::c_void,
						_: ecs_entity_t,
						_: *mut libc::c_void,
					) -> libc::c_int,
			),
		);
		ecs_query_group_by(
			world,
			query,
			pipeline,
			Some(
				rank_phase
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: ecs_type_t,
					) -> libc::c_int,
			),
		);
		/* Build signature for pipeline build query. The build query includes
		 * systems that are inactive, as an inactive system may become active as
		 * a result of another system, and as a result the correct merge
		 * operations need to be put in place. */
		ecs_sig_add(
			world,
			&mut sig,
			EcsFromAny,
			EcsOperAnd,
			EcsIn,
			5 as libc::c_int as ecs_entity_t,
			0 as libc::c_int as ecs_entity_t,
			0 as *const libc::c_char,
		);
		ecs_sig_add(
			world,
			&mut sig,
			EcsFromAny,
			EcsOperNot,
			EcsIn,
			(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
			0 as libc::c_int as ecs_entity_t,
			0 as *const libc::c_char,
		);
		add_pipeline_tags_to_sig(world, &mut sig, (*type_ptr).normalized);
		/* Use the same sorting functions for the build query */
		let mut build_query: *mut ecs_query_t =
			ecs_query_new_w_sig(world, 0 as libc::c_int as ecs_entity_t, &mut sig);
		ecs_query_order_by(
			world,
			build_query,
			0 as libc::c_int as ecs_entity_t,
			Some(
				compare_entity
					as unsafe extern "C" fn(
						_: ecs_entity_t,
						_: *mut libc::c_void,
						_: ecs_entity_t,
						_: *mut libc::c_void,
					) -> libc::c_int,
			),
		);
		ecs_query_group_by(
			world,
			build_query,
			pipeline,
			Some(
				rank_phase
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: ecs_type_t,
					) -> libc::c_int,
			),
		);
		let mut pq: *mut EcsPipelineQuery = ecs_get_mut_w_entity(
			world,
			pipeline,
			13 as libc::c_int as ecs_entity_t,
			0 as *mut bool,
		) as *mut EcsPipelineQuery;
		(*pq).query = query;
		(*pq).build_query = build_query;
		(*pq).match_count = -(1 as libc::c_int);
		(*pq).ops = 0 as *mut ecs_vector_t;
		ecs_log_pop();
		i -= 1
	}
}
/* * Progress a world.
 * This operation progresses the world by running all systems that are both
 * enabled and periodic on their matching entities.
 *
 * An application can pass a delta_time into the function, which is the time
 * passed since the last frame. This value is passed to systems so they can
 * update entity values proportional to the elapsed time since their last
 * invocation.
 *
 * When an application passes 0 to delta_time, ecs_progress will automatically
 * measure the time passed since the last frame. If an application does not uses
 * time management, it should pass a non-zero value for delta_time (1.0 is
 * recommended). That way, no time will be wasted measuring the time.
 *
 * @param world The world to progress.
 * @param delta_time The time passed since the last frame.
 * @return false if ecs_quit has been called, true otherwise.
 */
/* -- Public API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_progress(
	mut world: *mut ecs_world_t,
	mut user_delta_time: libc::c_float,
) -> bool {
	ecs_frame_begin(world, user_delta_time);
	ecs_workers_progress(world);
	ecs_frame_end(world);
	return !(*world).should_quit;
}
/* * Set time scale.
 * Increase or decrease simulation speed by the provided multiplier.
 *
 * @param world The world.
 * @param scale The scale to apply (default = 1).
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_time_scale(mut world: *mut ecs_world_t, mut scale: libc::c_float) {
	(*world).stats.time_scale = scale;
}
/* * Reset world clock.
 * Reset the clock that keeps track of the total time passed in the simulation.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_reset_clock(mut world: *mut ecs_world_t) {
	(*world).stats.world_time_total = 0 as libc::c_int as libc::c_float;
	(*world).stats.world_time_total_raw = 0 as libc::c_int as libc::c_float;
}
/* * Signal exit
 * This operation signals that the application should quit. It will cause
 * ecs_progress to return false.
 *
 * @param world The world to quit.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_quit(mut world: *mut ecs_world_t) {
	ecs_get_stage(&mut world);
	(*world).should_quit = 1 as libc::c_int != 0;
}
/* * Deactivate systems that are not matched with tables.
 * By default Flecs deactivates systems that are not matched with any tables.
 * However, once a system has been matched with a table it remains activated, to
 * prevent systems from continuously becoming active and inactive.
 *
 * To re-deactivate systems, an application can invoke this function, which will
 * deactivate all systems that are not matched with any tables.
 *
 * @param world The world.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_deactivate_systems(mut world: *mut ecs_world_t) {
	let mut pipeline: ecs_entity_t = (*world).pipeline;
	let mut pq: *const EcsPipelineQuery =
		ecs_get_w_entity(world, pipeline, 13 as libc::c_int as ecs_entity_t)
			as *const EcsPipelineQuery;
	/* Iterate over all systems, add EcsInvalid tag if queries aren't matched
	 * with any tables */
	let mut it: ecs_iter_t = ecs_query_iter((*pq).build_query);
	/* Make sure that we defer adding the inactive tags until after iterating
	 * the query */
	ecs_defer_none(world, &mut (*world).stage);
	while ecs_query_next(&mut it) {
		let mut sys: *mut EcsSystem = ecs_column_w_size(
			&mut it,
			::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
			1 as libc::c_int,
		) as *mut EcsSystem;
		let mut i: int32_t = 0;
		i = 0 as libc::c_int;
		while i < it.count {
			let mut query: *mut ecs_query_t = (*sys.offset(i as isize)).query;
			if !query.is_null() {
				if ecs_vector_count((*query).tables) == 0 {
					ecs_add_entity(
						world,
						*it.entities.offset(i as isize),
						(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
					);
				}
			}
			i += 1
		}
	}
	ecs_defer_flush(world, &mut (*world).stage);
}
// //////////////////////////////////////////////////////////////////////////////
// // Pipeline API
// //////////////////////////////////////////////////////////////////////////////
/* * Set a custom pipeline.
 * This operation sets the pipeline to run when ecs_progress is invoked.
 *
 * @param world The world.
 * @param pipeline The pipeline to set.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_pipeline(mut world: *mut ecs_world_t, mut pipeline: ecs_entity_t) {
	(*world).pipeline = pipeline;
}
/* * Get the current pipeline.
 * This operation gets the current pipeline.
 *
 * @param world The world.
 * @param pipeline The pipeline to set.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_pipeline(mut world: *mut ecs_world_t) -> ecs_entity_t {
	return (*world).pipeline;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_pipeline(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
) -> ecs_entity_t {
	let mut result: ecs_entity_t = ecs_new_type(world, e, name, expr);
	ecs_add_entity(
		world,
		result,
		(256 as libc::c_int + 8 as libc::c_int) as ecs_entity_t,
	);
	return result;
}
/* -- Module implementation -- */
unsafe extern "C" fn FlecsPipelineFini(mut world: *mut ecs_world_t, mut ctx: *mut libc::c_void) {
	if !(*world).workers.is_null() {
		ecs_set_threads(world, 0 as libc::c_int);
	};
}
#[no_mangle]
pub unsafe extern "C" fn FlecsPipelineImport(mut world: *mut ecs_world_t) {
	let mut FLECS__EFlecsPipeline: ecs_entity_t = ecs_new_module(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"FlecsPipeline\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<FlecsPipeline>() as libc::c_ulong,
		::std::mem::align_of::<FlecsPipeline>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TFlecsPipeline_value: C2RustUnnamed_30 = {
		let mut init = C2RustUnnamed_30 {
			header: C2RustUnnamed_31 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsPipeline: *const ecs_vector_t =
		&mut __FLECS__TFlecsPipeline_value as *mut C2RustUnnamed_30 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsPipeline_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsPipeline as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut handles: *mut FlecsPipeline = ecs_get_mut_w_entity(
		world,
		FLECS__EFlecsPipeline,
		FLECS__EFlecsPipeline,
		0 as *mut bool,
	) as *mut FlecsPipeline;
	let mut FLECS__MFlecsSystem: FlecsSystem = FlecsSystem { dummy: 0 };
	let mut FlecsSystem__name: *mut libc::c_char =
		ecs_module_path_from_c(b"FlecsSystem\x00" as *const u8 as *const libc::c_char);
	let mut FLECS__EFlecsSystem: ecs_entity_t = ecs_import(
		world,
		Some(FlecsSystemImport as unsafe extern "C" fn(_: *mut ecs_world_t) -> ()),
		FlecsSystem__name,
		&mut FLECS__MFlecsSystem as *mut FlecsSystem as *mut libc::c_void,
		::std::mem::size_of::<FlecsSystem>() as libc::c_ulong,
	);
	ecs_os_api.free_.expect("non-null function pointer")(FlecsSystem__name as *mut libc::c_void);
	let mut __FLECS__TFlecsSystem_value: C2RustUnnamed_10 = {
		let mut init = C2RustUnnamed_10 {
			header: C2RustUnnamed_11 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsSystem: *const ecs_vector_t =
		&mut __FLECS__TFlecsSystem_value as *mut C2RustUnnamed_10 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsSystem_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsSystem as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	ecs_set_name_prefix(world, b"Ecs\x00" as *const u8 as *const libc::c_char);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 8 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPipeline\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPipeline\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 8 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_new_component(
		world,
		13 as libc::c_int as ecs_entity_t,
		b"EcsPipelineQuery\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsPipelineQuery>() as libc::c_ulong,
		::std::mem::align_of::<EcsPipelineQuery>() as libc::c_ulong as int64_t as size_t,
	);
	/* Phases of the builtin pipeline are regular entities. Names are set so
	 * they can be resolved by type expressions. */
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 13 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPreFrame\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPreFrame\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 13 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 14 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnLoad\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnLoad\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 14 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPostLoad\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPostLoad\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 16 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPreUpdate\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPreUpdate\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 16 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 17 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnUpdate\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnUpdate\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 17 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 18 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnValidate\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnValidate\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 18 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 19 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPostUpdate\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPostUpdate\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 19 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 20 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPreStore\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPreStore\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 20 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnStore\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnStore\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 22 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPostFrame\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPostFrame\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 22 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	memcpy(
		__FLECS__TEcsPipelineQuery_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsPipelineQuery as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	/* Set ctor and dtor for PipelineQuery */
	ecs_set_ptr_w_entity(
		world,
		13 as libc::c_int as ecs_entity_t,
		2 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsComponentLifecycle>() as libc::c_ulong,
		&mut {
			let mut init = EcsComponentLifecycle {
				ctor: Some(
					EcsPipelineQuery_ctor
						as unsafe extern "C" fn(
							_: *mut ecs_world_t,
							_: ecs_entity_t,
							_: *const ecs_entity_t,
							_: *mut libc::c_void,
							_: size_t,
							_: int32_t,
							_: *mut libc::c_void,
						) -> (),
				),
				dtor: Some(
					EcsPipelineQuery_dtor
						as unsafe extern "C" fn(
							_: *mut ecs_world_t,
							_: ecs_entity_t,
							_: *const ecs_entity_t,
							_: *mut libc::c_void,
							_: size_t,
							_: int32_t,
							_: *mut libc::c_void,
						) -> (),
				),
				copy: None,
				move_0: None,
				ctx: 0 as *mut libc::c_void,
			};
			init
		} as *mut EcsComponentLifecycle as *const libc::c_void,
	);
	/* When the Pipeline tag is added a pipeline will be created */
	let mut __FEcsOnAddPipeline: ecs_entity_t = ecs_new_trigger(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsOnAddPipeline\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 9 as libc::c_int) as ecs_entity_t,
		b"Pipeline\x00" as *const u8 as *const libc::c_char,
		Some(EcsOnAddPipeline as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ()),
	);
	let mut EcsOnAddPipeline_0: ecs_entity_t = __FEcsOnAddPipeline;
	/* Create the builtin pipeline */
	(*world).pipeline =
		ecs_new_pipeline(world, 0 as libc::c_int as ecs_entity_t,
							  b"BuiltinPipeline\x00" as *const u8 as
								  *const libc::c_char,
							  b"PreFrame, OnLoad, PostLoad, PreUpdate, OnUpdate, OnValidate, PostUpdate, PreStore, OnStore, PostFrame\x00"
								  as *const u8 as *const libc::c_char);
	/* Cleanup thread administration when world is destroyed */
	ecs_atfini(
		world,
		Some(
			FlecsPipelineFini
				as unsafe extern "C" fn(_: *mut ecs_world_t, _: *mut libc::c_void) -> (),
		),
		0 as *mut libc::c_void,
	); /* Initialize with remainder */
}
#[no_mangle]
pub static mut FLECS__TEcsTimer: ecs_type_t = 0 as *const ecs_vector_t;
#[no_mangle]
pub static mut FLECS__TEcsRateFilter: ecs_type_t = 0 as *const ecs_vector_t;
unsafe extern "C" fn AddTickSource(mut it: *mut ecs_iter_t) {
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_set_ptr_w_entity(
			(*it).world,
			*(*it).entities.offset(i as isize),
			7 as libc::c_int as ecs_entity_t,
			::std::mem::size_of::<EcsTickSource>() as libc::c_ulong,
			&mut {
				let mut init = EcsTickSource {
					tick: 0 as libc::c_int != 0,
					time_elapsed: 0.,
				};
				init
			} as *mut EcsTickSource as *const libc::c_void,
		);
		i += 1
	}
}
unsafe extern "C" fn ProgressTimers(mut it: *mut ecs_iter_t) {
	let mut timer: *mut EcsTimer = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTimer>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsTimer;
	let mut tick_source: *mut EcsTickSource = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTickSource>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsTickSource;
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		(*tick_source.offset(i as isize)).tick = 0 as libc::c_int != 0;
		if (*timer.offset(i as isize)).active {
			let mut time_elapsed: libc::c_float =
				(*timer.offset(i as isize)).time + (*(*it).world).stats.delta_time_raw;
			let mut timeout: libc::c_float = (*timer.offset(i as isize)).timeout;
			if time_elapsed >= timeout {
				let mut t: libc::c_float = time_elapsed - timeout;
				if t > timeout {
					t = 0 as libc::c_int as libc::c_float
				}
				(*timer.offset(i as isize)).time = t;
				(*tick_source.offset(i as isize)).tick = 1 as libc::c_int != 0;
				(*tick_source.offset(i as isize)).time_elapsed = time_elapsed;
				if (*timer.offset(i as isize)).single_shot {
					(*timer.offset(i as isize)).active = 0 as libc::c_int != 0
				}
			} else {
				(*timer.offset(i as isize)).time = time_elapsed
			}
		}
		i += 1
	}
}
unsafe extern "C" fn ProgressRateFilters(mut it: *mut ecs_iter_t) {
	let mut filter: *mut EcsRateFilter = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsRateFilter>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsRateFilter;
	let mut tick_dst: *mut EcsTickSource = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTickSource>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsTickSource;
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut src: ecs_entity_t = (*filter.offset(i as isize)).src;
		let mut inc: bool = 0 as libc::c_int != 0;
		(*filter.offset(i as isize)).time_elapsed += (*it).delta_time;
		if src != 0 {
			let mut tick_src: *const EcsTickSource =
				ecs_get_w_entity((*it).world, src, 7 as libc::c_int as ecs_entity_t)
					as *const EcsTickSource;
			if !tick_src.is_null() {
				inc = (*tick_src).tick
			}
		} else {
			inc = 1 as libc::c_int != 0
		}
		if inc {
			let ref mut fresh58 = (*filter.offset(i as isize)).tick_count;
			*fresh58 += 1;
			let mut triggered: bool =
				(*filter.offset(i as isize)).tick_count % (*filter.offset(i as isize)).rate == 0;
			(*tick_dst.offset(i as isize)).tick = triggered;
			(*tick_dst.offset(i as isize)).time_elapsed = (*filter.offset(i as isize)).time_elapsed;
			if triggered {
				(*filter.offset(i as isize)).time_elapsed = 0 as libc::c_int as libc::c_float
			}
		} else {
			(*tick_dst.offset(i as isize)).tick = 0 as libc::c_int != 0
		}
		i += 1
	}
}
// //////////////////////////////////////////////////////////////////////////////
// // Timer API
// //////////////////////////////////////////////////////////////////////////////
/* * Set timer timeout.
 * This operation executes any systems associated with the timer after the
 * specified timeout value. If the entity contains an existing timer, the
 * timeout value will be reset.
 *
 * Any entity can be used as a timer (including systems). If a timeout value is
 * set on a system entity, it will be automatically applied to that system.
 *
 * The timer is synchronous, and is incremented each frame by delta_time.
 *
 * @param world The world.
 * @param timer The timer for which to set the timeout (0 to create one).
 * @param timeout The timeout value.
 * @return The timer entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_timeout(
	mut world: *mut ecs_world_t,
	mut timer: ecs_entity_t,
	mut timeout: libc::c_float,
) -> ecs_entity_t {
	timer = ecs_set_ptr_w_entity(
		world,
		timer,
		14 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsTimer>() as libc::c_ulong,
		&mut {
			let mut init = EcsTimer {
				timeout: timeout,
				time: 0.,
				fired_count: 0,
				active: 1 as libc::c_int != 0,
				single_shot: 1 as libc::c_int != 0,
			};
			init
		} as *mut EcsTimer as *const libc::c_void,
	);
	let mut system_data: *mut EcsSystem = ecs_get_mut_w_entity(
		world,
		timer,
		5 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsSystem;
	if !system_data.is_null() {
		(*system_data).tick_source = timer
	}
	return timer;
}
/* * Get current timeout value for the specified timer.
 * This operation returns the value set by ecs_set_timeout. If no timer is
 * active for this entity, the operation returns 0.
 *
 * After the timeout expires the timer component is removed from the entity.
 * This means that if ecs_get_timeout is invoked after the timer is expired, the
 * operation will return 0.
 *
 * @param world The world.
 * @param timer The timer.
 * @return The current timeout value, or 0 if no timer is active.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_timeout(
	mut world: *mut ecs_world_t,
	mut timer: ecs_entity_t,
) -> libc::c_float {
	let mut value: *mut EcsTimer = ecs_get_mut_w_entity(
		world,
		timer,
		14 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsTimer;
	if !value.is_null() {
		return (*value).timeout;
	} else {
		return 0 as libc::c_int as libc::c_float;
	};
}
/* * Set timer interval.
 * This operation will continously invoke systems associated with the timer
 * after the interval period expires. If the entity contains an existing timer,
 * the interval value will be reset.
 *
 * Any entity can be used as a timer (including systems). If an interval value
 * is set on a system entity, it will be automatically applied to that system.
 *
 * The timer is synchronous, and is incremented each frame by delta_time.
 *
 * @param world The world.
 * @param timer The timer for which to set the interval (0 to create one).
 * @param interval The interval value.
 * @return The timer entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_interval(
	mut world: *mut ecs_world_t,
	mut timer: ecs_entity_t,
	mut interval: libc::c_float,
) -> ecs_entity_t {
	timer = ecs_set_ptr_w_entity(
		world,
		timer,
		14 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsTimer>() as libc::c_ulong,
		&mut {
			let mut init = EcsTimer {
				timeout: interval,
				time: 0.,
				fired_count: 0,
				active: 1 as libc::c_int != 0,
				single_shot: false,
			};
			init
		} as *mut EcsTimer as *const libc::c_void,
	);
	let mut system_data: *mut EcsSystem = ecs_get_mut_w_entity(
		world,
		timer,
		5 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsSystem;
	if !system_data.is_null() {
		(*system_data).tick_source = timer
	}
	return timer;
}
/* * Get current interval value for the specified timer.
 * This operation returns the value set by ecs_set_interval. If no timer is
 * active for this entity, the operation returns 0.
 *
 * @param world The world.
 * @param timer The timer for which to set the interval. If 0, an entity will be created.
 * @return The current interval value, or 0 if no timer is active.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_interval(
	mut world: *mut ecs_world_t,
	mut timer: ecs_entity_t,
) -> libc::c_float {
	if timer == 0 {
		return 0 as libc::c_int as libc::c_float;
	}
	let mut value: *mut EcsTimer = ecs_get_mut_w_entity(
		world,
		timer,
		14 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsTimer;
	if !value.is_null() {
		return (*value).timeout;
	} else {
		return 0 as libc::c_int as libc::c_float;
	};
}
/* * Start timer.
 * This operation resets the timer and starts it with the specified timeout. The
 * entity must have the EcsTimer component (added by ecs_set_timeout and
 * ecs_set_interval). If the entity does not have the EcsTimer component this
 * operation will assert.
 *
 * @param world The world.
 * @param timer The timer to start.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_start_timer(mut world: *mut ecs_world_t, mut timer: ecs_entity_t) {
	let mut ptr: *mut EcsTimer = ecs_get_mut_w_entity(
		world,
		timer,
		14 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsTimer;
	(*ptr).active = 1 as libc::c_int != 0;
	(*ptr).time = 0 as libc::c_int as libc::c_float;
}
/* * Stop timer
 * This operation stops a timer from triggering. The entity must have the
 * EcsTimer component or this operation will assert.
 *
 * @param world The world.
 * @param timer The timer to stop.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_stop_timer(mut world: *mut ecs_world_t, mut timer: ecs_entity_t) {
	let mut ptr: *mut EcsTimer = ecs_get_mut_w_entity(
		world,
		timer,
		14 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsTimer;
	(*ptr).active = 0 as libc::c_int != 0;
}
/* * Set rate filter.
 * This operation sets the source and rate for a rate filter. A rate filter
 * samples another tick source (or frames, if none provided) and ticks when the
 * number of sampled ticks equals the rate.
 *
 * @param world The world.
 * @param filter The filter entity (0 to create one).
 * @param rate The rate to apply.
 * @param source The tick source (0 to use frames)
 * @return The filter entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_rate_filter(
	mut world: *mut ecs_world_t,
	mut filter: ecs_entity_t,
	mut rate: int32_t,
	mut source: ecs_entity_t,
) -> ecs_entity_t {
	filter = ecs_set_ptr_w_entity(
		world,
		filter,
		15 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsRateFilter>() as libc::c_ulong,
		&mut {
			let mut init = EcsRateFilter {
				src: source,
				rate: rate,
				tick_count: 0,
				time_elapsed: 0.,
			};
			init
		} as *mut EcsRateFilter as *const libc::c_void,
	);
	let mut system_data: *mut EcsSystem = ecs_get_mut_w_entity(
		world,
		filter,
		5 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsSystem;
	if !system_data.is_null() {
		(*system_data).tick_source = filter
	}
	return filter;
}
/* * Assign tick source to system.
 * This operation associates a system with a tick source. If the system is both
 * active and enabled at the moment the tick source fires, it will be executed.
 * If no tick source is associated with a system, it will be invoked every
 * frame.
 *
 * To disassociate a tick source from a system, use 0 for the tick_source
 * parameter.
 *
 * Timer and rate filter entities are valid tick sources. An application can
 * also create its own tick source by setting the EcsTickSource component on an
 * entity.
 *
 * If an entity without the EcsTickSource component is provided as tick source,
 * the system will not be executed.
 *
 * @param world The world.
 * @param system The system to associate with the timer.
 * @param timer The timer to associate with the system.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_tick_source(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut tick_source: ecs_entity_t,
) {
	let mut system_data: *mut EcsSystem = ecs_get_mut_w_entity(
		world,
		system,
		5 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsSystem;
	(*system_data).tick_source = tick_source;
}
#[no_mangle]
pub unsafe extern "C" fn FlecsTimerImport(mut world: *mut ecs_world_t) {
	let mut FLECS__EFlecsTimer: ecs_entity_t = ecs_new_module(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"FlecsTimer\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<FlecsTimer>() as libc::c_ulong,
		::std::mem::align_of::<FlecsTimer>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TFlecsTimer_value: C2RustUnnamed_32 = {
		let mut init = C2RustUnnamed_32 {
			header: C2RustUnnamed_33 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsTimer: *const ecs_vector_t =
		&mut __FLECS__TFlecsTimer_value as *mut C2RustUnnamed_32 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsTimer_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsTimer as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut handles: *mut FlecsTimer = ecs_get_mut_w_entity(
		world,
		FLECS__EFlecsTimer,
		FLECS__EFlecsTimer,
		0 as *mut bool,
	) as *mut FlecsTimer;
	let mut FLECS__MFlecsPipeline: FlecsPipeline = FlecsPipeline { dummy: 0 };
	let mut FlecsPipeline__name: *mut libc::c_char =
		ecs_module_path_from_c(b"FlecsPipeline\x00" as *const u8 as *const libc::c_char);
	let mut FLECS__EFlecsPipeline: ecs_entity_t = ecs_import(
		world,
		Some(FlecsPipelineImport as unsafe extern "C" fn(_: *mut ecs_world_t) -> ()),
		FlecsPipeline__name,
		&mut FLECS__MFlecsPipeline as *mut FlecsPipeline as *mut libc::c_void,
		::std::mem::size_of::<FlecsPipeline>() as libc::c_ulong,
	);
	ecs_os_api.free_.expect("non-null function pointer")(FlecsPipeline__name as *mut libc::c_void);
	let mut __FLECS__TFlecsPipeline_value: C2RustUnnamed_6 = {
		let mut init = C2RustUnnamed_6 {
			header: C2RustUnnamed_7 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsPipeline: *const ecs_vector_t =
		&mut __FLECS__TFlecsPipeline_value as *mut C2RustUnnamed_6 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsPipeline_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsPipeline as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	ecs_set_name_prefix(world, b"Ecs\x00" as *const u8 as *const libc::c_char);
	ecs_new_component(
		world,
		14 as libc::c_int as ecs_entity_t,
		b"EcsTimer\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsTimer>() as libc::c_ulong,
		::std::mem::align_of::<EcsTimer>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		15 as libc::c_int as ecs_entity_t,
		b"EcsRateFilter\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsRateFilter>() as libc::c_ulong,
		::std::mem::align_of::<EcsRateFilter>() as libc::c_ulong as int64_t as size_t,
	);
	/* Add EcsTickSource to timers and rate filters */
	let mut FLECS__FAddTickSource: ecs_iter_action_t =
		Some(AddTickSource as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut AddTickSource_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"AddTickSource\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 13 as libc::c_int) as ecs_entity_t,
		b"[in] Timer || RateFilter, [out] !flecs.system.TickSource\x00" as *const u8
			as *const libc::c_char,
		FLECS__FAddTickSource,
	);
	/* Timer handling */
	let mut FLECS__FProgressTimers: ecs_iter_action_t =
		Some(ProgressTimers as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut ProgressTimers_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"ProgressTimers\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 13 as libc::c_int) as ecs_entity_t,
		b"Timer, flecs.system.TickSource\x00" as *const u8 as *const libc::c_char,
		FLECS__FProgressTimers,
	);
	/* Rate filter handling */
	let mut FLECS__FProgressRateFilters: ecs_iter_action_t =
		Some(ProgressRateFilters as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut ProgressRateFilters_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"ProgressRateFilters\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 13 as libc::c_int) as ecs_entity_t,
		b"[in] RateFilter, [out] flecs.system.TickSource\x00" as *const u8 as *const libc::c_char,
		FLECS__FProgressRateFilters,
	);
}
/* -- Systems that add components on interest */
unsafe extern "C" fn StatsAddWorldStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsWorldStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsWorldStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	ecs_set_ptr_w_entity(
		(*it).world,
		(256 as libc::c_int + 25 as libc::c_int) as ecs_entity_t,
		FLECS__EEcsWorldStats,
		::std::mem::size_of::<EcsWorldStats>() as libc::c_ulong,
		&mut {
			let mut init = EcsWorldStats {
				target_fps_hz: 0 as libc::c_int as libc::c_double,
				tables_count: 0,
				components_count: 0,
				col_systems_count: 0,
				row_systems_count: 0,
				inactive_systems_count: 0,
				entities_count: 0,
				threads_count: 0,
				frame_count_total: 0,
				frame_seconds_total: 0.,
				system_seconds_total: 0.,
				merge_seconds_total: 0.,
				world_seconds_total: 0.,
				fps_hz: 0.,
			};
			init
		} as *mut EcsWorldStats as *const libc::c_void,
	);
}
unsafe extern "C" fn StatsAddAllocStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsAllocStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsAllocStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	ecs_set_ptr_w_entity(
		(*it).world,
		(256 as libc::c_int + 25 as libc::c_int) as ecs_entity_t,
		FLECS__EEcsAllocStats,
		::std::mem::size_of::<EcsAllocStats>() as libc::c_ulong,
		&mut {
			let mut init = EcsAllocStats {
				malloc_count_total: 0 as libc::c_int as int64_t,
				realloc_count_total: 0,
				calloc_count_total: 0,
				free_count_total: 0,
			};
			init
		} as *mut EcsAllocStats as *const libc::c_void,
	);
}
unsafe extern "C" fn StatsAddMemoryStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsMemoryStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsMemoryStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	ecs_set_ptr_w_entity(
		(*it).world,
		(256 as libc::c_int + 25 as libc::c_int) as ecs_entity_t,
		FLECS__EEcsMemoryStats,
		::std::mem::size_of::<EcsMemoryStats>() as libc::c_ulong,
		&mut {
			let mut init = EcsMemoryStats {
				__dummy: 0 as libc::c_int,
				total_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				entities_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				components_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				systems_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				types_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				tables_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				stages_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
				world_memory: ecs_memory_stat_t {
					allocd_bytes: 0,
					used_bytes: 0,
				},
			};
			init
		} as *mut EcsMemoryStats as *const libc::c_void,
	);
}
unsafe extern "C" fn StatsAddSystemStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsSystemStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsSystemStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_set_ptr_w_entity(
			(*it).world,
			*(*it).entities.offset(i as isize),
			FLECS__EEcsSystemStats,
			::std::mem::size_of::<EcsSystemStats>() as libc::c_ulong,
			&mut {
				let mut init = EcsSystemStats {
					entity: 0 as libc::c_int as ecs_entity_t,
					name: 0 as *const libc::c_char,
					signature: 0 as *const libc::c_char,
					phase: 0,
					period_seconds: 0.,
					tables_matched_count: 0,
					entities_matched_count: 0,
					invoke_count_total: 0,
					seconds_total: 0.,
					is_enabled: false,
					is_active: false,
					is_hidden: false,
				};
				init
			} as *mut EcsSystemStats as *const libc::c_void,
		);
		i += 1
	}
}
unsafe extern "C" fn StatsAddColSystemMemoryStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsSystemMemoryStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsSystemMemoryStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_set_ptr_w_entity(
			(*it).world,
			*(*it).entities.offset(i as isize),
			FLECS__EEcsSystemMemoryStats,
			::std::mem::size_of::<EcsSystemMemoryStats>() as libc::c_ulong,
			&mut {
				let mut init = EcsSystemMemoryStats {
					base_memory_bytes: 0 as libc::c_int,
					columns_memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					active_tables_memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					inactive_tables_memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					jobs_memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					other_memory_bytes: 0,
				};
				init
			} as *mut EcsSystemMemoryStats as *const libc::c_void,
		);
		i += 1
	}
}
unsafe extern "C" fn StatsAddComponentStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsComponentStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsComponentStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_set_ptr_w_entity(
			(*it).world,
			*(*it).entities.offset(i as isize),
			FLECS__EEcsComponentStats,
			::std::mem::size_of::<EcsComponentStats>() as libc::c_ulong,
			&mut {
				let mut init = EcsComponentStats {
					entity: 0 as libc::c_int as ecs_entity_t,
					name: 0 as *const libc::c_char,
					size_bytes: 0,
					memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					entities_count: 0,
					tables_count: 0,
				};
				init
			} as *mut EcsComponentStats as *const libc::c_void,
		);
		i += 1
	}
}
unsafe extern "C" fn StatsAddTableStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsTableStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsTableStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_set_ptr_w_entity(
			(*it).world,
			*(*it).entities.offset(i as isize),
			FLECS__EEcsTableStats,
			::std::mem::size_of::<EcsTableStats>() as libc::c_ulong,
			&mut {
				let mut init = EcsTableStats {
					type_0: 0 as ecs_type_t,
					columns_count: 0,
					rows_count: 0,
					systems_matched_count: 0,
					entity_memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					component_memory: ecs_memory_stat_t {
						allocd_bytes: 0,
						used_bytes: 0,
					},
					other_memory_bytes: 0,
				};
				init
			} as *mut EcsTableStats as *const libc::c_void,
		);
		i += 1
	}
}
unsafe extern "C" fn StatsAddTypeStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsTypeStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsTypeStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_set_ptr_w_entity(
			(*it).world,
			*(*it).entities.offset(i as isize),
			FLECS__EEcsTypeStats,
			::std::mem::size_of::<EcsTypeStats>() as libc::c_ulong,
			&mut {
				let mut init = EcsTypeStats {
					entity: 0 as libc::c_int as ecs_entity_t,
					name: 0 as *const libc::c_char,
					type_0: 0 as *const ecs_vector_t,
					normalized_type: 0 as *const ecs_vector_t,
					entities_count: 0,
					entities_childof_count: 0,
					entities_instanceof_count: 0,
					components_count: 0,
					col_systems_count: 0,
					row_systems_count: 0,
					enabled_systems_count: 0,
					active_systems_count: 0,
					instance_count: 0,
					is_hidden: false,
				};
				init
			} as *mut EcsTypeStats as *const libc::c_void,
		);
		i += 1
	}
}
/* -- Systems that collect metrics on interest -- */
unsafe extern "C" fn StatsCollectWorldStats_StatusAction(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut status: ecs_system_status_t,
	mut ctx: *mut libc::c_void,
) {
	if status as libc::c_uint == EcsSystemActivated as libc::c_int as libc::c_uint {
		ecs_measure_frame_time(world, 1 as libc::c_int != 0);
	} else if status as libc::c_uint == EcsSystemDeactivated as libc::c_int as libc::c_uint {
		ecs_measure_frame_time(world, 0 as libc::c_int != 0);
	};
}
unsafe extern "C" fn StatsCollectWorldStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsWorldStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsWorldStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	let mut stats: *mut EcsWorldStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsWorldStats>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsWorldStats;
	let mut world: *mut ecs_world_t = (*it).world;
	(*stats).entities_count = ecs_sparse_count((*world).store.entity_index);
	(*stats).components_count = ecs_count_type(world, FLECS__TEcsComponent);
	(*stats).col_systems_count = ecs_count_type(world, FLECS__TEcsSystem);
	(*stats).tables_count = ecs_sparse_count((*world).store.tables);
	(*stats).threads_count = ecs_vector_count((*world).workers);
	(*stats).frame_seconds_total = (*world).stats.frame_time_total as libc::c_double;
	(*stats).system_seconds_total = (*world).stats.system_time_total as libc::c_double;
	(*stats).merge_seconds_total = (*world).stats.merge_time_total as libc::c_double;
	(*stats).world_seconds_total = (*world).stats.world_time_total as libc::c_double;
	(*stats).target_fps_hz = (*world).stats.target_fps as libc::c_double;
	(*stats).frame_count_total = (*world).stats.frame_count_total;
}
unsafe extern "C" fn StatsCollectAllocStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsAllocStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsAllocStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	let mut stats: *mut EcsAllocStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsAllocStats>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsAllocStats;
	(*stats).malloc_count_total = ecs_os_api_malloc_count;
	(*stats).calloc_count_total = ecs_os_api_calloc_count;
	(*stats).realloc_count_total = ecs_os_api_realloc_count;
	(*stats).free_count_total = ecs_os_api_free_count;
}
unsafe extern "C" fn StatsCollectColSystemMemoryTotals(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsSystemMemoryStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsSystemMemoryStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	let mut stats: *mut EcsSystemMemoryStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystemMemoryStats>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSystemMemoryStats;
	let mut stat: *mut ecs_memory_stat_t = (*it).param as *mut ecs_memory_stat_t;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		(*stat).allocd_bytes +=
			(*stats.offset(i as isize)).base_memory_bytes
				+ (*stats.offset(i as isize)).columns_memory.allocd_bytes
				+ (*stats.offset(i as isize))
					.active_tables_memory
					.allocd_bytes + (*stats.offset(i as isize))
				.inactive_tables_memory
				.allocd_bytes + (*stats.offset(i as isize)).jobs_memory.allocd_bytes
				+ (*stats.offset(i as isize)).other_memory_bytes;
		(*stat).used_bytes += (*stats.offset(i as isize)).base_memory_bytes
			+ (*stats.offset(i as isize)).columns_memory.used_bytes
			+ (*stats.offset(i as isize)).active_tables_memory.used_bytes
			+ (*stats.offset(i as isize))
				.inactive_tables_memory
				.used_bytes + (*stats.offset(i as isize)).jobs_memory.used_bytes
			+ (*stats.offset(i as isize)).other_memory_bytes;
		i += 1
	}
}
unsafe extern "C" fn StatsCollectTableMemoryTotals(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsTableStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsTableStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	let mut stats: *mut EcsTableStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTableStats>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsTableStats;
	let mut world_stats: *mut EcsMemoryStats = (*it).param as *mut EcsMemoryStats;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		(*world_stats).components_memory.used_bytes +=
			(*stats.offset(i as isize)).component_memory.used_bytes;
		(*world_stats).components_memory.allocd_bytes +=
			(*stats.offset(i as isize)).component_memory.allocd_bytes;
		(*world_stats).entities_memory.used_bytes +=
			(*stats.offset(i as isize)).entity_memory.used_bytes;
		(*world_stats).entities_memory.allocd_bytes +=
			(*stats.offset(i as isize)).entity_memory.allocd_bytes;
		(*world_stats).tables_memory.used_bytes += (*stats.offset(i as isize)).other_memory_bytes;
		(*world_stats).tables_memory.allocd_bytes += (*stats.offset(i as isize)).other_memory_bytes;
		i += 1
	}
}
unsafe extern "C" fn compute_world_memory(
	mut world: *mut ecs_world_t,
	mut stats: *mut EcsMemoryStats,
) {
	(*stats).world_memory.allocd_bytes =
		::std::mem::size_of::<ecs_world_t>() as libc::c_ulong as ecs_size_t;
	(*stats).world_memory.used_bytes = (*stats).world_memory.allocd_bytes;
	/* Add memory spent on worker threads to world memory */
	_ecs_vector_memory(
		(*world).workers,
		::std::mem::size_of::<ecs_thread_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_thread_t>() as libc::c_ulong as int64_t
		} as int16_t,
		&mut (*stats).world_memory.allocd_bytes,
		&mut (*stats).world_memory.used_bytes,
	);
	/* Add memory spent on on demand lookup structures to system memory */
	ecs_map_memory(
		(*world).on_enable_components,
		&mut (*stats).systems_memory.allocd_bytes,
		&mut (*stats).systems_memory.used_bytes,
	);
	ecs_map_memory(
		(*world).on_activate_components,
		&mut (*stats).systems_memory.allocd_bytes,
		&mut (*stats).systems_memory.used_bytes,
	);
	_ecs_vector_memory(
		(*world).fini_tasks,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		&mut (*stats).systems_memory.allocd_bytes,
		&mut (*stats).systems_memory.used_bytes,
	);
	/* Add table array to table memory */
	ecs_sparse_memory(
		(*world).store.tables,
		&mut (*stats).tables_memory.allocd_bytes,
		&mut (*stats).tables_memory.used_bytes,
	);
	/* Add misc lookup indices to world memory */
	ecs_map_memory(
		(*world).type_handles,
		&mut (*stats).world_memory.allocd_bytes,
		&mut (*stats).world_memory.used_bytes,
	);
	(*stats).stages_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	/* Compute memory used in temporary stage */
	(*stats).stages_memory.used_bytes +=
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t;
	(*stats).stages_memory.allocd_bytes +=
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t;
	/* Add memory used / allocated by worker_stages array */
	_ecs_vector_memory(
		(*world).worker_stages,
		::std::mem::size_of::<ecs_stage_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_stage_t>() as libc::c_ulong as int64_t
		} as int16_t,
		&mut (*stats).stages_memory.allocd_bytes,
		&mut (*stats).stages_memory.used_bytes,
	);
}
unsafe extern "C" fn StatsCollectMemoryStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsMemoryStats: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsMemoryStats: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	let mut stats: *mut EcsMemoryStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsMemoryStats>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsMemoryStats;
	let mut StatsCollectColSystemMemoryTotals_0: ecs_entity_t =
		ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TStatsCollectColSystemMemoryTotals: ecs_type_t =
		ecs_column_type(it, 2 as libc::c_int);
	let mut StatsCollectTableMemoryTotals_0: ecs_entity_t = ecs_column_entity(it, 3 as libc::c_int);
	let mut FLECS__TStatsCollectTableMemoryTotals: ecs_type_t =
		ecs_column_type(it, 3 as libc::c_int);
	let mut world: *mut ecs_world_t = (*it).world;
	/* Compute entity memory (entity index) */
	(*stats).entities_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	ecs_sparse_memory(
		(*world).store.entity_index,
		&mut (*stats).entities_memory.allocd_bytes,
		&mut (*stats).entities_memory.used_bytes,
	);
	/* Compute entity (entity columns), component and table memory */
	(*stats).components_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	(*stats).tables_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	ecs_run(
		world,
		StatsCollectTableMemoryTotals_0,
		0 as libc::c_int as libc::c_float,
		stats as *mut libc::c_void,
	);
	/* Compute system memory */
	(*stats).systems_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	ecs_run(
		world,
		StatsCollectColSystemMemoryTotals_0,
		0 as libc::c_int as libc::c_float,
		&mut (*stats).systems_memory as *mut ecs_memory_stat_t as *mut libc::c_void,
	);
	/* Compute world memory */
	compute_world_memory(world, stats);
	/* Add everything up to compute total memory */
	(*stats).total_memory.used_bytes = (*stats).entities_memory.used_bytes
		+ (*stats).components_memory.used_bytes
		+ (*stats).tables_memory.used_bytes
		+ (*stats).types_memory.used_bytes
		+ (*stats).stages_memory.used_bytes
		+ (*stats).systems_memory.used_bytes;
	(*stats).total_memory.allocd_bytes = (*stats).entities_memory.allocd_bytes
		+ (*stats).components_memory.allocd_bytes
		+ (*stats).tables_memory.allocd_bytes
		+ (*stats).types_memory.allocd_bytes
		+ (*stats).stages_memory.allocd_bytes
		+ (*stats).systems_memory.allocd_bytes;
}
unsafe extern "C" fn StatsCollectSystemStats_StatusAction(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut status: ecs_system_status_t,
	mut ctx: *mut libc::c_void,
) {
	if status as libc::c_uint == EcsSystemActivated as libc::c_int as libc::c_uint {
		ecs_measure_system_time(world, 1 as libc::c_int != 0);
	} else if status as libc::c_uint == EcsSystemDeactivated as libc::c_int as libc::c_uint {
		ecs_measure_system_time(world, 0 as libc::c_int != 0);
	};
}
unsafe extern "C" fn system_tables_matched(mut system: *mut EcsSystem) -> int32_t {
	return ecs_vector_count((*(*system).query).tables)
		+ ecs_vector_count((*(*system).query).empty_tables);
}
unsafe extern "C" fn system_entities_matched(mut system: *mut EcsSystem) -> int32_t {
	let mut tables: *mut ecs_matched_table_t = _ecs_vector_first(
		(*(*system).query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	let mut i: int32_t = 0;
	let mut total: int32_t = 0 as libc::c_int;
	let mut count: int32_t = ecs_vector_count((*(*system).query).tables);
	i = 0 as libc::c_int;
	while i < count {
		if !(*tables.offset(i as isize)).data.table.is_null() {
			total += ecs_table_count((*tables.offset(i as isize)).data.table)
		}
		i += 1
	}
	return total;
}
unsafe extern "C" fn StatsCollectSystemStats(mut it: *mut ecs_iter_t) {
	let mut system: *mut EcsSystem = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSystem;
	let mut FLECS__EEcsSystemStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsSystemStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut stats: *mut EcsSystemStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystemStats>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsSystemStats;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut entity: ecs_entity_t = *(*it).entities.offset(i as isize);
		(*stats.offset(i as isize)).entity = entity;
		let ref mut fresh59 = (*stats.offset(i as isize)).name;
		*fresh59 = ecs_get_name((*it).world, entity);
		let ref mut fresh60 = (*stats.offset(i as isize)).signature;
		*fresh60 = (*(*system.offset(i as isize)).query).sig.expr;
		(*stats.offset(i as isize)).phase = 0 as libc::c_int as ecs_entity_t;
		(*stats.offset(i as isize)).tables_matched_count =
			system_tables_matched(&mut *system.offset(i as isize));
		(*stats.offset(i as isize)).entities_matched_count =
			system_entities_matched(&mut *system.offset(i as isize));
		(*stats.offset(i as isize)).period_seconds =
			ecs_get_interval((*it).world, (*system.offset(i as isize)).tick_source);
		(*stats.offset(i as isize)).seconds_total = (*system.offset(i as isize)).time_spent;
		(*stats.offset(i as isize)).invoke_count_total =
			(*system.offset(i as isize)).invoke_count as int64_t;
		(*stats.offset(i as isize)).is_enabled = !ecs_has_entity(
			(*it).world,
			entity,
			(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
		);
		(*stats.offset(i as isize)).is_active =
			ecs_vector_count((*(*system.offset(i as isize)).query).tables) != 0 as libc::c_int;
		(*stats.offset(i as isize)).is_hidden = ecs_has_entity(
			(*it).world,
			entity,
			(256 as libc::c_int + 2 as libc::c_int) as ecs_entity_t,
		);
		i += 1
	}
}
unsafe extern "C" fn collect_system_table_metrics(
	mut system: *mut EcsSystem,
	mut tables: *mut ecs_vector_t,
	mut stat: *mut ecs_memory_stat_t,
) {
	let mut column_count: int32_t = ecs_vector_count((*(*system).query).sig.columns);
	_ecs_vector_memory(
		tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		&mut (*stat).allocd_bytes,
		&mut (*stat).used_bytes,
	);
	let mut count: int32_t = ecs_vector_count(tables);
	/* The 'column' member in ecs_matched_table_t */
	(*stat).allocd_bytes +=
		::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t * column_count * count;
	(*stat).used_bytes +=
		::std::mem::size_of::<int32_t>() as libc::c_ulong as ecs_size_t * column_count * count;
	/* The 'components' member of ecs_matched_table_t */
	(*stat).allocd_bytes +=
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * column_count * count;
	(*stat).used_bytes +=
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t * column_count * count;
}
unsafe extern "C" fn StatsCollectColSystemMemoryStats(mut it: *mut ecs_iter_t) {
	let mut system: *mut EcsSystem = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSystem;
	let mut FLECS__EEcsSystemMemoryStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsSystemMemoryStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut stats: *mut EcsSystemMemoryStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystemMemoryStats>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsSystemMemoryStats;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		(*stats.offset(i as isize)).base_memory_bytes =
			::std::mem::size_of::<EcsSystem>() as libc::c_ulong as ecs_size_t;
		(*stats.offset(i as isize)).columns_memory = {
			let mut init = ecs_memory_stat_t {
				allocd_bytes: 0 as libc::c_int,
				used_bytes: 0,
			};
			init
		};
		(*stats.offset(i as isize)).active_tables_memory = {
			let mut init = ecs_memory_stat_t {
				allocd_bytes: 0 as libc::c_int,
				used_bytes: 0,
			};
			init
		};
		(*stats.offset(i as isize)).inactive_tables_memory = {
			let mut init = ecs_memory_stat_t {
				allocd_bytes: 0 as libc::c_int,
				used_bytes: 0,
			};
			init
		};
		(*stats.offset(i as isize)).jobs_memory = {
			let mut init = ecs_memory_stat_t {
				allocd_bytes: 0 as libc::c_int,
				used_bytes: 0,
			};
			init
		};
		(*stats.offset(i as isize)).other_memory_bytes = 0 as libc::c_int;
		_ecs_vector_memory(
			(*(*system).query).sig.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
			&mut (*stats.offset(i as isize)).columns_memory.allocd_bytes,
			&mut (*stats.offset(i as isize)).columns_memory.used_bytes,
		);
		collect_system_table_metrics(
			system,
			(*(*system).query).tables,
			&mut (*stats.offset(i as isize)).active_tables_memory,
		);
		collect_system_table_metrics(
			system,
			(*(*system).query).empty_tables,
			&mut (*stats.offset(i as isize)).inactive_tables_memory,
		);
		if !(*system).on_demand.is_null() {
			let ref mut fresh61 = (*stats.offset(i as isize)).other_memory_bytes;
			*fresh61 += ::std::mem::size_of::<ecs_on_demand_out_t>() as libc::c_ulong as ecs_size_t
		}
		i += 1
	}
}
unsafe extern "C" fn StatsCollectComponentStats(mut it: *mut ecs_iter_t) {
	let mut component: *mut EcsComponent = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsComponent>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsComponent;
	let mut FLECS__EEcsComponentStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsComponentStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut stats: *mut EcsComponentStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsComponentStats>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsComponentStats;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut entity: ecs_entity_t = *(*it).entities.offset(i as isize);
		(*stats.offset(i as isize)).entity = entity;
		let ref mut fresh62 = (*stats.offset(i as isize)).name;
		*fresh62 = ecs_get_name((*it).world, entity);
		(*stats.offset(i as isize)).size_bytes = (*component.offset(i as isize)).size;
		/* Reset values */
		(*stats.offset(i as isize)).tables_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).entities_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).memory = {
			let mut init = ecs_memory_stat_t {
				allocd_bytes: 0 as libc::c_int,
				used_bytes: 0,
			};
			init
		};
		/* Walk tables to collect memory and entity stats per component */
		let mut tables: *mut ecs_sparse_t = (*(*it).world).store.tables;
		let mut t: int32_t = 0;
		let mut count: int32_t = ecs_sparse_count((*(*it).world).store.tables);
		t = 0 as libc::c_int;
		while t < count {
			let mut table: *mut ecs_table_t = _ecs_sparse_get(
				tables,
				::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
				t,
			) as *mut ecs_table_t;
			let mut components: *mut ecs_entity_t = _ecs_vector_first(
				(*table).type_0,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			let mut c: int32_t = 0;
			let mut c_count: int32_t = (*table).column_count;
			/* Iterate over table columns until component is found */
			let mut data: *mut ecs_data_t = ecs_table_get_data(table);
			let mut columns: *mut ecs_column_t = (*data).columns;
			c = 0 as libc::c_int;
			while c < c_count {
				if *components.offset(c as isize) == entity {
					let mut column: *mut ecs_vector_t = (*columns.offset(c as isize)).data;
					let ref mut fresh63 = (*stats.offset(i as isize)).tables_count;
					*fresh63 += 1;
					let ref mut fresh64 = (*stats.offset(i as isize)).entities_count;
					*fresh64 += ecs_vector_count(column);
					_ecs_vector_memory(
						column,
						(*columns.offset(c as isize)).size as ecs_size_t,
						if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							> (*columns.offset(c as isize)).alignment as libc::c_int
						{
							::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						} else {
							(*columns.offset(c as isize)).alignment as libc::c_int
						} as int16_t,
						&mut (*stats.offset(i as isize)).memory.allocd_bytes,
						&mut (*stats.offset(i as isize)).memory.used_bytes,
					);
					break;
				} else {
					c += 1
				}
			}
			t += 1
		}
		i += 1
	}
}
unsafe extern "C" fn StatsCollectTableStats_StatusAction(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut status: ecs_system_status_t,
	mut ctx: *mut libc::c_void,
) {
	let mut FLECS__TEcsTablePtr: ecs_type_t = ctx as ecs_type_t;
	let mut FLECS__EEcsTablePtr: ecs_entity_t = ecs_type_to_entity(world, FLECS__TEcsTablePtr);
	if status as libc::c_uint == EcsSystemEnabled as libc::c_int as libc::c_uint {
		/* Create an entity for every table */
		let mut tables: *mut ecs_sparse_t = (*world).store.tables;
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_sparse_count(tables);
		i = 0 as libc::c_int;
		while i < count {
			let mut table: *mut ecs_table_t = _ecs_sparse_get(
				tables,
				::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
				i,
			) as *mut ecs_table_t;
			ecs_set_ptr_w_entity(
				world,
				0 as libc::c_int as ecs_entity_t,
				FLECS__EEcsTablePtr,
				::std::mem::size_of::<EcsTablePtr>() as libc::c_ulong,
				&mut {
					let mut init = EcsTablePtr { table: table };
					init
				} as *mut EcsTablePtr as *const libc::c_void,
			);
			i += 1
		}
	} else if status as libc::c_uint == EcsSystemDisabled as libc::c_int as libc::c_uint {
		/* Delete all entities with EcsTable tag */
		ecs_bulk_delete(world, &mut {
			let mut init = ecs_filter_t {
				include: FLECS__TEcsTablePtr,
				exclude: 0 as *const ecs_vector_t,
				include_kind: EcsMatchAny,
				exclude_kind: EcsMatchDefault,
			};
			init
		});
	};
}
unsafe extern "C" fn collect_table_data_memory(
	mut table: *mut ecs_table_t,
	mut stats: *mut EcsTableStats,
) {
	let mut c: int32_t = 0;
	let mut count: int32_t = (*table).column_count;
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	let mut columns: *mut ecs_column_t = (*data).columns;
	(*stats).entity_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	_ecs_vector_memory(
		(*data).entities,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		&mut (*stats).entity_memory.allocd_bytes,
		&mut (*stats).entity_memory.used_bytes,
	);
	(*stats).component_memory = {
		let mut init = ecs_memory_stat_t {
			allocd_bytes: 0 as libc::c_int,
			used_bytes: 0,
		};
		init
	};
	c = 0 as libc::c_int;
	while c < count {
		let mut column: *mut ecs_column_t = &mut *columns.offset(c as isize) as *mut ecs_column_t;
		_ecs_vector_memory(
			(*column).data,
			(*columns).size as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
				> (*columns).alignment as libc::c_int
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
			} else {
				(*columns).alignment as libc::c_int
			} as int16_t,
			&mut (*stats).component_memory.allocd_bytes,
			&mut (*stats).component_memory.used_bytes,
		);
		c += 1
	}
}
unsafe extern "C" fn StatsCollectTableStats(mut it: *mut ecs_iter_t) {
	let mut FLECS__EEcsTablePtr: ecs_entity_t = ecs_column_entity(it, 1 as libc::c_int);
	let mut FLECS__TEcsTablePtr: ecs_type_t = ecs_column_type(it, 1 as libc::c_int);
	let mut table_ptr: *mut EcsTablePtr = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTablePtr>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsTablePtr;
	let mut FLECS__EEcsTableStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsTableStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut stats: *mut EcsTableStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTableStats>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsTableStats;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut table: *mut ecs_table_t = (*table_ptr.offset(i as isize)).table;
		let mut data: *mut ecs_data_t = ecs_table_get_data(table);
		let mut columns: *mut ecs_column_t = (*data).columns;
		let mut type_0: ecs_type_t = (*table).type_0;
		let ref mut fresh65 = (*stats.offset(i as isize)).type_0;
		*fresh65 = (*table).type_0;
		(*stats.offset(i as isize)).columns_count = ecs_vector_count(type_0);
		(*stats.offset(i as isize)).rows_count =
			ecs_vector_count((*columns.offset(0 as libc::c_int as isize)).data);
		(*stats.offset(i as isize)).systems_matched_count = ecs_vector_count((*table).queries);
		(*stats.offset(i as isize)).other_memory_bytes = ::std::mem::size_of::<ecs_column_t>()
			as libc::c_ulong as ecs_size_t
			+ ecs_vector_count(type_0)
			+ ::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t
				* ecs_vector_count((*table).queries);
		collect_table_data_memory(table, &mut *stats.offset(i as isize));
		i += 1
	}
}
unsafe extern "C" fn StatsCollectTypeStats(mut it: *mut ecs_iter_t) {
	let mut type_component: *mut EcsType = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsType>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsType;
	let mut FLECS__EEcsTypeStats: ecs_entity_t = ecs_column_entity(it, 2 as libc::c_int);
	let mut FLECS__TEcsTypeStats: ecs_type_t = ecs_column_type(it, 2 as libc::c_int);
	let mut stats: *mut EcsTypeStats = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTypeStats>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsTypeStats;
	let mut world: *mut ecs_world_t = (*it).world;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let ref mut fresh66 = (*stats.offset(i as isize)).name;
		*fresh66 = ecs_get_name(world, *(*it).entities.offset(i as isize));
		(*stats.offset(i as isize)).entity = *(*it).entities.offset(i as isize);
		let ref mut fresh67 = (*stats.offset(i as isize)).type_0;
		*fresh67 = (*type_component.offset(i as isize)).type_0;
		let ref mut fresh68 = (*stats.offset(i as isize)).normalized_type;
		*fresh68 = (*type_component.offset(i as isize)).normalized;
		(*stats.offset(i as isize)).is_hidden = ecs_has_entity(
			world,
			*(*it).entities.offset(i as isize),
			(256 as libc::c_int + 2 as libc::c_int) as ecs_entity_t,
		);
		(*stats.offset(i as isize)).entities_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).entities_childof_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).entities_instanceof_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).components_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).col_systems_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).row_systems_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).enabled_systems_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).active_systems_count = 0 as libc::c_int;
		(*stats.offset(i as isize)).instance_count =
			ecs_count_type(world, (*type_component.offset(i as isize)).normalized);
		let mut j: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*type_component.offset(i as isize)).normalized);
		let mut entities: *mut ecs_entity_t = _ecs_vector_first(
			(*type_component.offset(i as isize)).normalized,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		j = 0 as libc::c_int;
		while j < count {
			let mut e: ecs_entity_t = *entities.offset(j as isize);
			let mut has_flags: bool = 0 as libc::c_int != 0;
			if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			{
				let ref mut fresh69 = (*stats.offset(i as isize)).entities_childof_count;
				*fresh69 += 1;
				has_flags = 1 as libc::c_int != 0
			}
			if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7e as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			{
				let ref mut fresh70 = (*stats.offset(i as isize)).entities_instanceof_count;
				*fresh70 += 1;
				has_flags = 1 as libc::c_int != 0
			}
			if !has_flags {
				if ecs_has_type(world, e, FLECS__TEcsComponent) {
					let ref mut fresh71 = (*stats.offset(i as isize)).components_count;
					*fresh71 += 1
				} else if ecs_has_type(world, e, FLECS__TEcsSystem) {
					let ref mut fresh72 = (*stats.offset(i as isize)).col_systems_count;
					*fresh72 += 1;
					if !ecs_has_entity(
						world,
						e,
						(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
					) {
						let ref mut fresh73 = (*stats.offset(i as isize)).enabled_systems_count;
						*fresh73 += 1
					}
					let mut ptr: *const EcsSystem =
						ecs_get_w_entity(world, e, 5 as libc::c_int as ecs_entity_t)
							as *const EcsSystem;
					if ecs_vector_count((*(*ptr).query).tables) != 0 {
						let ref mut fresh74 = (*stats.offset(i as isize)).active_systems_count;
						*fresh74 += 1
					}
				} else {
					let ref mut fresh75 = (*stats.offset(i as isize)).entities_count;
					*fresh75 += 1
				}
			}
			j += 1
		}
		i += 1
	}
}
/* -- Module import function -- */
#[no_mangle]
pub unsafe extern "C" fn FlecsStatsImport(mut world: *mut ecs_world_t) {
	let mut FLECS__EFlecsStats: ecs_entity_t = ecs_new_module(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"FlecsStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<FlecsStats>() as libc::c_ulong,
		::std::mem::align_of::<FlecsStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TFlecsStats_value: C2RustUnnamed_58 = {
		let mut init = C2RustUnnamed_58 {
			header: C2RustUnnamed_59 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsStats: *const ecs_vector_t =
		&mut __FLECS__TFlecsStats_value as *mut C2RustUnnamed_58 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut handles: *mut FlecsStats = ecs_get_mut_w_entity(
		world,
		FLECS__EFlecsStats,
		FLECS__EFlecsStats,
		0 as *mut bool,
	) as *mut FlecsStats;
	let mut FLECS__MFlecsPipeline: FlecsPipeline = FlecsPipeline { dummy: 0 };
	let mut FlecsPipeline__name: *mut libc::c_char =
		ecs_module_path_from_c(b"FlecsPipeline\x00" as *const u8 as *const libc::c_char);
	let mut FLECS__EFlecsPipeline: ecs_entity_t = ecs_import(
		world,
		Some(FlecsPipelineImport as unsafe extern "C" fn(_: *mut ecs_world_t) -> ()),
		FlecsPipeline__name,
		&mut FLECS__MFlecsPipeline as *mut FlecsPipeline as *mut libc::c_void,
		::std::mem::size_of::<FlecsPipeline>() as libc::c_ulong,
	);
	ecs_os_api.free_.expect("non-null function pointer")(FlecsPipeline__name as *mut libc::c_void);
	let mut __FLECS__TFlecsPipeline_value: C2RustUnnamed_56 = {
		let mut init = C2RustUnnamed_56 {
			header: C2RustUnnamed_57 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsPipeline: *const ecs_vector_t =
		&mut __FLECS__TFlecsPipeline_value as *mut C2RustUnnamed_56 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsPipeline_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsPipeline as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	ecs_set_name_prefix(world, b"Ecs\x00" as *const u8 as *const libc::c_char);
	let mut FLECS__EEcsAllocStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsAllocStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsAllocStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsAllocStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsAllocStats_value: C2RustUnnamed_52 = {
		let mut init = C2RustUnnamed_52 {
			header: C2RustUnnamed_53 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsAllocStats: *const ecs_vector_t =
		&mut __FLECS__TEcsAllocStats_value as *mut C2RustUnnamed_52 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsAllocStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsAllocStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsWorldStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsWorldStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsWorldStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsWorldStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsWorldStats_value: C2RustUnnamed_50 = {
		let mut init = C2RustUnnamed_50 {
			header: C2RustUnnamed_51 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsWorldStats: *const ecs_vector_t =
		&mut __FLECS__TEcsWorldStats_value as *mut C2RustUnnamed_50 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsWorldStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsWorldStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsMemoryStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsMemoryStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsMemoryStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsMemoryStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsMemoryStats_value: C2RustUnnamed_48 = {
		let mut init = C2RustUnnamed_48 {
			header: C2RustUnnamed_49 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsMemoryStats: *const ecs_vector_t =
		&mut __FLECS__TEcsMemoryStats_value as *mut C2RustUnnamed_48 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsMemoryStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsMemoryStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsSystemStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsSystemStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsSystemStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsSystemStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsSystemStats_value: C2RustUnnamed_46 = {
		let mut init = C2RustUnnamed_46 {
			header: C2RustUnnamed_47 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsSystemStats: *const ecs_vector_t =
		&mut __FLECS__TEcsSystemStats_value as *mut C2RustUnnamed_46 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsSystemStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsSystemStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsSystemMemoryStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsSystemMemoryStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsSystemMemoryStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsSystemMemoryStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsSystemMemoryStats_value: C2RustUnnamed_44 = {
		let mut init = C2RustUnnamed_44 {
			header: C2RustUnnamed_45 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsSystemMemoryStats: *const ecs_vector_t =
		&mut __FLECS__TEcsSystemMemoryStats_value as *mut C2RustUnnamed_44 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsSystemMemoryStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsSystemMemoryStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsRowSystemMemoryStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsRowSystemMemoryStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsRowSystemMemoryStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsRowSystemMemoryStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsRowSystemMemoryStats_value: C2RustUnnamed_54 = {
		let mut init = C2RustUnnamed_54 {
			header: C2RustUnnamed_55 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsRowSystemMemoryStats: *const ecs_vector_t =
		&mut __FLECS__TEcsRowSystemMemoryStats_value as *mut C2RustUnnamed_54 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsRowSystemMemoryStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsRowSystemMemoryStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsComponentStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsComponentStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsComponentStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsComponentStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsComponentStats_value: C2RustUnnamed_42 = {
		let mut init = C2RustUnnamed_42 {
			header: C2RustUnnamed_43 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsComponentStats: *const ecs_vector_t =
		&mut __FLECS__TEcsComponentStats_value as *mut C2RustUnnamed_42 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsComponentStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsComponentStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsTableStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsTableStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsTableStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsTableStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsTableStats_value: C2RustUnnamed_40 = {
		let mut init = C2RustUnnamed_40 {
			header: C2RustUnnamed_41 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsTableStats: *const ecs_vector_t =
		&mut __FLECS__TEcsTableStats_value as *mut C2RustUnnamed_40 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsTableStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsTableStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsTablePtr: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsTablePtr\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsTablePtr>() as libc::c_ulong,
		::std::mem::align_of::<EcsTablePtr>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsTablePtr_value: C2RustUnnamed_38 = {
		let mut init = C2RustUnnamed_38 {
			header: C2RustUnnamed_39 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsTablePtr: *const ecs_vector_t =
		&mut __FLECS__TEcsTablePtr_value as *mut C2RustUnnamed_38 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsTablePtr_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsTablePtr as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut FLECS__EEcsTypeStats: ecs_entity_t = ecs_new_component(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsTypeStats\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsTypeStats>() as libc::c_ulong,
		::std::mem::align_of::<EcsTypeStats>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TEcsTypeStats_value: C2RustUnnamed_36 = {
		let mut init = C2RustUnnamed_36 {
			header: C2RustUnnamed_37 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TEcsTypeStats: *const ecs_vector_t =
		&mut __FLECS__TEcsTypeStats_value as *mut C2RustUnnamed_36 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TEcsTypeStats_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EEcsTypeStats as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut EcsStatsSkipCollect: ecs_entity_t = ecs_new_entity(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EcsStatsSkipCollect\x00" as *const u8 as *const libc::c_char,
		b"0\x00" as *const u8 as *const libc::c_char,
	);
	/* -- Helper systems -- */
	let mut FLECS__FStatsCollectColSystemMemoryTotals: ecs_iter_action_t =
		Some(StatsCollectColSystemMemoryTotals as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectColSystemMemoryTotals_0: ecs_entity_t =
		ecs_new_system(world, 0 as libc::c_int as ecs_entity_t,
							b"StatsCollectColSystemMemoryTotals\x00" as *const u8
								as *const libc::c_char,
							0 as libc::c_int as ecs_entity_t,
							b"[in] EcsSystemMemoryStats, [out] World:EcsMemoryStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00"
								as *const u8 as *const libc::c_char,
							FLECS__FStatsCollectColSystemMemoryTotals);
	let mut FLECS__FStatsCollectTableMemoryTotals: ecs_iter_action_t =
		Some(StatsCollectTableMemoryTotals as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectTableMemoryTotals_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectTableMemoryTotals\x00" as *const u8 as *const libc::c_char,
		0 as libc::c_int as ecs_entity_t,
		b"[in] EcsTableStats, [out] World:EcsMemoryStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00"
			as *const u8 as *const libc::c_char,
		FLECS__FStatsCollectTableMemoryTotals,
	);
	/* -- Component creation systems -- */
	let mut FLECS__FStatsAddWorldStats: ecs_iter_action_t =
		Some(StatsAddWorldStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddWorldStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsAddWorldStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		b"[out] !World:EcsWorldStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsAddWorldStats,
	);
	let mut FLECS__FStatsAddAllocStats: ecs_iter_action_t =
		Some(StatsAddAllocStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddAllocStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsAddAllocStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		b"[out] !World:EcsAllocStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsAddAllocStats,
	);
	let mut FLECS__FStatsAddMemoryStats: ecs_iter_action_t =
		Some(StatsAddMemoryStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddMemoryStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsAddMemoryStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"[out] !World:EcsMemoryStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsAddMemoryStats,
	);
	let mut FLECS__FStatsAddSystemStats: ecs_iter_action_t =
		Some(StatsAddSystemStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddSystemStats_0: ecs_entity_t =
		ecs_new_system(world, 0 as libc::c_int as ecs_entity_t,
							b"StatsAddSystemStats\x00" as *const u8 as
								*const libc::c_char,
							(256 as libc::c_int + 21 as libc::c_int) as
								ecs_entity_t,
							b"flecs.system.EcsSystem, [out] !EcsSystemStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden, SYSTEM:EcsStatsSkipCollect, !EcsStatsSkipCollect\x00"
								as *const u8 as *const libc::c_char,
							FLECS__FStatsAddSystemStats);
	let mut FLECS__FStatsAddColSystemMemoryStats: ecs_iter_action_t =
		Some(StatsAddColSystemMemoryStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddColSystemMemoryStats_0: ecs_entity_t =
		ecs_new_system(world, 0 as libc::c_int as ecs_entity_t,
							b"StatsAddColSystemMemoryStats\x00" as *const u8 as
								*const libc::c_char,
							(256 as libc::c_int + 21 as libc::c_int) as
								ecs_entity_t,
							b"flecs.system.EcsSystem, [out] !EcsSystemMemoryStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden, SYSTEM:EcsStatsSkipCollect, !EcsStatsSkipCollect\x00"
								as *const u8 as *const libc::c_char,
							FLECS__FStatsAddColSystemMemoryStats);
	let mut FLECS__FStatsAddComponentStats: ecs_iter_action_t =
		Some(StatsAddComponentStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddComponentStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsAddComponentStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		b"EcsComponent, [out] !EcsComponentStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00"
			as *const u8 as *const libc::c_char,
		FLECS__FStatsAddComponentStats,
	);
	let mut FLECS__FStatsAddTableStats: ecs_iter_action_t =
		Some(StatsAddTableStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddTableStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsAddTableStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		b"EcsTablePtr, [out] !EcsTableStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsAddTableStats,
	);
	let mut FLECS__FStatsAddTypeStats: ecs_iter_action_t =
		Some(StatsAddTypeStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsAddTypeStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsAddTypeStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 21 as libc::c_int) as ecs_entity_t,
		b"EcsType, [out] !EcsTypeStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsAddTypeStats,
	);
	/* -- Metrics collection systems -- */
	let mut FLECS__FStatsCollectWorldStats: ecs_iter_action_t =
		Some(StatsCollectWorldStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectWorldStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectWorldStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"[out] EcsWorldStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsCollectWorldStats,
	);
	/* This handler enables frame time monitoring when system is activated */
	ecs_set_system_status_action(
		world,
		StatsCollectWorldStats_0,
		Some(
			StatsCollectWorldStats_StatusAction
				as unsafe extern "C" fn(
					_: *mut ecs_world_t,
					_: ecs_entity_t,
					_: ecs_system_status_t,
					_: *mut libc::c_void,
				) -> (),
		),
		0 as *const libc::c_void,
	);
	let mut FLECS__FStatsCollectAllocStats: ecs_iter_action_t =
		Some(StatsCollectAllocStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectAllocStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectAllocStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"[out] EcsAllocStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsCollectAllocStats,
	);
	let mut FLECS__FStatsCollectMemoryStats: ecs_iter_action_t =
		Some(StatsCollectMemoryStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectMemoryStats_0: ecs_entity_t =
		ecs_new_system(world, 0 as libc::c_int as ecs_entity_t,
							b"StatsCollectMemoryStats\x00" as *const u8 as
								*const libc::c_char,
							(256 as libc::c_int + 15 as libc::c_int) as
								ecs_entity_t,
							b"[out] EcsMemoryStats, :StatsCollectColSystemMemoryTotals, :StatsCollectTableMemoryTotals, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00"
								as *const u8 as *const libc::c_char,
							FLECS__FStatsCollectMemoryStats);
	let mut FLECS__FStatsCollectSystemStats: ecs_iter_action_t =
		Some(StatsCollectSystemStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectSystemStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectSystemStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"flecs.system.EcsSystem, [out] EcsSystemStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00"
			as *const u8 as *const libc::c_char,
		FLECS__FStatsCollectSystemStats,
	);
	/* This handler enables system time monitoring when system is activated */
	ecs_set_system_status_action(
		world,
		StatsCollectSystemStats_0,
		Some(
			StatsCollectSystemStats_StatusAction
				as unsafe extern "C" fn(
					_: *mut ecs_world_t,
					_: ecs_entity_t,
					_: ecs_system_status_t,
					_: *mut libc::c_void,
				) -> (),
		),
		0 as *const libc::c_void,
	);
	let mut FLECS__FStatsCollectColSystemMemoryStats: ecs_iter_action_t =
		Some(StatsCollectColSystemMemoryStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectColSystemMemoryStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectColSystemMemoryStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"flecs.system.EcsSystem, [out] EcsSystemMemoryStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00"
			as *const u8 as *const libc::c_char,
		FLECS__FStatsCollectColSystemMemoryStats,
	);
	let mut FLECS__FStatsCollectComponentStats: ecs_iter_action_t =
		Some(StatsCollectComponentStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectComponentStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectComponentStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"EcsComponent, [out] EcsComponentStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsCollectComponentStats,
	);
	let mut FLECS__FStatsCollectTableStats: ecs_iter_action_t =
		Some(StatsCollectTableStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectTableStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectTableStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"EcsTablePtr, [out] EcsTableStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsCollectTableStats,
	);
	/* This handler creates entities for tables when system is enabled */
	ecs_set_system_status_action(
		world,
		StatsCollectTableStats_0,
		Some(
			StatsCollectTableStats_StatusAction
				as unsafe extern "C" fn(
					_: *mut ecs_world_t,
					_: ecs_entity_t,
					_: ecs_system_status_t,
					_: *mut libc::c_void,
				) -> (),
		),
		FLECS__TEcsTablePtr as *const libc::c_void,
	);
	let mut FLECS__FStatsCollectTypeStats: ecs_iter_action_t =
		Some(StatsCollectTypeStats as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut StatsCollectTypeStats_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"StatsCollectTypeStats\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 15 as libc::c_int) as ecs_entity_t,
		b"EcsType, [out] EcsTypeStats, SYSTEM:EcsOnDemand, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FStatsCollectTypeStats,
	);
	/* Export components to module */
	if !handles.is_null() {
		(*handles).FLECS__EEcsAllocStats = FLECS__EEcsAllocStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsAllocStats = FLECS__TEcsAllocStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsWorldStats = FLECS__EEcsWorldStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsWorldStats = FLECS__TEcsWorldStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsMemoryStats = FLECS__EEcsMemoryStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsMemoryStats = FLECS__TEcsMemoryStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsSystemStats = FLECS__EEcsSystemStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsSystemStats = FLECS__TEcsSystemStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsSystemMemoryStats = FLECS__EEcsSystemMemoryStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsSystemMemoryStats = FLECS__TEcsSystemMemoryStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsComponentStats = FLECS__EEcsComponentStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsComponentStats = FLECS__TEcsComponentStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsTableStats = FLECS__EEcsTableStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsTableStats = FLECS__TEcsTableStats
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsTablePtr = FLECS__EEcsTablePtr
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsTablePtr = FLECS__TEcsTablePtr
	}
	if !handles.is_null() {
		(*handles).FLECS__EEcsTypeStats = FLECS__EEcsTypeStats
	}
	if !handles.is_null() {
		(*handles).FLECS__TEcsTypeStats = FLECS__TEcsTypeStats
	};
}
/* Global type variables */
static mut __EcsComponentLifecycle: ecs_entity_t = 2 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut __FLECS__TEcsComponentLifecycle_value: C2RustUnnamed_0 = {
	let mut init = C2RustUnnamed_0 {
		header: C2RustUnnamed_1 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
#[no_mangle]
pub static mut FLECS__TEcsComponentLifecycle: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsComponentLifecycle_value as *const C2RustUnnamed_0 as *mut C2RustUnnamed_0
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsTrigger_value: C2RustUnnamed_26 = {
	let mut init = C2RustUnnamed_26 {
		header: C2RustUnnamed_27 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
#[no_mangle]
pub static mut FLECS__TEcsTrigger: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsTrigger_value as *const C2RustUnnamed_26 as *mut C2RustUnnamed_26
		as *mut ecs_vector_t
};
static mut __EcsTrigger: ecs_entity_t = 4 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut FLECS__TEcsSystem: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsSystem_value as *const C2RustUnnamed_24 as *mut C2RustUnnamed_24
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsSystem_value: C2RustUnnamed_24 = {
	let mut init = C2RustUnnamed_24 {
		header: C2RustUnnamed_25 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
static mut __EcsSystem: ecs_entity_t = 5 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut FLECS__TEcsTickSource: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsTickSource_value as *const C2RustUnnamed_22 as *mut C2RustUnnamed_22
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsTickSource_value: C2RustUnnamed_22 = {
	let mut init = C2RustUnnamed_22 {
		header: C2RustUnnamed_23 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
static mut __EcsTickSource: ecs_entity_t = 7 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut __FLECS__TEcsSignatureExpr_value: C2RustUnnamed_20 = {
	let mut init = C2RustUnnamed_20 {
		header: C2RustUnnamed_21 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
#[no_mangle]
pub static mut FLECS__TEcsSignatureExpr: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsSignatureExpr_value as *const C2RustUnnamed_20 as *mut C2RustUnnamed_20
		as *mut ecs_vector_t
};
static mut __EcsSignatureExpr: ecs_entity_t = 8 as libc::c_int as ecs_entity_t;
static mut __EcsSignature: ecs_entity_t = 9 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut FLECS__TEcsSignature: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsSignature_value as *const C2RustUnnamed_18 as *mut C2RustUnnamed_18
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsSignature_value: C2RustUnnamed_18 = {
	let mut init = C2RustUnnamed_18 {
		header: C2RustUnnamed_19 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
static mut __EcsQuery: ecs_entity_t = 10 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut __FLECS__TEcsQuery_value: C2RustUnnamed_12 = {
	let mut init = C2RustUnnamed_12 {
		header: C2RustUnnamed_13 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
#[no_mangle]
pub static mut FLECS__TEcsQuery: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsQuery_value as *const C2RustUnnamed_12 as *mut C2RustUnnamed_12
		as *mut ecs_vector_t
};
static mut __EcsIterAction: ecs_entity_t = 11 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut FLECS__TEcsIterAction: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsIterAction_value as *const C2RustUnnamed_16 as *mut C2RustUnnamed_16
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsIterAction_value: C2RustUnnamed_16 = {
	let mut init = C2RustUnnamed_16 {
		header: C2RustUnnamed_17 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
static mut __EcsContext: ecs_entity_t = 12 as libc::c_int as ecs_entity_t;
#[no_mangle]
pub static mut FLECS__TEcsContext: *const ecs_vector_t = unsafe {
	&__FLECS__TEcsContext_value as *const C2RustUnnamed_14 as *mut C2RustUnnamed_14
		as *mut ecs_vector_t
};
#[no_mangle]
pub static mut __FLECS__TEcsContext_value: C2RustUnnamed_14 = {
	let mut init = C2RustUnnamed_14 {
		header: C2RustUnnamed_15 {
			vector: {
				let mut init = ecs_vector_t {
					count: 1 as libc::c_int,
					size: 1 as libc::c_int,
				};
				init
			},
		},
		array: [0; 1],
	};
	init
};
unsafe extern "C" fn get_in_component(
	mut component_map: *mut ecs_map_t,
	mut component: ecs_entity_t,
) -> *mut ecs_on_demand_in_t {
	let mut in_0: *mut ecs_on_demand_in_t = _ecs_map_get(
		component_map,
		::std::mem::size_of::<ecs_on_demand_in_t>() as libc::c_ulong as ecs_size_t,
		component,
	) as *mut ecs_on_demand_in_t;
	if in_0.is_null() {
		let mut in_value: ecs_on_demand_in_t = {
			let mut init = ecs_on_demand_in_t {
				count: 0 as libc::c_int,
				systems: 0 as *mut ecs_vector_t,
			};
			init
		};
		_ecs_map_set(
			component_map,
			::std::mem::size_of::<ecs_on_demand_in_t>() as libc::c_ulong as ecs_size_t,
			component,
			&mut in_value as *mut ecs_on_demand_in_t as *const libc::c_void,
		);
		in_0 = _ecs_map_get(
			component_map,
			::std::mem::size_of::<ecs_on_demand_in_t>() as libc::c_ulong as ecs_size_t,
			component,
		) as *mut ecs_on_demand_in_t
	}
	return in_0;
}
unsafe extern "C" fn activate_in_columns(
	mut world: *mut ecs_world_t,
	mut query: *mut ecs_query_t,
	mut component_map: *mut ecs_map_t,
	mut activate: bool,
) {
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*query).sig.columns);
	i = 0 as libc::c_int;
	while i < count {
		if (*columns.offset(i as isize)).inout_kind as libc::c_uint
			== EcsIn as libc::c_int as libc::c_uint
		{
			let mut in_0: *mut ecs_on_demand_in_t =
				get_in_component(component_map, (*columns.offset(i as isize)).is.component);
			(*in_0).count += if activate as libc::c_int != 0 {
				1 as libc::c_int
			} else {
				-(1 as libc::c_int)
			};
			/* If this is the first system that registers the in component, walk
			 * over all already registered systems to enable them */
			if !(*in_0).systems.is_null()
				&& (activate as libc::c_int != 0 && (*in_0).count == 1 as libc::c_int
					|| !activate && (*in_0).count == 0)
			{
				let mut out: *mut *mut ecs_on_demand_out_t = _ecs_vector_first(
					(*in_0).systems,
					::std::mem::size_of::<*mut ecs_on_demand_out_t>() as libc::c_ulong
						as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<*mut ecs_on_demand_out_t>()
						as libc::c_ulong as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<*mut ecs_on_demand_out_t>() as libc::c_ulong
							as int64_t
					} as int16_t,
				) as *mut *mut ecs_on_demand_out_t;
				let mut s: int32_t = 0;
				let mut in_count: int32_t = ecs_vector_count((*in_0).systems);
				s = 0 as libc::c_int;
				while s < in_count {
					/* Increase the count of the system with the out params */
					let ref mut fresh76 = (**out.offset(s as isize)).count;
					*fresh76 += if activate as libc::c_int != 0 {
						1 as libc::c_int
					} else {
						-(1 as libc::c_int)
					};
					/* If this is the first out column that is requested from
					 * the OnDemand system, enable it */
					if activate as libc::c_int != 0
						&& (**out.offset(s as isize)).count == 1 as libc::c_int
					{
						ecs_remove_entity(
							world,
							(**out.offset(s as isize)).system,
							(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
						);
					} else if !activate && (**out.offset(s as isize)).count == 0 {
						ecs_add_entity(
							world,
							(**out.offset(s as isize)).system,
							(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
						);
					}
					s += 1
				}
			}
		}
		i += 1
	}
}
unsafe extern "C" fn register_out_column(
	mut component_map: *mut ecs_map_t,
	mut component: ecs_entity_t,
	mut on_demand_out: *mut ecs_on_demand_out_t,
) {
	let mut in_0: *mut ecs_on_demand_in_t = get_in_component(component_map, component);
	(*on_demand_out).count += (*in_0).count;
	let mut elem: *mut *mut ecs_on_demand_out_t = _ecs_vector_add(
		&mut (*in_0).systems,
		::std::mem::size_of::<*mut ecs_on_demand_out_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_on_demand_out_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_on_demand_out_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut *mut ecs_on_demand_out_t;
	*elem = on_demand_out;
}
unsafe extern "C" fn register_out_columns(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut system_data: *mut EcsSystem,
) {
	let mut query: *mut ecs_query_t = (*system_data).query;
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	let mut i: int32_t = 0;
	let mut out_count: int32_t = 0 as libc::c_int;
	let mut count: int32_t = ecs_vector_count((*query).sig.columns);
	i = 0 as libc::c_int;
	while i < count {
		if (*columns.offset(i as isize)).inout_kind as libc::c_uint
			== EcsOut as libc::c_int as libc::c_uint
		{
			if (*system_data).on_demand.is_null() {
				(*system_data).on_demand =
					ecs_os_api.malloc_.expect("non-null function pointer")(::std::mem::size_of::<
						ecs_on_demand_out_t,
					>() as libc::c_ulong
						as ecs_size_t) as *mut ecs_on_demand_out_t;
				(*(*system_data).on_demand).system = system;
				(*(*system_data).on_demand).count = 0 as libc::c_int
			}
			/* If column operator is NOT and the inout kind is [out], the system
			 * explicitly states that it will create the component (it is not
			 * there, yet it is an out column). In this case it doesn't make
			 * sense to wait until [in] columns get activated (matched with
			 * entities) since the component is not there yet. Therefore add it
			 * to the on_enable_components list, so this system will be enabled
			 * when a [in] column is enabled, rather than activated */
			let mut component_map: *mut ecs_map_t = 0 as *mut ecs_map_t;
			if (*columns.offset(i as isize)).oper_kind as libc::c_uint
				== EcsOperNot as libc::c_int as libc::c_uint
			{
				component_map = (*world).on_enable_components
			} else {
				component_map = (*world).on_activate_components
			}
			register_out_column(
				component_map,
				(*columns.offset(i as isize)).is.component,
				(*system_data).on_demand,
			);
			out_count += 1
		}
		i += 1
	}
}
unsafe extern "C" fn invoke_status_action(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut system_data: *const EcsSystem,
	mut status: ecs_system_status_t,
) {
	let mut action: ecs_system_status_action_t = (*system_data).status_action;
	if action.is_some() {
		action.expect("non-null function pointer")(
			world,
			system,
			status,
			(*system_data).status_ctx,
		);
	};
}
/* Invoked when system becomes active / inactive */
/* Invoked when system becomes active or inactive */
#[no_mangle]
pub unsafe extern "C" fn ecs_system_activate(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut activate: bool,
	mut system_data: *const EcsSystem,
) {
	if activate {
		ecs_remove_entity(
			world,
			system,
			(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
		);
	}
	if system_data.is_null() {
		system_data =
			ecs_get_w_entity(world, system, 5 as libc::c_int as ecs_entity_t) as *const EcsSystem
	}
	if system_data.is_null() || (*system_data).query.is_null() {
		return;
	}
	/* If system contains in columns, signal that they are now in use */
	activate_in_columns(
		world,
		(*system_data).query,
		(*world).on_activate_components,
		activate,
	);
	/* Invoke system status action */
	invoke_status_action(
		world,
		system,
		system_data,
		if activate as libc::c_int != 0 {
			EcsSystemActivated as libc::c_int
		} else {
			EcsSystemDeactivated as libc::c_int
		} as ecs_system_status_t,
	);
}
/* Actually enable or disable system */
#[no_mangle]
pub unsafe extern "C" fn ecs_enable_system(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut system_data: *mut EcsSystem,
	mut enabled: bool,
) {
	let mut query: *mut ecs_query_t = (*system_data).query;
	if query.is_null() {
		return;
	}
	if ecs_vector_count((*query).tables) != 0 {
		/* Only (de)activate system if it has non-empty tables. */
		ecs_system_activate(world, system, enabled, system_data);
		system_data = ecs_get_mut_w_entity(
			world,
			system,
			5 as libc::c_int as ecs_entity_t,
			0 as *mut bool,
		) as *mut EcsSystem
	}
	/* Enable/disable systems that trigger on [in] enablement */
	activate_in_columns(world, query, (*world).on_enable_components, enabled);
	/* Invoke action for enable/disable status */
	invoke_status_action(
		world,
		system,
		system_data,
		if enabled as libc::c_int != 0 {
			EcsSystemEnabled as libc::c_int
		} else {
			EcsSystemDisabled as libc::c_int
		} as ecs_system_status_t,
	);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_init_system(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut action: ecs_iter_action_t,
	mut query: *mut ecs_query_t,
	mut ctx: *mut libc::c_void,
) {
	/* Add & initialize the EcsSystem component */
	let mut is_added: bool = 0 as libc::c_int != 0;
	let mut sptr: *mut EcsSystem = ecs_get_mut_w_entity(
		world,
		system,
		5 as libc::c_int as ecs_entity_t,
		&mut is_added,
	) as *mut EcsSystem;
	if is_added {
		memset(
			sptr as *mut libc::c_void,
			0 as libc::c_int,
			::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
		);
		(*sptr).query = query;
		(*sptr).entity = system;
		(*sptr).tick_source = 0 as libc::c_int as ecs_entity_t;
		(*sptr).time_spent = 0 as libc::c_int as libc::c_float
	}
	/* Sanity check to make sure creating the query didn't add any additional
	 * tags or components to the system */
	(*sptr).action = action;
	(*sptr).ctx = ctx;
	/* Only run this code when the system is created for the first time */
	if is_added {
		/* If tables have been matched with this system it is active, and we
		 * should activate the in-columns, if any. This will ensure that any
		 * OnDemand systems get enabled. */
		if ecs_vector_count((*query).tables) != 0 {
			ecs_system_activate(world, system, 1 as libc::c_int != 0, sptr);
		} else {
			/* If system isn't matched with any tables, mark it as inactive. This
			 * causes it to be ignored by the main loop. When the system matches
			 * with a table it will be activated. */
			ecs_add_entity(
				world,
				system,
				(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
			);
		}
		/* If system is enabled, trigger enable components */
		activate_in_columns(
			world,
			query,
			(*world).on_enable_components,
			1 as libc::c_int != 0,
		);
		/* Check if all non-table column constraints are met. If not, disable
		 * system (system will be enabled once constraints are met) */
		if !ecs_sig_check_constraints(world, &mut (*query).sig) {
			ecs_add_entity(
				world,
				system,
				(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
			);
		}
		/* If the query has a OnDemand system tag, register its [out] columns */
		if ecs_has_entity(
			world,
			system,
			(256 as libc::c_int + 6 as libc::c_int) as ecs_entity_t,
		) {
			register_out_columns(world, system, sptr);
			/* If there are no systems currently interested in any of the [out]
			 * columns of the on demand system, disable it */
			if (*(*sptr).on_demand).count == 0 {
				ecs_add_entity(
					world,
					system,
					(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
				);
			}
		}
		/* Check if system has out columns */
		let mut i: int32_t = 0;
		let mut count: int32_t = ecs_vector_count((*query).sig.columns);
		let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
			(*query).sig.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		i = 0 as libc::c_int;
		while i < count {
			if (*columns.offset(i as isize)).inout_kind as libc::c_uint
				!= EcsIn as libc::c_int as libc::c_uint
			{
				break;
			}
			i += 1
		}
	};
}
#[no_mangle]
pub unsafe extern "C" fn ecs_col_system_free(mut system_data: *mut EcsSystem) {
	ecs_query_free((*system_data).query);
}
/* * Get the parent of an entity.
 * Same as ecs_get_parent_w_entity but accepts a component typename.
 *
 * @param world The world.
 * @param entity The entity.
 * @param component A component that the parent must have.
 * @return The parent of the entity, 0 if no parent was found.
 */
/* * Enable or disable an entity.
 * This operation enables or disables an entity by adding or removing the
 * EcsDisabled tag. A disabled entity will not be matched with any systems,
 * unless the system explicitly specifies the EcsDisabled tag.
 *
 * @param world The world.
 * @param entity The entity to enable or disable.
 * @param enabled true to enable the entity, false to disable.
 */
/* -- Public API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_enable(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut enabled: bool,
) {
	let mut type_ptr: *const EcsType =
		ecs_get_w_entity(world, entity, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
	if !type_ptr.is_null() {
		/* If entity is a type, disable all entities in the type */
		let mut e_i: libc::c_int = 0;
		let mut e_count: libc::c_int = ecs_vector_count((*type_ptr).normalized);
		let mut e_array: *mut ecs_entity_t = _ecs_vector_first(
			(*type_ptr).normalized,
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_entity_t;
		e_i = 0 as libc::c_int;
		while e_i < e_count {
			let mut e: *mut ecs_entity_t = &mut *e_array.offset(e_i as isize) as *mut ecs_entity_t;
			ecs_enable(world, *e, enabled);
			e_i += 1
		}
	} else if enabled {
		ecs_remove_entity(
			world,
			entity,
			(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
		);
	} else {
		ecs_add_entity(
			world,
			entity,
			(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
		);
	};
}
/* * Set system status action.
 * The status action is invoked whenever a system is enabled or disabled. Note
 * that a system may be enabled but may not actually match any entities. In this
 * case the system is enabled but not _active_.
 *
 * In addition to communicating the enabled / disabled status, the action also
 * communicates changes in the activation status of the system. A system becomes
 * active when it has one or more matching entities, and becomes inactive when
 * it no longer matches any entities.
 *
 * A system switches between enabled and disabled when an application invokes the
 * ecs_enable operation with a state different from the state of the system, for
 * example the system is disabled, and ecs_enable is invoked with enabled: true.
 *
 * Additionally a system may switch between enabled and disabled when it is an
 * EcsOnDemand system, and interest is generated or lost for one of its [out]
 * columns.
 *
 * @param world The world.
 * @param system The system for which to set the action.
 * @param action The action.
 * @param ctx Context that will be passed to the action when invoked.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_system_status_action(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut action: ecs_system_status_action_t,
	mut ctx: *const libc::c_void,
) {
	let mut system_data: *mut EcsSystem = ecs_get_mut_w_entity(
		world,
		system,
		5 as libc::c_int as ecs_entity_t,
		0 as *mut bool,
	) as *mut EcsSystem;
	(*system_data).status_action = action;
	(*system_data).status_ctx = ctx as *mut libc::c_void;
	if !ecs_has_entity(
		world,
		system,
		(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
	) {
		/* If system is already enabled, generate enable status. The API
		 * should guarantee that it exactly matches enable-disable
		 * notifications and activate-deactivate notifications. */
		invoke_status_action(world, system, system_data, EcsSystemEnabled);
		/* If column system has active (non-empty) tables, also generate the
		 * activate status. */
		if ecs_vector_count((*(*system_data).query).tables) != 0 {
			invoke_status_action(world, system, system_data, EcsSystemActivated);
		}
	};
}
/* Internal function to run a system */
#[no_mangle]
pub unsafe extern "C" fn ecs_run_intern(
	mut world: *mut ecs_world_t,
	mut stage: *mut ecs_stage_t,
	mut system: ecs_entity_t,
	mut system_data: *mut EcsSystem,
	mut delta_time: libc::c_float,
	mut offset: int32_t,
	mut limit: int32_t,
	mut filter: *const ecs_filter_t,
	mut param: *mut libc::c_void,
	mut ran_by_app: bool,
) -> ecs_entity_t {
	if param.is_null() {
		param = (*system_data).ctx
	}
	let mut time_elapsed: libc::c_float = delta_time;
	let mut tick_source: ecs_entity_t = (*system_data).tick_source;
	if tick_source != 0 {
		let mut tick: *const EcsTickSource =
			ecs_get_w_entity(world, tick_source, 7 as libc::c_int as ecs_entity_t)
				as *const EcsTickSource;
		if !tick.is_null() {
			time_elapsed = (*tick).time_elapsed;
			/* If timer hasn't fired we shouldn't run the system */
			if !(*tick).tick {
				return 0 as libc::c_int as ecs_entity_t;
			}
		} else {
			/* If a timer has been set but the timer entity does not have the
			 * EcsTimer component, don't run the system. This can be the result
			 * of a single-shot timer that has fired already. Not resetting the
			 * timer field of the system will ensure that the system won't be
			 * ran after the timer has fired. */
			return 0 as libc::c_int as ecs_entity_t;
		}
	}
	let mut time_start: ecs_time_t = ecs_time_t { sec: 0, nanosec: 0 };
	let mut measure_time: bool = (*world).measure_system_time;
	if measure_time {
		ecs_os_api.get_time_.expect("non-null function pointer")(&mut time_start);
	}
	let mut defer: bool = 0 as libc::c_int != 0;
	if (*stage).defer == 0 {
		ecs_defer_begin((*stage).world);
		defer = 1 as libc::c_int != 0
	}
	/* Prepare the query iterator */
	let mut it: ecs_iter_t = ecs_query_iter_page((*system_data).query, offset, limit);
	it.world = (*stage).world;
	it.system = system;
	it.delta_time = delta_time;
	it.delta_system_time = time_elapsed;
	it.world_time = (*world).stats.world_time_total;
	it.frame_offset = offset;
	/* Set param if provided, otherwise use system context */
	if !param.is_null() {
		it.param = param
	} else {
		it.param = (*system_data).ctx
	}
	let mut action: ecs_iter_action_t = (*system_data).action;
	/* If no filter is provided, just iterate tables & invoke action */
	if ran_by_app as libc::c_int != 0 || world == (*stage).world {
		while ecs_query_next_w_filter(&mut it, filter) {
			action.expect("non-null function pointer")(&mut it);
		}
	} else {
		let mut thread: *mut ecs_thread_t = (*stage).world as *mut ecs_thread_t;
		let mut total: int32_t = ecs_vector_count((*world).workers);
		let mut current: int32_t = (*thread).index;
		while ecs_query_next_worker(&mut it, current, total) {
			action.expect("non-null function pointer")(&mut it);
		}
	}
	if defer {
		ecs_defer_end((*stage).world);
	}
	if measure_time {
		(*system_data).time_spent += ecs_time_measure(&mut time_start) as libc::c_float
	}
	(*system_data).invoke_count += 1;
	return it.interrupted_by;
}
/* * Run system with offset/limit and type filter.
 * This operation is the same as ecs_run, but filters the entities that will be
 * iterated by the system.
 *
 * Entities can be filtered in two ways. Offset and limit control the range of
 * entities that is iterated over. The range is applied to all entities matched
 * with the system, thus may cover multiple archetypes.
 *
 * The type filter controls which entity types the system will evaluate. Only
 * types that contain all components in the type filter will be iterated over. A
 * type filter is only evaluated once per table, which makes filtering cheap if
 * the number of entities is large and the number of tables is small, but not as
 * cheap as filtering in the system signature.
 *
 * @param world The world.
 * @param system The system to invoke.
 * @param delta_time: The time passed since the last system invocation.
 * @param filter A component or type to filter matched entities.
 * @param param A user-defined parameter to pass to the system.
 * @return handle to last evaluated entity if system was interrupted.
 */
/* -- Public API -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_run_w_filter(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut delta_time: libc::c_float,
	mut offset: int32_t,
	mut limit: int32_t,
	mut filter: *const ecs_filter_t,
	mut param: *mut libc::c_void,
) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut in_progress: bool = ecs_staging_begin(world);
	let mut system_data: *mut EcsSystem =
		ecs_get_w_entity(world, system, 5 as libc::c_int as ecs_entity_t) as *const EcsSystem
			as *mut EcsSystem;
	let mut interrupted_by: ecs_entity_t = ecs_run_intern(
		world,
		stage,
		system,
		system_data,
		delta_time,
		offset,
		limit,
		filter,
		param,
		1 as libc::c_int != 0,
	);
	/* If world wasn't in progress when we entered this function, we need to
	 * merge and reset the in_progress value */
	if !in_progress {
		ecs_staging_end(world);
	}
	return interrupted_by;
}
// //////////////////////////////////////////////////////////////////////////////
// // Systems API
// //////////////////////////////////////////////////////////////////////////////
/* * Declare a systen.
 * This macro declares a system with the specified function, kind and signature.
 * Systems are matched with entities that match the system signature. The system
 * signature is specified as a comma-separated list of column expressions, where
 * a column expression can be any of the following:
 *
 * - A simple component identifier ('Position')
 * - An OR expression ('Position | Velocity')
 * - An optional expression ('?Position')
 * - A NOT expression ('!Position')
 * - An OWNED expression ('OWNED:Position')
 * - A SHARED expression ('SHARED:Position')
 * - A PARENT expression ('PARENT:Position')
 * - A CASCADE expression ('CASCADE:Position')
 * - An entity expression ('MyEntity:Position')
 * - An empty expression (':Position')
 *
 * The systen kind specifies the phase in which the system is ran.
 *
 * Examples:
 * ECS_SYSTEM(world, Move, EcsOnUpdate, Position, Velocity, !AngularVelocity);
 * ECS_SYSTEM(world, Transform, EcsPostUpdate, PARENT:Transform, Transform);
 *
 * In these examples, 'Move' and 'Transform' must be valid identifiers to a C
 * function of the following signature:
 *
 * void Move(ecs_iter_t *it) { ... }
 *
 * Inside this function the system can access the data from the signature with
 * the ECS_COLUMN macro:
 *
 * ECS_COLUMN(it, Position, p, 1);
 * ECS_COLUMN(it, Velocity, v, 2);
 *
 * For more details on system signatures and phases see the Flecs manual.
 */
/* * Run a specific system manually.
 * This operation runs a single system manually. It is an efficient way to
 * invoke logic on a set of entities, as manual systems are only matched to
 * tables at creation time or after creation time, when a new table is created.
 *
 * Manual systems are useful to evaluate lists of prematched entities at
 * application defined times. Because none of the matching logic is evaluated
 * before the system is invoked, manual systems are much more efficient than
 * manually obtaining a list of entities and retrieving their components.
 *
 * An application may pass custom data to a system through the param parameter.
 * This data can be accessed by the system through the param member in the
 * ecs_iter_t value that is passed to the system callback.
 *
 * Any system may interrupt execution by setting the interrupted_by member in
 * the ecs_iter_t value. This is particularly useful for manual systems, where
 * the value of interrupted_by is returned by this operation. This, in
 * cominbation with the param argument lets applications use manual systems
 * to lookup entities: once the entity has been found its handle is passed to
 * interrupted_by, which is then subsequently returned.
 *
 * @param world The world.
 * @param system The system to run.
 * @param delta_time: The time passed since the last system invocation.
 * @param param A user-defined parameter to pass to the system.
 * @return handle to last evaluated entity if system was interrupted.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_run(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut delta_time: libc::c_float,
	mut param: *mut libc::c_void,
) -> ecs_entity_t {
	return ecs_run_w_filter(
		world,
		system,
		delta_time,
		0 as libc::c_int,
		0 as libc::c_int,
		0 as *const ecs_filter_t,
		param,
	);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_run_monitor(
	mut world: *mut ecs_world_t,
	mut monitor: *mut ecs_matched_query_t,
	mut components: *mut ecs_entities_t,
	mut row: int32_t,
	mut count: int32_t,
	mut entities: *mut ecs_entity_t,
) {
	let mut query: *mut ecs_query_t = (*monitor).query;
	let mut system: ecs_entity_t = (*query).system;
	let mut system_data: *const EcsSystem =
		ecs_get_w_entity(world, system, 5 as libc::c_int as ecs_entity_t) as *const EcsSystem;
	if (*system_data).action.is_none() {
		return;
	}
	let mut it: ecs_iter_t = {
		let mut init = ecs_iter_t {
			world: 0 as *mut ecs_world_t,
			system: 0,
			table: 0 as *mut ecs_iter_table_t,
			query: 0 as *mut ecs_query_t,
			table_count: 0,
			inactive_table_count: 0,
			column_count: 0,
			table_columns: 0 as *mut libc::c_void,
			entities: 0 as *mut ecs_entity_t,
			param: 0 as *mut libc::c_void,
			delta_time: 0.,
			delta_system_time: 0.,
			world_time: 0.,
			frame_offset: 0,
			table_offset: 0,
			offset: 0,
			count: 0,
			total_count: 0,
			triggered_by: 0 as *mut ecs_entities_t,
			interrupted_by: 0,
			iter: C2RustUnnamed {
				parent: ecs_scope_iter_t {
					filter: ecs_filter_t {
						include: 0 as *const ecs_vector_t,
						exclude: 0 as *const ecs_vector_t,
						include_kind: EcsMatchDefault,
						exclude_kind: EcsMatchDefault,
					},
					tables: 0 as *mut ecs_vector_t,
					index: 0,
					table: ecs_iter_table_t {
						columns: 0 as *mut int32_t,
						table: 0 as *mut ecs_table_t,
						data: 0 as *mut ecs_data_t,
						components: 0 as *mut ecs_entity_t,
						types: 0 as *mut ecs_type_t,
						references: 0 as *mut ecs_ref_t,
					},
				},
			},
		};
		init
	};
	ecs_query_set_iter(
		world,
		query,
		&mut it,
		(*monitor).matched_table_index,
		row,
		count,
	);
	it.world = world;
	it.triggered_by = components;
	it.param = (*system_data).ctx;
	if !entities.is_null() {
		it.entities = entities
	}
	it.system = system;
	(*system_data).action.expect("non-null function pointer")(&mut it);
}
/* Generic constructor to initialize a component to 0 */
unsafe extern "C" fn sys_ctor_init_zero(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut entities: *const ecs_entity_t,
	mut ptr: *mut libc::c_void,
	mut size: size_t,
	mut count: int32_t,
	mut ctx: *mut libc::c_void,
) {
	memset(ptr, 0 as libc::c_int, size.wrapping_mul(count as size_t));
}
/* System destructor */
unsafe extern "C" fn ecs_colsystem_dtor(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut entities: *const ecs_entity_t,
	mut ptr: *mut libc::c_void,
	mut size: size_t,
	mut count: int32_t,
	mut ctx: *mut libc::c_void,
) {
	let mut system_data: *mut EcsSystem = ptr as *mut EcsSystem;
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < count {
		let mut cur: *mut EcsSystem = &mut *system_data.offset(i as isize) as *mut EcsSystem;
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		/* Invoke Deactivated action for active systems */
		if !(*cur).query.is_null() && ecs_vector_count((*(*cur).query).tables) != 0 {
			invoke_status_action(world, e, ptr as *const EcsSystem, EcsSystemDeactivated);
		}
		/* Invoke Disabled action for enabled systems */
		if !ecs_has_entity(
			world,
			e,
			(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
		) && !ecs_has_entity(
			world,
			e,
			(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
		) {
			invoke_status_action(world, e, ptr as *const EcsSystem, EcsSystemDisabled);
		}
		ecs_os_api.free_.expect("non-null function pointer")((*cur).on_demand as *mut libc::c_void);
		i += 1
	}
}
/* Register a trigger for a component */
unsafe extern "C" fn trigger_find_or_create(
	mut triggers: *mut *mut ecs_vector_t,
	mut entity: ecs_entity_t,
) -> *mut EcsTrigger {
	let mut trigger_i: libc::c_int = 0;
	let mut trigger_count: libc::c_int = ecs_vector_count(*triggers);
	let mut trigger_array: *mut EcsTrigger = _ecs_vector_first(
		*triggers,
		::std::mem::size_of::<EcsTrigger>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut EcsTrigger;
	trigger_i = 0 as libc::c_int;
	while trigger_i < trigger_count {
		let mut trigger: *mut EcsTrigger =
			&mut *trigger_array.offset(trigger_i as isize) as *mut EcsTrigger;
		if (*trigger).self_0 == entity {
			return trigger;
		}
		trigger_i += 1
	}
	let mut result: *mut EcsTrigger = _ecs_vector_add(
		triggers,
		::std::mem::size_of::<EcsTrigger>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut EcsTrigger;
	return result;
}
unsafe extern "C" fn trigger_set(
	mut world: *mut ecs_world_t,
	mut entities: *const ecs_entity_t,
	mut ct: *mut EcsTrigger,
	mut count: int32_t,
) {
	let mut el: *mut EcsTrigger = 0 as *mut EcsTrigger;
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < count {
		let mut c: ecs_entity_t = (*ct.offset(i as isize)).component;
		let mut c_info: *mut ecs_c_info_t = ecs_get_or_create_c_info(world, c);
		match (*ct.offset(i as isize)).kind {
			265 => el = trigger_find_or_create(&mut (*c_info).on_add, *entities.offset(i as isize)),
			266 => {
				el = trigger_find_or_create(&mut (*c_info).on_remove, *entities.offset(i as isize))
			}
			_ => {
				_ecs_abort(
					2 as libc::c_int,
					0 as *const libc::c_char,
					b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
					32281 as libc::c_int,
				);
				abort();
			}
		}
		*el = *ct.offset(i as isize);
		(*el).self_0 = *entities.offset(i as isize);
		ecs_notify_tables(world, &mut {
			let mut init = ecs_table_event_t {
				kind: EcsTableComponentInfo,
				query: 0 as *mut ecs_query_t,
				matched_table_index: 0,
				component: c,
			};
			init
		});
		i += 1
	}
}
unsafe extern "C" fn OnSetTrigger(mut it: *mut ecs_iter_t) {
	let mut ct: *mut EcsTrigger = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTrigger>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsTrigger;
	trigger_set((*it).world, (*it).entities, ct, (*it).count);
}
unsafe extern "C" fn OnSetTriggerCtx(mut it: *mut ecs_iter_t) {
	let mut ct: *mut EcsTrigger = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsTrigger>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsTrigger;
	let mut ctx: *mut EcsContext = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsContext>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsContext;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let ref mut fresh77 = (*ct.offset(i as isize)).ctx;
		*fresh77 = (*ctx.offset(i as isize)).ctx as *mut libc::c_void;
		i += 1
	}
	trigger_set((*it).world, (*it).entities, ct, (*it).count);
}
/* System that registers component lifecycle callbacks */
unsafe extern "C" fn OnSetComponentLifecycle(mut it: *mut ecs_iter_t) {
	let mut cl: *mut EcsComponentLifecycle = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsComponentLifecycle>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsComponentLifecycle;
	let mut world: *mut ecs_world_t = (*it).world;
	let mut i: libc::c_int = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut e: ecs_entity_t = *(*it).entities.offset(i as isize);
		ecs_set_component_actions_w_entity(world, e, &mut *cl.offset(i as isize));
		i += 1
	}
}
/* Disable system when EcsDisabled is added */
unsafe extern "C" fn DisableSystem(mut it: *mut ecs_iter_t) {
	let mut system_data: *mut EcsSystem = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSystem;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_enable_system(
			(*it).world,
			*(*it).entities.offset(i as isize),
			&mut *system_data.offset(i as isize),
			0 as libc::c_int != 0,
		);
		i += 1
	}
}
/* Enable system when EcsDisabled is removed */
unsafe extern "C" fn EnableSystem(mut it: *mut ecs_iter_t) {
	let mut system_data: *mut EcsSystem = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSystem;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		ecs_enable_system(
			(*it).world,
			*(*it).entities.offset(i as isize),
			&mut *system_data.offset(i as isize),
			1 as libc::c_int != 0,
		);
		i += 1
	}
}
/* Parse a signature expression into the ecs_sig_t data structure */
unsafe extern "C" fn CreateSignature(mut it: *mut ecs_iter_t) {
	let mut world: *mut ecs_world_t = (*it).world;
	let mut entities: *mut ecs_entity_t = (*it).entities;
	let mut signature: *mut EcsSignatureExpr = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSignatureExpr>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSignatureExpr;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		let mut name: *const libc::c_char = ecs_get_name(world, e);
		/* Parse the signature and add the result to the entity */
		let mut sig: EcsSignature = {
			let mut init = EcsSignature {
				signature: {
					let mut init = ecs_sig_t {
						name: 0 as *const libc::c_char,
						expr: 0 as *mut libc::c_char,
						columns: 0 as *mut ecs_vector_t,
					};
					init
				},
			};
			init
		};
		ecs_sig_init(
			world,
			name,
			(*signature.offset(0 as libc::c_int as isize)).expr,
			&mut sig.signature,
		);
		ecs_set_ptr_w_entity(
			world,
			e,
			9 as libc::c_int as ecs_entity_t,
			::std::mem::size_of::<EcsSignature>() as libc::c_ulong,
			&mut sig as *mut EcsSignature as *const libc::c_void,
		);
		/* If sig has FromSystem columns, add components to the entity */
		let mut column_i: libc::c_int = 0;
		let mut column_count: libc::c_int = ecs_vector_count(sig.signature.columns);
		let mut column_array: *mut ecs_sig_column_t = _ecs_vector_first(
			sig.signature.columns,
			::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut ecs_sig_column_t;
		column_i = 0 as libc::c_int;
		while column_i < column_count {
			let mut column: *mut ecs_sig_column_t =
				&mut *column_array.offset(column_i as isize) as *mut ecs_sig_column_t;
			if (*column).from_kind as libc::c_uint == EcsFromSystem as libc::c_int as libc::c_uint {
				ecs_add_entity(world, e, (*column).is.component);
			}
			column_i += 1
		}
		i += 1
	}
}
/* Create a query from a signature */
unsafe extern "C" fn CreateQuery(mut it: *mut ecs_iter_t) {
	let mut world: *mut ecs_world_t = (*it).world;
	let mut entities: *mut ecs_entity_t = (*it).entities;
	let mut signature: *mut EcsSignature = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsSignature>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsSignature;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		if !ecs_has_type(world, e, FLECS__TEcsQuery) {
			let mut query: EcsQuery = {
				let mut init = EcsQuery {
					query: 0 as *mut ecs_query_t,
				};
				init
			};
			query.query =
				ecs_query_new_w_sig(world, e, &mut (*signature.offset(i as isize)).signature);
			ecs_set_ptr_w_entity(
				world,
				e,
				10 as libc::c_int as ecs_entity_t,
				::std::mem::size_of::<EcsQuery>() as libc::c_ulong,
				&mut query as *mut EcsQuery as *const libc::c_void,
			);
		}
		i += 1
	}
}
/* Create a system from a query and an action */
unsafe extern "C" fn CreateSystem(mut it: *mut ecs_iter_t) {
	let mut world: *mut ecs_world_t = (*it).world;
	let mut entities: *mut ecs_entity_t = (*it).entities;
	let mut query: *mut EcsQuery = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsQuery>() as libc::c_ulong,
		1 as libc::c_int,
	) as *mut EcsQuery;
	let mut action: *mut EcsIterAction = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsIterAction>() as libc::c_ulong,
		2 as libc::c_int,
	) as *mut EcsIterAction;
	let mut ctx: *mut EcsContext = ecs_column_w_size(
		it,
		::std::mem::size_of::<EcsContext>() as libc::c_ulong,
		3 as libc::c_int,
	) as *mut EcsContext;
	let mut i: int32_t = 0;
	i = 0 as libc::c_int;
	while i < (*it).count {
		let mut e: ecs_entity_t = *entities.offset(i as isize);
		let mut ctx_ptr: *mut libc::c_void = 0 as *mut libc::c_void;
		if !ctx.is_null() {
			ctx_ptr = (*ctx.offset(i as isize)).ctx as *mut libc::c_void
		}
		ecs_init_system(
			world,
			e,
			(*action.offset(i as isize)).action,
			(*query.offset(i as isize)).query,
			ctx_ptr,
		);
		i += 1
	}
}
unsafe extern "C" fn bootstrap_set_system(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
	mut action: ecs_iter_action_t,
) {
	let mut sig: ecs_sig_t = {
		let mut init = ecs_sig_t {
			name: 0 as *const libc::c_char,
			expr: 0 as *mut libc::c_char,
			columns: 0 as *mut ecs_vector_t,
		};
		init
	};
	let mut sys: ecs_entity_t = ecs_set_ptr_w_entity(
		world,
		0 as libc::c_int as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: name,
				symbol: 0 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		sys,
		(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
	);
	ecs_sig_init(world, name, expr, &mut sig);
	let mut query: *mut ecs_query_t = ecs_query_new_w_sig(world, sys, &mut sig);
	ecs_init_system(world, sys, action, query, 0 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_system(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut tag: ecs_entity_t,
	mut signature: *const libc::c_char,
	mut action: ecs_iter_action_t,
) -> ecs_entity_t {
	let mut result: ecs_entity_t = ecs_lookup_w_id(world, e, name);
	if result == 0 {
		result = ecs_new_entity(
			world,
			0 as libc::c_int as ecs_entity_t,
			name,
			0 as *const libc::c_char,
		)
	}
	if tag != 0 {
		ecs_add_entity(world, result, tag);
	}
	let mut added: bool = 0 as libc::c_int != 0;
	let mut expr: *mut EcsSignatureExpr =
		ecs_get_mut_w_entity(world, result, 8 as libc::c_int as ecs_entity_t, &mut added)
			as *mut EcsSignatureExpr;
	if added {
		(*expr).expr = signature
	} else if (*expr).expr.is_null() || signature.is_null() {
		if (*expr).expr != signature {
			if !(!(*expr).expr.is_null()
				&& strcmp((*expr).expr, b"0\x00" as *const u8 as *const libc::c_char) == 0)
			{
				if !signature.is_null()
					&& strcmp(signature, b"0\x00" as *const u8 as *const libc::c_char) == 0
				{
				} else {
					_ecs_abort(
						14 as libc::c_int,
						0 as *const libc::c_char,
						b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
						32491 as libc::c_int,
					);
					abort();
				}
			}
		}
	} else if strcmp((*expr).expr, signature) != 0 {
		_ecs_abort(
			14 as libc::c_int,
			name,
			b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
			32496 as libc::c_int,
		);
		abort();
	}
	ecs_modified_w_entity(world, result, 8 as libc::c_int as ecs_entity_t);
	ecs_set_ptr_w_entity(
		world,
		result,
		11 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsIterAction>() as libc::c_ulong,
		&mut {
			let mut init = EcsIterAction { action: action };
			init
		} as *mut EcsIterAction as *const libc::c_void,
	);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_trigger(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut kind: ecs_entity_t,
	mut component_name: *const libc::c_char,
	mut action: ecs_iter_action_t,
) -> ecs_entity_t {
	let mut component: ecs_entity_t = ecs_lookup_path_w_sep(
		world,
		0 as libc::c_int as ecs_entity_t,
		component_name,
		b".\x00" as *const u8 as *const libc::c_char,
		0 as *const libc::c_char,
	);
	let mut result: ecs_entity_t = ecs_lookup_w_id(world, e, name);
	if result == 0 {
		result = ecs_new_entity(
			world,
			0 as libc::c_int as ecs_entity_t,
			name,
			0 as *const libc::c_char,
		)
	}
	let mut added: bool = 0 as libc::c_int != 0;
	let mut trigger: *mut EcsTrigger =
		ecs_get_mut_w_entity(world, result, 4 as libc::c_int as ecs_entity_t, &mut added)
			as *mut EcsTrigger;
	if added {
		(*trigger).kind = kind;
		(*trigger).action = action;
		(*trigger).component = component;
		(*trigger).ctx = 0 as *mut libc::c_void
	} else {
		if (*trigger).kind != kind {
			_ecs_abort(
				14 as libc::c_int,
				name,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				32535 as libc::c_int,
			);
			abort();
		}
		if (*trigger).component != component {
			_ecs_abort(
				14 as libc::c_int,
				name,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				32539 as libc::c_int,
			);
			abort();
		}
		if (*trigger).action != action {
			(*trigger).action = action
		}
	}
	ecs_modified_w_entity(world, result, 4 as libc::c_int as ecs_entity_t);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn FlecsSystemImport(mut world: *mut ecs_world_t) {
	let mut FLECS__EFlecsSystem: ecs_entity_t = ecs_new_module(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"FlecsSystem\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<FlecsSystem>() as libc::c_ulong,
		::std::mem::align_of::<FlecsSystem>() as libc::c_ulong as int64_t as size_t,
	);
	let mut __FLECS__TFlecsSystem_value: C2RustUnnamed_28 = {
		let mut init = C2RustUnnamed_28 {
			header: C2RustUnnamed_29 {
				vector: {
					let mut init = ecs_vector_t {
						count: 1 as libc::c_int,
						size: 1 as libc::c_int,
					};
					init
				},
			},
			array: [0; 1],
		};
		init
	};
	let mut FLECS__TFlecsSystem: *const ecs_vector_t =
		&mut __FLECS__TFlecsSystem_value as *mut C2RustUnnamed_28 as *mut ecs_vector_t;
	memcpy(
		__FLECS__TFlecsSystem_value.array.as_mut_ptr() as *mut libc::c_void,
		&mut FLECS__EFlecsSystem as *mut ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	let mut handles: *mut FlecsSystem = ecs_get_mut_w_entity(
		world,
		FLECS__EFlecsSystem,
		FLECS__EFlecsSystem,
		0 as *mut bool,
	) as *mut FlecsSystem;
	ecs_set_name_prefix(world, b"Ecs\x00" as *const u8 as *const libc::c_char);
	ecs_new_component(
		world,
		2 as libc::c_int as ecs_entity_t,
		b"EcsComponentLifecycle\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsComponentLifecycle>() as libc::c_ulong,
		::std::mem::align_of::<EcsComponentLifecycle>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		4 as libc::c_int as ecs_entity_t,
		b"EcsTrigger\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsTrigger>() as libc::c_ulong,
		::std::mem::align_of::<EcsTrigger>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		5 as libc::c_int as ecs_entity_t,
		b"EcsSystem\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsSystem>() as libc::c_ulong,
		::std::mem::align_of::<EcsSystem>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		7 as libc::c_int as ecs_entity_t,
		b"EcsTickSource\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsTickSource>() as libc::c_ulong,
		::std::mem::align_of::<EcsTickSource>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		8 as libc::c_int as ecs_entity_t,
		b"EcsSignatureExpr\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsSignatureExpr>() as libc::c_ulong,
		::std::mem::align_of::<EcsSignatureExpr>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		9 as libc::c_int as ecs_entity_t,
		b"EcsSignature\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsSignature>() as libc::c_ulong,
		::std::mem::align_of::<EcsSignature>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		10 as libc::c_int as ecs_entity_t,
		b"EcsQuery\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsQuery>() as libc::c_ulong,
		::std::mem::align_of::<EcsQuery>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		11 as libc::c_int as ecs_entity_t,
		b"EcsIterAction\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsIterAction>() as libc::c_ulong,
		::std::mem::align_of::<EcsIterAction>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_new_component(
		world,
		12 as libc::c_int as ecs_entity_t,
		b"EcsContext\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsContext>() as libc::c_ulong,
		::std::mem::align_of::<EcsContext>() as libc::c_ulong as int64_t as size_t,
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 9 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnAdd\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnAdd\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 9 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 10 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnRemove\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnRemove\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 10 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnSet\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnSet\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 12 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsUnSet\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsUnSet\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 12 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsDisabledIntern\x00" as *const u8 as *const libc::c_char).offset(
					(strlen as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
						b"Ecs\x00" as *const u8 as *const libc::c_char,
					) as ecs_size_t as isize,
				) as *const libc::c_char,
				symbol: b"EcsDisabledIntern\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 4 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsInactive\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsInactive\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 5 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	/* Put EcsOnDemand and EcsMonitor in flecs.core so they can be looked up
	 * without using the flecs.systems prefix */
	let mut old_scope: ecs_entity_t = ecs_set_scope(
		world,
		(256 as libc::c_int + 24 as libc::c_int) as ecs_entity_t,
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 6 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsOnDemand\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsOnDemand\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 6 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 7 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsMonitor\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsMonitor\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 7 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_scope(world, old_scope);
	memcpy(
		__FLECS__TEcsComponentLifecycle_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsComponentLifecycle as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsTrigger_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsTrigger as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsSystem_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsSystem as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsTickSource_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsTickSource as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsSignatureExpr_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsSignatureExpr as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsSignature_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsSignature as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsQuery_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsQuery as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsIterAction_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsIterAction as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	memcpy(
		__FLECS__TEcsContext_value.array.as_mut_ptr() as *mut libc::c_void,
		&__EcsContext as *const ecs_entity_t as *const libc::c_void,
		(::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong)
			.wrapping_mul(1 as libc::c_int as libc::c_ulong),
	);
	/* Bootstrap ctor and dtor for EcsSystem */
	ecs_set_component_actions_w_entity(world, 5 as libc::c_int as ecs_entity_t, &mut {
		let mut init = EcsComponentLifecycle {
			ctor: Some(
				sys_ctor_init_zero
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			),
			dtor: Some(
				ecs_colsystem_dtor
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			),
			copy: None,
			move_0: None,
			ctx: 0 as *mut libc::c_void,
		};
		init
	});
	/* Create systems necessary to create systems */
	bootstrap_set_system(
		world,
		b"CreateSignature\x00" as *const u8 as *const libc::c_char,
		b"SignatureExpr\x00" as *const u8 as *const libc::c_char,
		Some(CreateSignature as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ()),
	);
	bootstrap_set_system(
		world,
		b"CreateQuery\x00" as *const u8 as *const libc::c_char,
		b"Signature, IterAction\x00" as *const u8 as *const libc::c_char,
		Some(CreateQuery as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ()),
	);
	bootstrap_set_system(
		world,
		b"CreateSystem\x00" as *const u8 as *const libc::c_char,
		b"Query, IterAction, ?Context\x00" as *const u8 as *const libc::c_char,
		Some(CreateSystem as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ()),
	);
	/* From here we can create systems */
	/* Register OnSet system for EcsComponentLifecycle */
	let mut FLECS__FOnSetComponentLifecycle: ecs_iter_action_t =
		Some(OnSetComponentLifecycle as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut OnSetComponentLifecycle_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"OnSetComponentLifecycle\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
		b"ComponentLifecycle, SYSTEM:Hidden\x00" as *const u8 as *const libc::c_char,
		FLECS__FOnSetComponentLifecycle,
	);
	/* Register OnSet system for triggers */
	let mut FLECS__FOnSetTrigger: ecs_iter_action_t =
		Some(OnSetTrigger as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut OnSetTrigger_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"OnSetTrigger\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
		b"Trigger, SYSTEM:Hidden\x00" as *const u8 as *const libc::c_char,
		FLECS__FOnSetTrigger,
	);
	/* System that sets ctx for a trigger */
	let mut FLECS__FOnSetTriggerCtx: ecs_iter_action_t =
		Some(OnSetTriggerCtx as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut OnSetTriggerCtx_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"OnSetTriggerCtx\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 11 as libc::c_int) as ecs_entity_t,
		b"Trigger, Context, SYSTEM:Hidden\x00" as *const u8 as *const libc::c_char,
		FLECS__FOnSetTriggerCtx,
	);
	/* Monitors that trigger when a system is enabled or disabled */
	let mut FLECS__FDisableSystem: ecs_iter_action_t =
		Some(DisableSystem as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut DisableSystem_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"DisableSystem\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 7 as libc::c_int) as ecs_entity_t,
		b"System, Disabled || DisabledIntern, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FDisableSystem,
	);
	let mut FLECS__FEnableSystem: ecs_iter_action_t =
		Some(EnableSystem as unsafe extern "C" fn(_: *mut ecs_iter_t) -> ());
	let mut EnableSystem_0: ecs_entity_t = ecs_new_system(
		world,
		0 as libc::c_int as ecs_entity_t,
		b"EnableSystem\x00" as *const u8 as *const libc::c_char,
		(256 as libc::c_int + 7 as libc::c_int) as ecs_entity_t,
		b"System, !Disabled, !DisabledIntern, SYSTEM:Hidden\x00" as *const u8
			as *const libc::c_char,
		FLECS__FEnableSystem,
	);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_system(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut dbg_out: *mut ecs_dbg_system_t,
) -> libc::c_int {
	let mut system_data: *const EcsSystem =
		ecs_get_w_entity(world, system, 5 as libc::c_int as ecs_entity_t) as *const EcsSystem;
	if system_data.is_null() {
		return -(1 as libc::c_int);
	}
	*dbg_out = {
		let mut init = ecs_dbg_system_t {
			system: system,
			entities_matched_count: 0,
			active_table_count: 0,
			inactive_table_count: 0,
			enabled: false,
			system_data: 0 as *mut libc::c_void,
		};
		init
	};
	(*dbg_out).active_table_count = ecs_vector_count((*(*system_data).query).tables);
	(*dbg_out).inactive_table_count = ecs_vector_count((*(*system_data).query).empty_tables);
	(*dbg_out).enabled = !ecs_has_entity(
		world,
		system,
		(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
	);
	let mut mt_i: libc::c_int = 0;
	let mut mt_count: libc::c_int = ecs_vector_count((*(*system_data).query).tables);
	let mut mt_array: *mut ecs_matched_table_t = _ecs_vector_first(
		(*(*system_data).query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_matched_table_t;
	mt_i = 0 as libc::c_int;
	while mt_i < mt_count {
		let mut mt: *mut ecs_matched_table_t =
			&mut *mt_array.offset(mt_i as isize) as *mut ecs_matched_table_t;
		let mut table: *mut ecs_table_t = (*mt).data.table;
		if !table.is_null() {
			(*dbg_out).entities_matched_count += ecs_table_count(table)
		}
		mt_i += 1
	}
	/* Inactive tables are inactive because they are empty, so no need to
	 * iterate them */
	return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_match_entity(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut system: ecs_entity_t,
	mut failure_info_out: *mut ecs_match_failure_t,
) -> bool {
	let mut dbg: ecs_dbg_entity_t = ecs_dbg_entity_t {
		entity: 0,
		table: 0 as *mut ecs_table_t,
		type_0: 0 as *const ecs_vector_t,
		row: 0,
		is_watched: false,
	};
	ecs_dbg_entity(world, entity, &mut dbg);
	let mut system_data: *const EcsSystem =
		ecs_get_w_entity(world, system, 5 as libc::c_int as ecs_entity_t) as *const EcsSystem;
	if system_data.is_null() {
		(*failure_info_out).reason = EcsMatchNotASystem;
		(*failure_info_out).column = -(1 as libc::c_int);
		return 0 as libc::c_int != 0;
	}
	return ecs_query_match(world, dbg.table, (*system_data).query, failure_info_out);
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_active_table(
	mut world: *mut ecs_world_t,
	mut dbg: *mut ecs_dbg_system_t,
	mut index: int32_t,
) -> *mut ecs_table_t {
	let mut system_data: *mut EcsSystem = (*dbg).system_data as *mut EcsSystem;
	let mut table: *mut ecs_matched_table_t = _ecs_vector_get(
		(*(*system_data).query).tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		index,
	) as *mut ecs_matched_table_t;
	if table.is_null() {
		return 0 as *mut ecs_table_t;
	}
	return (*table).data.table;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_inactive_table(
	mut world: *mut ecs_world_t,
	mut dbg: *mut ecs_dbg_system_t,
	mut index: int32_t,
) -> *mut ecs_table_t {
	let mut system_data: *mut EcsSystem = (*dbg).system_data as *mut EcsSystem;
	let mut table: *mut ecs_matched_table_t = _ecs_vector_get(
		(*(*system_data).query).empty_tables,
		::std::mem::size_of::<ecs_matched_table_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_matched_table_t>() as libc::c_ulong as int64_t
		} as int16_t,
		index,
	) as *mut ecs_matched_table_t;
	if table.is_null() {
		return 0 as *mut ecs_table_t;
	}
	return (*table).data.table;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_dbg_get_column_type(
	mut world: *mut ecs_world_t,
	mut system: ecs_entity_t,
	mut column_index: int32_t,
) -> ecs_type_t {
	let mut system_data: *const EcsSystem =
		ecs_get_w_entity(world, system, 5 as libc::c_int as ecs_entity_t) as *const EcsSystem;
	if system_data.is_null() {
		return 0 as ecs_type_t;
	}
	let mut columns: *mut ecs_sig_column_t = _ecs_vector_first(
		(*(*system_data).query).sig.columns,
		::std::mem::size_of::<ecs_sig_column_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_sig_column_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_sig_column_t;
	let mut count: int32_t = ecs_vector_count((*(*system_data).query).sig.columns);
	if count < column_index {
		return 0 as ecs_type_t;
	}
	let mut column: *mut ecs_sig_column_t =
		&mut *columns.offset((column_index - 1 as libc::c_int) as isize) as *mut ecs_sig_column_t;
	let mut oper_kind: ecs_sig_oper_kind_t = (*column).oper_kind;
	let mut result: ecs_type_t = 0 as *const ecs_vector_t;
	match oper_kind as libc::c_uint {
		1 => result = (*column).is.type_0 as ecs_type_t,
		_ => result = ecs_type_from_entity(world, (*column).is.component),
	}
	return result;
}
/* * Parse callback that adds type to type identifier for ecs_new_type */
unsafe extern "C" fn parse_type_action(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
	mut sig: *const libc::c_char,
	mut column: int64_t,
	mut from_kind: ecs_sig_from_kind_t,
	mut oper_kind: ecs_sig_oper_kind_t,
	mut inout_kind: ecs_sig_inout_kind_t,
	mut role: ecs_entity_t,
	mut entity_id: *const libc::c_char,
	mut source_id: *const libc::c_char,
	mut trait_id: *const libc::c_char,
	mut arg_name: *const libc::c_char,
	mut data: *mut libc::c_void,
) -> libc::c_int {
	let mut array: *mut *mut ecs_vector_t = data as *mut *mut ecs_vector_t;
	if !arg_name.is_null() {
		_ecs_parser_error(
			name,
			sig,
			column,
			b"column names not supported in type expression\x00" as *const u8
				as *const libc::c_char,
		);
		abort();
	}
	if strcmp(entity_id, b"0\x00" as *const u8 as *const libc::c_char) != 0 {
		let mut entity: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
		if from_kind as libc::c_uint != EcsFromOwned as libc::c_int as libc::c_uint {
			if name.is_null() {
				return -(1 as libc::c_int);
			}
			_ecs_parser_error(
				name,
				sig,
				column,
				b"source modifiers not supported for type expressions\x00" as *const u8
					as *const libc::c_char,
			);
			abort();
		}
		entity = ecs_lookup_path_w_sep(
			world,
			0 as libc::c_int as ecs_entity_t,
			entity_id,
			b".\x00" as *const u8 as *const libc::c_char,
			0 as *const libc::c_char,
		);
		if entity == 0 {
			if name.is_null() {
				return -(1 as libc::c_int);
			}
			_ecs_parser_error(
				name,
				sig,
				column,
				b"unresolved identifier \'%s\'\x00" as *const u8 as *const libc::c_char,
				entity_id,
			);
			abort();
		}
		if !trait_id.is_null() {
			let mut trait_0: ecs_entity_t = ecs_lookup_path_w_sep(
				world,
				0 as libc::c_int as ecs_entity_t,
				trait_id,
				b".\x00" as *const u8 as *const libc::c_char,
				0 as *const libc::c_char,
			);
			if trait_0 == 0 {
				_ecs_parser_error(
					name,
					sig,
					column,
					b"unresolved trait identifier \'%s\'\x00" as *const u8 as *const libc::c_char,
					trait_id,
				);
				abort();
			}
			entity =
				(trait_0 << 32 as libc::c_int).wrapping_add(entity as uint32_t as libc::c_ulong)
		}
		if oper_kind as libc::c_uint == EcsOperAnd as libc::c_int as libc::c_uint {
			let mut e_ptr: *mut ecs_entity_t = _ecs_vector_add(
				array,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			*e_ptr = entity | role
		} else {
			if name.is_null() {
				return -(1 as libc::c_int);
			}
			/* Only AND and OR operators are supported for type expressions */
			_ecs_parser_error(
				name,
				sig,
				column,
				b"invalid operator for type expression\x00" as *const u8 as *const libc::c_char,
			);
			abort();
		}
	}
	return 0 as libc::c_int;
}
unsafe extern "C" fn type_from_vec(
	mut world: *mut ecs_world_t,
	mut vec: *mut ecs_vector_t,
) -> EcsType {
	let mut result: EcsType = {
		let mut init = EcsType {
			type_0: 0 as ecs_type_t,
			normalized: 0 as ecs_type_t,
		};
		init
	};
	let mut array: *mut ecs_entity_t = _ecs_vector_first(
		vec,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_entity_t;
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count(vec);
	let mut entities: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: array,
			count: count,
		};
		init
	};
	let mut table: *mut ecs_table_t = ecs_table_find_or_create(world, &mut entities);
	if table.is_null() {
		return {
			let mut init = EcsType {
				type_0: 0 as ecs_type_t,
				normalized: 0 as *const ecs_vector_t,
			};
			init
		};
	}
	result.type_0 = (*table).type_0;
	/* Create normalized type. A normalized type resolves all elements with an
	 * AND flag and appends them to the resulting type, where the default type
	 * maintains the original type hierarchy. */
	let mut normalized: *mut ecs_vector_t = 0 as *mut ecs_vector_t;
	i = 0 as libc::c_int;
	while i < count {
		let mut e: ecs_entity_t = *array.offset(i as isize);
		if e & (0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			== (1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7b as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		{
			let mut entity: ecs_entity_t =
				e & !((0xff as libc::c_int as ecs_entity_t) << 56 as libc::c_int);
			let mut type_ptr: *const EcsType =
				ecs_get_w_entity(world, entity, 3 as libc::c_int as ecs_entity_t) as *const EcsType;
			let mut c_ptr_i: libc::c_int = 0;
			let mut c_ptr_count: libc::c_int = ecs_vector_count((*type_ptr).normalized);
			let mut c_ptr_array: *mut ecs_entity_t = _ecs_vector_first(
				(*type_ptr).normalized,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
			) as *mut ecs_entity_t;
			c_ptr_i = 0 as libc::c_int;
			while c_ptr_i < c_ptr_count {
				let mut c_ptr: *mut ecs_entity_t =
					&mut *c_ptr_array.offset(c_ptr_i as isize) as *mut ecs_entity_t;
				let mut el: *mut ecs_entity_t = _ecs_vector_add(
					&mut normalized,
					::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
					if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
						as int64_t
					{
						::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
							as libc::c_long
					} else {
						::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
					} as int16_t,
				) as *mut ecs_entity_t;
				*el = *c_ptr;
				c_ptr_i += 1
			}
		}
		i += 1
	}
	/* Only get normalized type if it's different from the type */
	if !normalized.is_null() {
		let mut normalized_array: ecs_entities_t = ecs_type_to_entities(normalized as ecs_type_t);
		let mut norm_table: *mut ecs_table_t = ecs_table_traverse_add(
			world,
			table,
			&mut normalized_array,
			0 as *mut ecs_entities_t,
		);
		result.normalized = (*norm_table).type_0;
		ecs_vector_free(normalized);
	} else {
		result.normalized = result.type_0
	}
	return result;
}
unsafe extern "C" fn type_from_expr(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
) -> EcsType {
	if !expr.is_null() {
		let mut vec: *mut ecs_vector_t = _ecs_vector_new(
			::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
			} as int16_t,
			1 as libc::c_int,
		);
		ecs_parse_expr(
			world,
			name,
			expr,
			Some(
				parse_type_action
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: *const libc::c_char,
						_: *const libc::c_char,
						_: int64_t,
						_: ecs_sig_from_kind_t,
						_: ecs_sig_oper_kind_t,
						_: ecs_sig_inout_kind_t,
						_: ecs_entity_t,
						_: *const libc::c_char,
						_: *const libc::c_char,
						_: *const libc::c_char,
						_: *const libc::c_char,
						_: *mut libc::c_void,
					) -> libc::c_int,
			),
			&mut vec as *mut *mut ecs_vector_t as *mut libc::c_void,
		);
		let mut result: EcsType = type_from_vec(world, vec);
		ecs_vector_free(vec);
		return result;
	} else {
		return {
			let mut init = EcsType {
				type_0: 0 as ecs_type_t,
				normalized: 0 as ecs_type_t,
			};
			init
		};
	};
}
/* Convert a symbol name to an entity name by removing the prefix */
/* If a name prefix is set with ecs_set_name_prefix, check if the entity name
 * has the prefix, and if so remove it. This enables using prefixed names in C
 * for components / systems while storing a canonical / language independent
 * identifier. */
#[no_mangle]
pub unsafe extern "C" fn ecs_name_from_symbol(
	mut world: *mut ecs_world_t,
	mut type_name: *const libc::c_char,
) -> *const libc::c_char {
	let mut prefix: *const libc::c_char = (*world).name_prefix;
	if !type_name.is_null() && !prefix.is_null() {
		let mut len: ecs_size_t = strlen(prefix) as ecs_size_t;
		if strncmp(type_name, prefix, len as size_t) == 0
			&& (*(*__ctype_b_loc()).offset(*type_name.offset(len as isize) as libc::c_int as isize)
				as libc::c_int & _ISupper as libc::c_int as libc::c_ushort as libc::c_int
				!= 0 || *type_name.offset(len as isize) as libc::c_int == '_' as i32)
		{
			if *type_name.offset(len as isize) as libc::c_int == '_' as i32 {
				return type_name
					.offset(len as isize)
					.offset(1 as libc::c_int as isize);
			} else {
				return type_name.offset(len as isize);
			}
		}
	}
	return type_name;
}
/* Set entity name with symbol */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_symbol(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
) {
	let mut e_name: *const libc::c_char = ecs_name_from_symbol(world, name);
	ecs_set_ptr_w_entity(
		world,
		e,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: e_name,
				symbol: name,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
}
/* Lookup an entity by name with a specific id */
#[no_mangle]
pub unsafe extern "C" fn ecs_lookup_w_id(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	if e != 0 {
		if !name.is_null() {
			/* Make sure name is the same */
			let mut existing: *const libc::c_char = ecs_get_name(world, e);
			if !existing.is_null() && strcmp(existing, name) != 0 {
				_ecs_abort(
					48 as libc::c_int,
					name,
					b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
					32951 as libc::c_int,
				);
				abort();
			}
			if existing.is_null() {
				ecs_set_symbol(world, e, name);
			}
		}
	}
	let mut result: ecs_entity_t = e;
	if result == 0 {
		if name.is_null() {
			/* If neither an id nor name is specified, return 0 */
			return 0 as libc::c_int as ecs_entity_t;
		}
		result = ecs_lookup(world, name)
	}
	return result;
}
/* -- Public functions -- */
#[no_mangle]
pub unsafe extern "C" fn ecs_type_from_str(
	mut world: *mut ecs_world_t,
	mut expr: *const libc::c_char,
) -> ecs_type_t {
	let mut type_0: EcsType = type_from_expr(world, 0 as *const libc::c_char, expr);
	return type_0.normalized;
}
// //////////////////////////////////////////////////////////////////////////////
// // Functions used in declarative (macro) API
// //////////////////////////////////////////////////////////////////////////////
#[no_mangle]
pub unsafe extern "C" fn ecs_new_entity(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
) -> ecs_entity_t {
	let mut result: ecs_entity_t = ecs_lookup_w_id(world, e, name);
	if result == 0 {
		result = ecs_new_w_type(world, 0 as ecs_type_t);
		ecs_set_symbol(world, result, name);
	}
	let mut type_0: EcsType = type_from_expr(world, name, expr);
	ecs_add_type(world, result, type_0.normalized);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_prefab(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
) -> ecs_entity_t {
	let mut result: ecs_entity_t = ecs_lookup_w_id(world, e, name);
	if result == 0 {
		result = ecs_new_w_type(world, 0 as ecs_type_t);
		ecs_set_symbol(world, result, name);
	}
	ecs_add_entity(
		world,
		result,
		(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t,
	);
	let mut type_0: EcsType = type_from_expr(world, name, expr);
	ecs_add_type(world, result, type_0.normalized);
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_component(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut size: size_t,
	mut alignment: size_t,
) -> ecs_entity_t {
	let mut in_progress: bool = (*world).in_progress;
	/* If world is in progress component may be registered, but only when not
	 * in multithreading mode. */
	if in_progress {
		/* Component creation should not be deferred */
		ecs_defer_end(world);
		(*world).in_progress = 0 as libc::c_int != 0
	}
	let mut result: ecs_entity_t = ecs_lookup_w_id(world, e, name);
	if result == 0 {
		result = ecs_new_component_id(world);
		ecs_set_symbol(world, result, name);
	}
	/* ecs_new_component_id does not add the scope, so add it explicitly */
	let mut scope: ecs_entity_t = (*world).stage.scope;
	if scope != 0 {
		ecs_add_entity(
			world,
			result,
			(1 as libc::c_int as uint64_t) << 63 as libc::c_int
				| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
				| scope,
		);
	}
	let mut added: bool = 0 as libc::c_int != 0;
	let mut ptr: *mut EcsComponent =
		ecs_get_mut_w_entity(world, result, 1 as libc::c_int as ecs_entity_t, &mut added)
			as *mut EcsComponent;
	if added {
		(*ptr).size = ecs_from_size_t(size);
		(*ptr).alignment = ecs_from_size_t(alignment)
	} else {
		if (*ptr).size != ecs_from_size_t(size) {
			_ecs_abort(
				15 as libc::c_int,
				name,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				33062 as libc::c_int,
			);
			abort();
		}
		if (*ptr).alignment != ecs_from_size_t(alignment) {
			_ecs_abort(
				15 as libc::c_int,
				name,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				33065 as libc::c_int,
			);
			abort();
		}
	}
	ecs_modified_w_entity(world, result, 1 as libc::c_int as ecs_entity_t);
	if e > (*world).stats.last_component_id && e < 256 as libc::c_int as libc::c_ulong {
		(*world).stats.last_component_id = e.wrapping_add(1 as libc::c_int as libc::c_ulong)
	}
	if in_progress {
		(*world).in_progress = 1 as libc::c_int != 0;
		ecs_defer_begin(world);
	}
	return result;
}
#[no_mangle]
pub unsafe extern "C" fn ecs_new_type(
	mut world: *mut ecs_world_t,
	mut e: ecs_entity_t,
	mut name: *const libc::c_char,
	mut expr: *const libc::c_char,
) -> ecs_entity_t {
	let mut result: ecs_entity_t = ecs_lookup_w_id(world, e, name);
	if result == 0 {
		result = ecs_new_entity(
			world,
			0 as libc::c_int as ecs_entity_t,
			name,
			0 as *const libc::c_char,
		)
	}
	let mut type_parsed: EcsType = type_from_expr(world, name, expr);
	let mut added: bool = 0 as libc::c_int != 0;
	let mut type_0: *mut EcsType =
		ecs_get_mut_w_entity(world, result, 3 as libc::c_int as ecs_entity_t, &mut added)
			as *mut EcsType;
	if added {
		(*type_0).type_0 = type_parsed.type_0;
		(*type_0).normalized = type_parsed.normalized
	} else {
		if (*type_0).type_0 != type_parsed.type_0 {
			_ecs_abort(
				14 as libc::c_int,
				name,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				33105 as libc::c_int,
			);
			abort();
		}
		if (*type_0).normalized != type_parsed.normalized {
			_ecs_abort(
				14 as libc::c_int,
				name,
				b"/tmp/.tmpQiV5EM/source.c\x00" as *const u8 as *const libc::c_char,
				33109 as libc::c_int,
			);
			abort();
		}
	}
	/* This will allow the type to show up in debug tools */
	_ecs_map_set(
		(*world).type_handles,
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		type_parsed.type_0 as uintptr_t,
		&mut result as *mut ecs_entity_t as *const libc::c_void,
	);
	return result;
}
/* Global type variables */
#[no_mangle]
pub static mut FLECS__TEcsComponent: ecs_type_t = 0 as *const ecs_vector_t;
#[no_mangle]
pub static mut FLECS__TEcsType: ecs_type_t = 0 as *const ecs_vector_t;
#[no_mangle]
pub static mut FLECS__TEcsName: ecs_type_t = 0 as *const ecs_vector_t;
#[no_mangle]
pub static mut FLECS__TEcsPrefab: ecs_type_t = 0 as *const ecs_vector_t;
/* Component lifecycle actions for EcsName */
#[no_mangle]
pub unsafe extern "C" fn EcsName_ctor(
	mut world: *mut ecs_world_t,
	mut component: ecs_entity_t,
	mut entity_ptr: *const ecs_entity_t,
	mut _ptr: *mut libc::c_void,
	mut _size: size_t,
	mut _count: int32_t,
	mut ctx: *mut libc::c_void,
) {
	let mut i: int32_t = 0 as libc::c_int;
	while i < _count {
		let mut entity: ecs_entity_t = *entity_ptr.offset(i as isize);
		let mut ptr: *mut EcsName = &mut *(_ptr as *mut EcsName).offset(i as isize) as *mut EcsName;
		(*ptr).value = 0 as *const libc::c_char;
		(*ptr).alloc_value = 0 as *mut libc::c_char;
		(*ptr).symbol = 0 as *const libc::c_char;
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn EcsName_dtor(
	mut _world: *mut ecs_world_t,
	mut _component: ecs_entity_t,
	mut entity_ptr: *const ecs_entity_t,
	mut _ptr: *mut libc::c_void,
	mut _size: size_t,
	mut _count: int32_t,
	mut _ctx: *mut libc::c_void,
) {
	let mut i: int32_t = 0 as libc::c_int;
	while i < _count {
		let mut ptr: *mut EcsName = &mut *(_ptr as *mut EcsName).offset(i as isize) as *mut EcsName;
		ecs_os_api.free_.expect("non-null function pointer")(
			(*ptr).alloc_value as *mut libc::c_void,
		);
		(*ptr).value = 0 as *const libc::c_char;
		(*ptr).alloc_value = 0 as *mut libc::c_char;
		(*ptr).symbol = 0 as *const libc::c_char;
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn EcsName_copy(
	mut _world: *mut ecs_world_t,
	mut _component: ecs_entity_t,
	mut dst_entities: *const ecs_entity_t,
	mut src_entities: *const ecs_entity_t,
	mut _dst_ptr: *mut libc::c_void,
	mut _src_ptr: *const libc::c_void,
	mut _size: size_t,
	mut _count: int32_t,
	mut _ctx: *mut libc::c_void,
) {
	let mut i: int32_t = 0 as libc::c_int;
	while i < _count {
		let mut _dst_entity: ecs_entity_t = *dst_entities.offset(i as isize);
		let mut _src_entity: ecs_entity_t = *src_entities.offset(i as isize);
		let mut dst: *mut EcsName =
			&mut *(_dst_ptr as *mut EcsName).offset(i as isize) as *mut EcsName;
		let mut src: *mut EcsName =
			&mut *(_src_ptr as *mut EcsName).offset(i as isize) as *mut EcsName;
		if !(*dst).alloc_value.is_null() {
			ecs_os_api.free_.expect("non-null function pointer")(
				(*dst).alloc_value as *mut libc::c_void,
			);
			(*dst).alloc_value = 0 as *mut libc::c_char
		}
		if !(*src).alloc_value.is_null() {
			(*dst).alloc_value =
				ecs_os_api.strdup_.expect("non-null function pointer")((*src).alloc_value);
			(*dst).value = (*dst).alloc_value
		} else {
			(*dst).alloc_value = 0 as *mut libc::c_char;
			(*dst).value = (*src).value
		}
		(*dst).symbol = (*src).symbol;
		i += 1
	}
}
#[no_mangle]
pub unsafe extern "C" fn EcsName_move(
	mut _world: *mut ecs_world_t,
	mut _component: ecs_entity_t,
	mut dst_entities: *const ecs_entity_t,
	mut src_entities: *const ecs_entity_t,
	mut _dst_ptr: *mut libc::c_void,
	mut _src_ptr: *mut libc::c_void,
	mut _size: size_t,
	mut _count: int32_t,
	mut _ctx: *mut libc::c_void,
) {
	let mut i: int32_t = 0 as libc::c_int;
	while i < _count {
		let mut _dst_entity: ecs_entity_t = *dst_entities.offset(i as isize);
		let mut _src_entity: ecs_entity_t = *src_entities.offset(i as isize);
		let mut dst: *mut EcsName =
			&mut *(_dst_ptr as *mut EcsName).offset(i as isize) as *mut EcsName;
		let mut src: *mut EcsName =
			&mut *(_src_ptr as *mut EcsName).offset(i as isize) as *mut EcsName;
		(*dst).value = (*src).value;
		(*dst).alloc_value = (*src).alloc_value;
		(*dst).symbol = (*src).symbol;
		(*src).value = 0 as *const libc::c_char;
		(*src).alloc_value = 0 as *mut libc::c_char;
		(*src).symbol = 0 as *const libc::c_char;
		i += 1
	}
}
/* -- Bootstrapping -- */
#[no_mangle]
pub unsafe extern "C" fn _bootstrap_component(
	mut world: *mut ecs_world_t,
	mut table: *mut ecs_table_t,
	mut entity: ecs_entity_t,
	mut id: *const libc::c_char,
	mut size: ecs_size_t,
	mut alignment: ecs_size_t,
) {
	let mut data: *mut ecs_data_t = ecs_table_get_or_create_data(table);
	let mut columns: *mut ecs_column_t = (*data).columns;
	/* Create record in entity index */
	let mut record: *mut ecs_record_t = _ecs_sparse_get_or_create(
		(*world).store.entity_index,
		::std::mem::size_of::<ecs_record_t>() as libc::c_ulong as ecs_size_t,
		entity,
	) as *mut ecs_record_t;
	(*record).table = table;
	/* Insert row into table to store EcsComponent itself */
	let mut index: int32_t =
		ecs_table_append(world, table, data, entity, record, 0 as libc::c_int != 0);
	(*record).row = index + 1 as libc::c_int;
	/* Set size and id */
	let mut c_info: *mut EcsComponent = _ecs_vector_first(
		(*columns.offset(0 as libc::c_int as isize)).data,
		::std::mem::size_of::<EcsComponent>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsComponent>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsComponent>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut EcsComponent; /* Skip prefix */
	let mut id_data: *mut EcsName = _ecs_vector_first(
		(*columns.offset(1 as libc::c_int as isize)).data,
		::std::mem::size_of::<EcsName>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut EcsName;
	(*c_info.offset(index as isize)).size = size;
	(*c_info.offset(index as isize)).alignment = alignment;
	let ref mut fresh78 = (*id_data.offset(index as isize)).value;
	*fresh78 = &*id.offset(
		(strlen as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
			b"Ecs\x00" as *const u8 as *const libc::c_char,
		) as ecs_size_t as isize,
	) as *const libc::c_char;
	let ref mut fresh79 = (*id_data.offset(index as isize)).symbol;
	*fresh79 = id;
	let ref mut fresh80 = (*id_data.offset(index as isize)).alloc_value;
	*fresh80 = 0 as *mut libc::c_char;
}
/* * Create type for component */
#[no_mangle]
pub unsafe extern "C" fn ecs_bootstrap_type(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
) -> ecs_type_t {
	let mut table: *mut ecs_table_t = ecs_table_find_or_create(world, &mut {
		let mut init = ecs_entities_t {
			array: [entity].as_mut_ptr(),
			count: 1 as libc::c_int,
		};
		init
	});
	return (*table).type_0;
}
/* * Bootstrap types for builtin components and tags */
unsafe extern "C" fn bootstrap_types(mut world: *mut ecs_world_t) {
	FLECS__TEcsComponent = ecs_bootstrap_type(world, 1 as libc::c_int as ecs_entity_t);
	FLECS__TEcsType = ecs_bootstrap_type(world, 3 as libc::c_int as ecs_entity_t);
	FLECS__TEcsName = ecs_bootstrap_type(world, 6 as libc::c_int as ecs_entity_t);
}
/* * Initialize component table. This table is manually constructed to bootstrap
 * flecs. After this function has been called, the builtin components can be
 * created.
 * The reason this table is constructed manually is because it requires the size
 * and alignment of the EcsComponent and EcsName components, which haven't been
 * created yet */
unsafe extern "C" fn bootstrap_component_table(mut world: *mut ecs_world_t) -> *mut ecs_table_t {
	let mut entities: [ecs_entity_t; 3] = [
		1 as libc::c_int as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| (256 as libc::c_int + 24 as libc::c_int) as libc::c_ulong,
	];
	let mut array: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: entities.as_mut_ptr(),
			count: 3 as libc::c_int,
		};
		init
	};
	let mut result: *mut ecs_table_t = ecs_table_find_or_create(world, &mut array);
	let mut data: *mut ecs_data_t = ecs_table_get_or_create_data(result);
	/* Preallocate enough memory for initial components */
	(*data).entities = _ecs_vector_new(
		::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
		} as int16_t,
		32 as libc::c_int,
	);
	(*data).record_ptrs = _ecs_vector_new(
		::std::mem::size_of::<*mut ecs_record_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<*mut ecs_record_t>() as libc::c_ulong as int64_t
		} as int16_t,
		32 as libc::c_int,
	);
	(*data).columns = ecs_os_api.malloc_.expect("non-null function pointer")(
		(::std::mem::size_of::<ecs_column_t>() as libc::c_ulong)
			.wrapping_mul(2 as libc::c_int as libc::c_ulong) as ecs_size_t,
	) as *mut ecs_column_t;
	let ref mut fresh81 = (*(*data).columns.offset(0 as libc::c_int as isize)).data;
	*fresh81 = _ecs_vector_new(
		::std::mem::size_of::<EcsComponent>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsComponent>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsComponent>() as libc::c_ulong as int64_t
		} as int16_t,
		32 as libc::c_int,
	);
	(*(*data).columns.offset(0 as libc::c_int as isize)).size =
		::std::mem::size_of::<EcsComponent>() as libc::c_ulong as int16_t;
	(*(*data).columns.offset(0 as libc::c_int as isize)).alignment =
		::std::mem::align_of::<EcsComponent>() as libc::c_ulong as int64_t as int16_t;
	let ref mut fresh82 = (*(*data).columns.offset(1 as libc::c_int as isize)).data;
	*fresh82 = _ecs_vector_new(
		::std::mem::size_of::<EcsName>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
		} as int16_t,
		32 as libc::c_int,
	);
	(*(*data).columns.offset(1 as libc::c_int as isize)).size =
		::std::mem::size_of::<EcsName>() as libc::c_ulong as int16_t;
	(*(*data).columns.offset(1 as libc::c_int as isize)).alignment =
		::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t as int16_t;
	(*result).column_count = 2 as libc::c_int;
	return result;
}
/* Lock world when in progress */
// //////////////////////////////////////////////////////////////////////////////
// // Core bootstrap functions
// //////////////////////////////////////////////////////////////////////////////
/* Bootstrap world */
#[no_mangle]
pub unsafe extern "C" fn ecs_bootstrap(mut world: *mut ecs_world_t) {
	FLECS__TEcsComponent = 0 as ecs_type_t;
	ecs_log_push();
	/* Create table that will hold components (EcsComponent, EcsName) */
	let mut table: *mut ecs_table_t = bootstrap_component_table(world);
	_bootstrap_component(
		world,
		table,
		1 as libc::c_int as ecs_entity_t,
		b"EcsComponent\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsComponent>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<EcsComponent>() as libc::c_ulong as int64_t as ecs_size_t,
	);
	_bootstrap_component(
		world,
		table,
		3 as libc::c_int as ecs_entity_t,
		b"EcsType\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsType>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<EcsType>() as libc::c_ulong as int64_t as ecs_size_t,
	);
	_bootstrap_component(
		world,
		table,
		6 as libc::c_int as ecs_entity_t,
		b"EcsName\x00" as *const u8 as *const libc::c_char,
		::std::mem::size_of::<EcsName>() as libc::c_ulong as ecs_size_t,
		::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t as ecs_size_t,
	);
	(*world).stats.last_component_id = 32 as libc::c_int as ecs_entity_t;
	(*world).stats.last_id = (256 as libc::c_int + 32 as libc::c_int) as ecs_entity_t;
	(*world).stats.min_id = 0 as libc::c_int as ecs_entity_t;
	(*world).stats.max_id = 0 as libc::c_int as ecs_entity_t;
	bootstrap_types(world);
	ecs_set_scope(
		world,
		(256 as libc::c_int + 24 as libc::c_int) as ecs_entity_t,
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 0 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsModule\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsModule\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 0 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsPrefab\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsPrefab\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 1 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 2 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsHidden\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsHidden\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 2 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: &*(b"EcsDisabled\x00" as *const u8 as *const libc::c_char).offset((strlen
					as unsafe extern "C" fn(_: *const libc::c_char) -> libc::c_ulong)(
					b"Ecs\x00" as *const u8 as *const libc::c_char,
				)
					as ecs_size_t
					as isize) as *const libc::c_char,
				symbol: b"EcsDisabled\x00" as *const u8 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 3 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| ecs_get_scope(world),
	);
	ecs_set_component_actions_w_entity(world, 6 as libc::c_int as ecs_entity_t, &mut {
		let mut init = EcsComponentLifecycle {
			ctor: Some(
				EcsName_ctor
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			),
			dtor: Some(
				EcsName_dtor
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			),
			copy: Some(
				EcsName_copy
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: *const libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			),
			move_0: Some(
				EcsName_move
					as unsafe extern "C" fn(
						_: *mut ecs_world_t,
						_: ecs_entity_t,
						_: *const ecs_entity_t,
						_: *const ecs_entity_t,
						_: *mut libc::c_void,
						_: *mut libc::c_void,
						_: size_t,
						_: int32_t,
						_: *mut libc::c_void,
					) -> (),
			),
			ctx: 0 as *mut libc::c_void,
		};
		init
	});
	/* Initialize scopes */
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 23 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: b"flecs\x00" as *const u8 as *const libc::c_char,
				symbol: 0 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 23 as libc::c_int) as ecs_entity_t,
		(256 as libc::c_int + 0 as libc::c_int) as ecs_entity_t,
	);
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 24 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: b"core\x00" as *const u8 as *const libc::c_char,
				symbol: 0 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 24 as libc::c_int) as ecs_entity_t,
		(256 as libc::c_int + 0 as libc::c_int) as ecs_entity_t,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 24 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| (256 as libc::c_int + 23 as libc::c_int) as libc::c_ulong,
	);
	/* Initialize EcsWorld */
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 25 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: b"World\x00" as *const u8 as *const libc::c_char,
				symbol: 0 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 25 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| (256 as libc::c_int + 24 as libc::c_int) as libc::c_ulong,
	);
	/* Initialize EcsSingleton */
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 26 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: b"$\x00" as *const u8 as *const libc::c_char,
				symbol: 0 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 26 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| (256 as libc::c_int + 24 as libc::c_int) as libc::c_ulong,
	);
	/* Initialize EcsWildcard */
	ecs_set_ptr_w_entity(
		world,
		(256 as libc::c_int + 27 as libc::c_int) as ecs_entity_t,
		6 as libc::c_int as ecs_entity_t,
		::std::mem::size_of::<EcsName>() as libc::c_ulong,
		&mut {
			let mut init = EcsName {
				value: b"*\x00" as *const u8 as *const libc::c_char,
				symbol: 0 as *const libc::c_char,
				alloc_value: 0 as *mut libc::c_char,
			};
			init
		} as *mut EcsName as *const libc::c_void,
	);
	ecs_add_entity(
		world,
		(256 as libc::c_int + 27 as libc::c_int) as ecs_entity_t,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
			| (256 as libc::c_int + 24 as libc::c_int) as libc::c_ulong,
	);
	ecs_set_scope(world, 0 as libc::c_int as ecs_entity_t);
	ecs_log_pop();
}
unsafe extern "C" fn path_append(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut child: ecs_entity_t,
	mut component: ecs_entity_t,
	mut sep: *const libc::c_char,
	mut prefix: *const libc::c_char,
	mut buf: *mut ecs_strbuf_t,
) -> bool {
	let mut type_0: ecs_type_t = ecs_get_type(world, child);
	let mut cur: ecs_entity_t = ecs_find_in_type(
		world,
		type_0,
		component,
		(1 as libc::c_int as uint64_t) << 63 as libc::c_int
			| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int,
	);
	if cur != 0 {
		if cur != parent && cur != (256 as libc::c_int + 24 as libc::c_int) as libc::c_ulong {
			path_append(world, parent, cur, component, sep, prefix, buf);
			ecs_strbuf_appendstr(buf, sep);
		}
	} else if !prefix.is_null() {
		ecs_strbuf_appendstr(buf, prefix);
	}
	let mut buff: [libc::c_char; 22] = [0; 22];
	let mut name: *const libc::c_char = ecs_get_name(world, child);
	if name.is_null() {
		sprintf(
			buff.as_mut_ptr(),
			b"%u\x00" as *const u8 as *const libc::c_char,
			child as uint32_t,
		);
		name = buff.as_mut_ptr()
	}
	ecs_strbuf_appendstr(buf, name);
	return cur != 0 as libc::c_int as libc::c_ulong;
}
unsafe extern "C" fn find_as_alias(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*world).aliases);
	let mut aliases: *mut ecs_alias_t = _ecs_vector_first(
		(*world).aliases,
		::std::mem::size_of::<ecs_alias_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_alias_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_alias_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_alias_t;
	i = 0 as libc::c_int;
	while i < count {
		if strcmp((*aliases.offset(i as isize)).name, name) == 0 {
			return (*aliases.offset(i as isize)).entity;
		}
		i += 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
/* * @} */
/* *
 * @defgroup paths Paths
 * @{
 */
/* * Get a path identifier for an entity.
 * This operation creates a path that contains the names of the entities from
 * the specified parent to the provided entity, separated by the provided
 * separator. If no parent is provided the path will be relative to the root. If
 * a prefix is provided, the path will be prefixed by the prefix.
 *
 * If the parent is equal to the provided child, the operation will return an
 * empty string. If a nonzero component is provided, the path will be created by
 * looking for parents with that component.
 *
 * The returned path should be freed by the application.
 *
 * @param world The world.
 * @param parent The entity from which to create the path.
 * @param child The entity to which to create the path.
 * @param component The component of the parent.
 * @return The relative entity path.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_path_w_sep(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut child: ecs_entity_t,
	mut component: ecs_entity_t,
	mut sep: *const libc::c_char,
	mut prefix: *const libc::c_char,
) -> *mut libc::c_char {
	let mut buf: ecs_strbuf_t = {
		let mut init = ecs_strbuf_t {
			buf: 0 as *mut libc::c_char,
			max: 0,
			size: 0,
			elementCount: 0,
			firstElement: ecs_strbuf_element_embedded {
				super_0: ecs_strbuf_element {
					buffer_embedded: false,
					pos: 0,
					buf: 0 as *mut libc::c_char,
					next: 0 as *mut ecs_strbuf_element,
				},
				buf: [0; 512],
			},
			current: 0 as *mut ecs_strbuf_element,
			list_stack: [ecs_strbuf_list_elem {
				count: 0,
				separator: 0 as *const libc::c_char,
			}; 32],
			list_sp: 0,
		};
		init
	};
	if parent != child {
		path_append(world, parent, child, component, sep, prefix, &mut buf);
	} else {
		ecs_strbuf_appendstr(&mut buf, b"\x00" as *const u8 as *const libc::c_char);
	}
	return ecs_strbuf_get(&mut buf);
}
unsafe extern "C" fn is_number(mut name: *const libc::c_char) -> bool {
	if *(*__ctype_b_loc()).offset(*name.offset(0 as libc::c_int as isize) as libc::c_int as isize)
		as libc::c_int
		& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
		== 0
	{
		return 0 as libc::c_int != 0;
	}
	let mut i: ecs_size_t = 0;
	let mut s: ecs_size_t = strlen(name) as ecs_size_t;
	i = 0 as libc::c_int;
	while i < s {
		if *(*__ctype_b_loc()).offset(*name.offset(i as isize) as libc::c_int as isize)
			as libc::c_int
			& _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
			== 0
		{
			break;
		}
		i += 1
	}
	return i == s;
}
unsafe extern "C" fn name_to_id(mut name: *const libc::c_char) -> ecs_entity_t {
	let mut result: libc::c_long = atol(name);
	return result as ecs_entity_t;
}
unsafe extern "C" fn find_child_in_table(
	mut table: *mut ecs_table_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	/* If table doesn't have EcsName, then don't bother */
	let mut name_index: int32_t =
		ecs_type_index_of((*table).type_0, 6 as libc::c_int as ecs_entity_t);
	if name_index == -(1 as libc::c_int) {
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut data: *mut ecs_data_t = ecs_table_get_data(table);
	if data.is_null() || (*data).columns.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut i: int32_t = 0;
	let mut count: int32_t = ecs_vector_count((*data).entities);
	if count == 0 {
		return 0 as libc::c_int as ecs_entity_t;
	}
	if is_number(name) {
		return name_to_id(name);
	}
	let mut column: *mut ecs_column_t =
		&mut *(*data).columns.offset(name_index as isize) as *mut ecs_column_t;
	let mut names: *mut EcsName = _ecs_vector_first(
		(*column).data,
		::std::mem::size_of::<EcsName>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<EcsName>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut EcsName;
	i = 0 as libc::c_int;
	while i < count {
		let mut cur_name: *const libc::c_char = (*names.offset(i as isize)).value;
		let mut cur_sym: *const libc::c_char = (*names.offset(i as isize)).symbol;
		if !cur_name.is_null() && strcmp(cur_name, name) == 0
			|| !cur_sym.is_null() && strcmp(cur_sym, name) == 0
		{
			return *(_ecs_vector_get(
				(*data).entities,
				::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
				if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
					as libc::c_long > ::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong
					as int64_t
				{
					::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
						as libc::c_long
				} else {
					::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
				} as int16_t,
				i,
			) as *mut ecs_entity_t);
		}
		i += 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
unsafe extern "C" fn find_child(
	mut world: *mut ecs_world_t,
	mut _parent: ecs_entity_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	let mut table_i: libc::c_int = 0;
	let mut table_count: libc::c_int = ecs_sparse_count((*world).store.tables);
	table_i = 0 as libc::c_int;
	while table_i < table_count {
		let mut table: *mut ecs_table_t = _ecs_sparse_get(
			(*world).store.tables,
			::std::mem::size_of::<ecs_table_t>() as libc::c_ulong as ecs_size_t,
			table_i,
		) as *mut ecs_table_t;
		let mut result: ecs_entity_t = find_child_in_table(table, name);
		if result != 0 {
			return result;
		}
		table_i += 1
	}
	return 0 as libc::c_int as ecs_entity_t;
}
/* * Lookup a child entity by name.
 * Returns an entity that matches the specified name. Only looks for entities in
 * the provided parent. If no parent is provided, look in the current scope (
 * root if no scope is provided).
 *
 * @param world The world.
 * @param name The entity name.
 * @return The entity with the specified name, or 0 if no entity was found.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_lookup_child(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	let mut result: ecs_entity_t = 0 as libc::c_int as ecs_entity_t;
	let mut child_tables: *mut ecs_vector_t =
		_ecs_map_get_ptr((*world).child_tables, parent) as *mut ecs_vector_t;
	if !child_tables.is_null() {
		let mut table_ptr_i: libc::c_int = 0;
		let mut table_ptr_count: libc::c_int = ecs_vector_count(child_tables);
		let mut table_ptr_array: *mut *mut ecs_table_t = _ecs_vector_first(
			child_tables,
			::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_table_t;
		table_ptr_i = 0 as libc::c_int;
		while table_ptr_i < table_ptr_count {
			let mut table_ptr: *mut *mut ecs_table_t =
				&mut *table_ptr_array.offset(table_ptr_i as isize) as *mut *mut ecs_table_t;
			let mut table: *mut ecs_table_t = *table_ptr;
			result = find_child_in_table(table, name);
			if result != 0 {
				return result;
			}
			table_ptr_i += 1
		}
	}
	return result;
}
/* * @} */
/* *
 * @defgroup lookup Lookups
 * @{
 */
/* * Lookup an entity by name.
 * Returns an entity that matches the specified name. Only looks for entities in
 * the current scope (root if no scope is provided).
 *
 * @param world The world.
 * @param name The entity name.
 * @return The entity with the specified name, or 0 if no entity was found.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_lookup(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	if name.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	if is_number(name) {
		return name_to_id(name);
	}
	let mut e: ecs_entity_t = find_as_alias(world, name);
	if e != 0 {
		return e;
	}
	return ecs_lookup_child(world, 0 as libc::c_int as ecs_entity_t, name);
}
/* * Lookup an entity by its symbol name.
 * This looks up an entity by the symbol name that was provided in EcsName. The
 * operation does not take into account scoping, which means it will search all
 * entities that have an EcsName.
 *
 * This operation can be useful to resolve, for example, a type by its C
 * identifier, which does not include the Flecs namespacing.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_lookup_symbol(
	mut world: *mut ecs_world_t,
	mut name: *const libc::c_char,
) -> ecs_entity_t {
	if name.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	if is_number(name) {
		return name_to_id(name);
	}
	let mut e: ecs_entity_t = find_as_alias(world, name);
	if e != 0 {
		return e;
	}
	return find_child(world, 0 as libc::c_int as ecs_entity_t, name);
}
unsafe extern "C" fn is_sep(
	mut ptr: *mut *const libc::c_char,
	mut sep: *const libc::c_char,
) -> bool {
	let mut len: ecs_size_t = strlen(sep) as ecs_size_t;
	if strncmp(*ptr, sep, len as size_t) == 0 {
		*ptr = (*ptr).offset((len - 1 as libc::c_int) as isize);
		return 1 as libc::c_int != 0;
	} else {
		return 0 as libc::c_int != 0;
	};
}
unsafe extern "C" fn path_elem(
	mut path: *const libc::c_char,
	mut buff: *mut libc::c_char,
	mut sep: *const libc::c_char,
) -> *const libc::c_char {
	let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
	let mut bptr: *mut libc::c_char = 0 as *mut libc::c_char;
	let mut ch: libc::c_char = 0;
	bptr = buff;
	ptr = path;
	loop {
		ch = *ptr;
		if !(ch != 0) {
			break;
		}
		if is_sep(&mut ptr, sep) {
			*bptr = '\u{0}' as i32 as libc::c_char;
			return ptr.offset(1 as libc::c_int as isize);
		} else {
			*bptr = ch;
			bptr = bptr.offset(1)
		}
		ptr = ptr.offset(1)
	}
	if bptr != buff {
		*bptr = '\u{0}' as i32 as libc::c_char;
		return ptr;
	} else {
		return 0 as *const libc::c_char;
	};
}
unsafe extern "C" fn get_parent_from_path(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut path_ptr: *mut *const libc::c_char,
	mut prefix: *const libc::c_char,
) -> ecs_entity_t {
	let mut start_from_root: bool = 0 as libc::c_int != 0;
	let mut path: *const libc::c_char = *path_ptr;
	if !prefix.is_null() {
		let mut len: ecs_size_t = strlen(prefix) as ecs_size_t;
		if strncmp(path, prefix, len as size_t) == 0 {
			path = path.offset(len as isize);
			parent = 0 as libc::c_int as ecs_entity_t;
			start_from_root = 1 as libc::c_int != 0
		}
	}
	if !start_from_root && parent == 0 {
		let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
		parent = (*stage).scope
	}
	*path_ptr = path;
	return parent;
}
/* * Lookup an entity from a path.
 * Lookup an entity from a provided path, relative to the provided parent. The
 * operation will use the provided separator to tokenize the path expression. If
 * the provided path contains the prefix, the search will start from the root.
 *
 * If the entity is not found in the provided parent, the operation will
 * continue to search in the parent of the parent, until the root is reached. If
 * the entity is still not found, the lookup will search in the flecs.core
 * scope. If the entity is not found there either, the function returns 0.
 *
 * @param world The world.
 * @param parent The entity from which to resolve the path.
 * @param path The path to resolve.
 * @param sep The path separator.
 * @param prefix The path prefix.
 * @return The entity if found, else 0.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_lookup_path_w_sep(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut path: *const libc::c_char,
	mut sep: *const libc::c_char,
	mut prefix: *const libc::c_char,
) -> ecs_entity_t {
	if path.is_null() {
		return 0 as libc::c_int as ecs_entity_t;
	}
	let mut e: ecs_entity_t = find_as_alias(world, path);
	if e != 0 {
		return e;
	}
	let mut buff: [libc::c_char; 64] = [0; 64];
	let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
	let mut cur: ecs_entity_t = 0;
	let mut core_searched: bool = 0 as libc::c_int != 0;
	if sep.is_null() {
		sep = b".\x00" as *const u8 as *const libc::c_char
	}
	parent = get_parent_from_path(world, parent, &mut path, prefix);
	loop {
		cur = parent;
		ptr = path;
		loop {
			ptr = path_elem(ptr, buff.as_mut_ptr(), sep);
			if ptr.is_null() {
				break;
			}
			cur = ecs_lookup_child(world, cur, buff.as_mut_ptr());
			if cur == 0 {
				break;
			}
		}
		if !(cur == 0) {
			break;
		}
		if core_searched {
			break;
		}
		if parent != 0 {
			parent = ecs_get_parent_w_entity(world, parent, 0 as libc::c_int as ecs_entity_t)
		} else {
			parent = (256 as libc::c_int + 24 as libc::c_int) as ecs_entity_t;
			core_searched = 1 as libc::c_int != 0
		}
	}
	return cur;
}
/* * Set the current scope.
 * This operation sets the scope of the current stage to the provided entity.
 * As a result new entities will be created in this scope, and lookups will be
 * relative to the provided scope.
 *
 * It is considered good practice to restore the scope to the old value.
 *
 * @param world The world.
 * @param scope The entity to use as scope.
 * @return The previous scope.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_scope(
	mut world: *mut ecs_world_t,
	mut scope: ecs_entity_t,
) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	let mut e: ecs_entity_t = (1 as libc::c_int as uint64_t) << 63 as libc::c_int
		| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
		| scope;
	let mut to_add: ecs_entities_t = {
		let mut init = ecs_entities_t {
			array: &mut e,
			count: 1 as libc::c_int,
		};
		init
	};
	let mut cur: ecs_entity_t = (*stage).scope;
	(*stage).scope = scope;
	if scope != 0 {
		(*stage).scope_table = ecs_table_traverse_add(
			world,
			&mut (*world).store.root,
			&mut to_add,
			0 as *mut ecs_entities_t,
		)
	} else {
		(*stage).scope_table = &mut (*world).store.root
	}
	return cur;
}
/* * Get the current scope.
 * Get the scope set by ecs_set_scope. If no scope is set, this operation will
 * return 0.
 *
 * @param world The world.
 * @return The current scope.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_scope(mut world: *mut ecs_world_t) -> ecs_entity_t {
	let mut stage: *mut ecs_stage_t = ecs_get_stage(&mut world);
	return (*stage).scope;
}
/* * Add specified path to entity.
 * Same as ecs_add_from_path_w_sep, but with defaults for sep and prefix.
 *
 * @param world The world.
 * @param entity The entity to which to add the path.
 * @param parent The entity relative to which the entity should be created.
 * @param path The path to create the entity for.
 * @return The entity.
 */
/* * Add specified path to entity.
 * Same as ecs_add_from_path, but entity will be created from the current scope,
 * or root scope if no scope is set.
 *
 * @param world The world.
 * @param entity The entity to which to add the path.
 * @param path The path to create the entity for.
 * @return The entity.
 */
/* * @} */
/* *
 * @defgroup scopes Scopes
 * @{
 */
/* * Does entity have children.
 *
 * @param world The world
 * @param entity The entity
 * @return True if the entity has children, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_get_child_count(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
) -> int32_t {
	let mut tables: *mut ecs_vector_t =
		_ecs_map_get_ptr((*world).child_tables, entity) as *mut ecs_vector_t;
	if tables.is_null() {
		return 0 as libc::c_int;
	} else {
		let mut count: int32_t = 0 as libc::c_int;
		let mut table_ptr_i: libc::c_int = 0;
		let mut table_ptr_count: libc::c_int = ecs_vector_count(tables);
		let mut table_ptr_array: *mut *mut ecs_table_t = _ecs_vector_first(
			tables,
			::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
		) as *mut *mut ecs_table_t;
		table_ptr_i = 0 as libc::c_int;
		while table_ptr_i < table_ptr_count {
			let mut table_ptr: *mut *mut ecs_table_t =
				&mut *table_ptr_array.offset(table_ptr_i as isize) as *mut *mut ecs_table_t;
			let mut table: *mut ecs_table_t = *table_ptr;
			count += ecs_table_count(table);
			table_ptr_i += 1
		}
		return count;
	};
}
/* * Return a scope iterator.
 * A scope iterator iterates over all the child entities of the specified
 * parent.
 *
 * @param world The world.
 * @param parent The parent entity for which to iterate the children.
 * @return The iterator.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_scope_iter(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
) -> ecs_iter_t {
	let mut iter: ecs_scope_iter_t = {
		let mut init = ecs_scope_iter_t {
			filter: ecs_filter_t {
				include: 0 as *const ecs_vector_t,
				exclude: 0 as *const ecs_vector_t,
				include_kind: EcsMatchDefault,
				exclude_kind: EcsMatchDefault,
			},
			tables: _ecs_map_get_ptr((*world).child_tables, parent) as *mut ecs_vector_t,
			index: 0 as libc::c_int,
			table: ecs_iter_table_t {
				columns: 0 as *mut int32_t,
				table: 0 as *mut ecs_table_t,
				data: 0 as *mut ecs_data_t,
				components: 0 as *mut ecs_entity_t,
				types: 0 as *mut ecs_type_t,
				references: 0 as *mut ecs_ref_t,
			},
		};
		init
	};
	return {
		let mut init = ecs_iter_t {
			world: world,
			system: 0,
			table: 0 as *mut ecs_iter_table_t,
			query: 0 as *mut ecs_query_t,
			table_count: 0,
			inactive_table_count: 0,
			column_count: 0,
			table_columns: 0 as *mut libc::c_void,
			entities: 0 as *mut ecs_entity_t,
			param: 0 as *mut libc::c_void,
			delta_time: 0.,
			delta_system_time: 0.,
			world_time: 0.,
			frame_offset: 0,
			table_offset: 0,
			offset: 0,
			count: 0,
			total_count: 0,
			triggered_by: 0 as *mut ecs_entities_t,
			interrupted_by: 0,
			iter: C2RustUnnamed { parent: iter },
		};
		init
	};
}
/* * Return a filtered scope iterator.
 * Same as ecs_scope_iter, but results will be filtered.
 *
 * @param world The world.
 * @param parent The parent entity for which to iterate the children.
 * @return The iterator.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_scope_iter_w_filter(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut filter: *mut ecs_filter_t,
) -> ecs_iter_t {
	let mut iter: ecs_scope_iter_t = {
		let mut init = ecs_scope_iter_t {
			filter: *filter,
			tables: _ecs_map_get_ptr((*world).child_tables, parent) as *mut ecs_vector_t,
			index: 0 as libc::c_int,
			table: ecs_iter_table_t {
				columns: 0 as *mut int32_t,
				table: 0 as *mut ecs_table_t,
				data: 0 as *mut ecs_data_t,
				components: 0 as *mut ecs_entity_t,
				types: 0 as *mut ecs_type_t,
				references: 0 as *mut ecs_ref_t,
			},
		};
		init
	};
	return {
		let mut init = ecs_iter_t {
			world: world,
			system: 0,
			table: 0 as *mut ecs_iter_table_t,
			query: 0 as *mut ecs_query_t,
			table_count: ecs_vector_count(iter.tables),
			inactive_table_count: 0,
			column_count: 0,
			table_columns: 0 as *mut libc::c_void,
			entities: 0 as *mut ecs_entity_t,
			param: 0 as *mut libc::c_void,
			delta_time: 0.,
			delta_system_time: 0.,
			world_time: 0.,
			frame_offset: 0,
			table_offset: 0,
			offset: 0,
			count: 0,
			total_count: 0,
			triggered_by: 0 as *mut ecs_entities_t,
			interrupted_by: 0,
			iter: C2RustUnnamed { parent: iter },
		};
		init
	};
}
/* * Progress the scope iterator.
 * This operation progresses the scope iterator to the next table. The iterator
 * must have been initialized with `ecs_scope_iter`. This operation must be
 * invoked at least once before interpreting the contents of the iterator.
 *
 * @param it The iterator
 * @return True if more data is available, false if not.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_scope_next(mut it: *mut ecs_iter_t) -> bool {
	let mut iter: *mut ecs_scope_iter_t = &mut (*it).iter.parent;
	let mut tables: *mut ecs_vector_t = (*iter).tables;
	let mut filter: ecs_filter_t = (*iter).filter;
	let mut count: int32_t = ecs_vector_count(tables);
	let mut i: int32_t = 0;
	let mut current_block_10: u64;
	i = (*iter).index;
	while i < count {
		let mut table: *mut ecs_table_t = *(_ecs_vector_get(
			tables,
			::std::mem::size_of::<*mut ecs_table_t>() as libc::c_ulong as ecs_size_t,
			if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
				> ::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			{
				::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			} else {
				::std::mem::align_of::<*mut ecs_table_t>() as libc::c_ulong as int64_t
			} as int16_t,
			i,
		) as *mut *mut ecs_table_t);
		let mut data: *mut ecs_data_t = ecs_table_get_data(table);
		if !data.is_null() {
			(*it).count = ecs_table_count(table);
			if !((*it).count == 0) {
				if !filter.include.is_null() || !filter.exclude.is_null() {
					if !ecs_table_match_filter((*it).world, table, &mut filter) {
						current_block_10 = 4644295000439058019;
					} else {
						current_block_10 = 9606288038608642794;
					}
				} else {
					current_block_10 = 9606288038608642794;
				}
				match current_block_10 {
					4644295000439058019 => {}
					_ => {
						(*iter).table.table = table;
						(*it).table = &mut (*iter).table;
						(*it).table_columns = (*data).columns as *mut libc::c_void;
						(*it).count = ecs_table_count(table);
						(*it).entities = _ecs_vector_first(
							(*data).entities,
							::std::mem::size_of::<ecs_entity_t>() as libc::c_ulong as ecs_size_t,
							if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
								as libc::c_long > ::std::mem::align_of::<ecs_entity_t>()
								as libc::c_ulong as int64_t
							{
								::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t
									as libc::c_long
							} else {
								::std::mem::align_of::<ecs_entity_t>() as libc::c_ulong as int64_t
							} as int16_t,
						) as *mut ecs_entity_t;
						(*iter).index = i + 1 as libc::c_int;
						return 1 as libc::c_int != 0;
					}
				}
			}
		}
		i += 1
	}
	return 0 as libc::c_int != 0;
}
/* * Set a name prefix for newly created entities.
 * This is a utility that lets C modules use prefixed names for C types and
 * C functions, while using names for the entity names that do not have the
 * prefix. The name prefix is currently only used by ECS_COMPONENT.
 *
 * @param world The world.
 * @param prefix The name prefix to use.
 * @return The previous prefix.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_set_name_prefix(
	mut world: *mut ecs_world_t,
	mut prefix: *const libc::c_char,
) -> *const libc::c_char {
	let mut old_prefix: *const libc::c_char = (*world).name_prefix;
	(*world).name_prefix = prefix;
	return old_prefix;
}
/* * Add specified path to entity.
 * This operation is similar to ecs_new_from_path, but will instead add the path
 * to an existing entity.
 *
 * If an entity already exists for the path, it will be returned instead.
 *
 * @param world The world.
 * @param entity The entity to which to add the path.
 * @param parent The entity relative to which the entity should be created.
 * @param path The path to create the entity for.
 * @param sep The separator used in the path.
 * @param prefix The prefix used in the path.
 * @return The entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_add_path_w_sep(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut parent: ecs_entity_t,
	mut path: *const libc::c_char,
	mut sep: *const libc::c_char,
	mut prefix: *const libc::c_char,
) -> ecs_entity_t {
	if path.is_null() {
		if entity == 0 {
			entity = ecs_new_id(world)
		}
		if parent != 0 {
			ecs_add_entity(
				world,
				entity,
				(1 as libc::c_int as uint64_t) << 63 as libc::c_int
					| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
					| entity,
			);
		}
		return entity;
	}
	let mut buff: [libc::c_char; 64] = [0; 64];
	let mut ptr: *const libc::c_char = path;
	parent = get_parent_from_path(world, parent, &mut path, prefix);
	let mut cur: ecs_entity_t = parent;
	loop {
		ptr = path_elem(ptr, buff.as_mut_ptr(), sep);
		if ptr.is_null() {
			break;
		}
		let mut e: ecs_entity_t = ecs_lookup_child(world, cur, buff.as_mut_ptr());
		if e == 0 {
			let mut name: *mut libc::c_char =
				ecs_os_api.strdup_.expect("non-null function pointer")(buff.as_mut_ptr());
			/* If this is the last entity in the path, use the provided id */
			if entity != 0 && path_elem(ptr, buff.as_mut_ptr(), sep).is_null() {
				e = entity
			}
			e = ecs_set_ptr_w_entity(
				world,
				e,
				6 as libc::c_int as ecs_entity_t,
				::std::mem::size_of::<EcsName>() as libc::c_ulong,
				&mut {
					let mut init = EcsName {
						value: name,
						symbol: 0 as *const libc::c_char,
						alloc_value: name,
					};
					init
				} as *mut EcsName as *const libc::c_void,
			);
			ecs_os_api.free_.expect("non-null function pointer")(name as *mut libc::c_void);
			if cur != 0 {
				ecs_add_entity(
					world,
					e,
					(1 as libc::c_int as uint64_t) << 63 as libc::c_int
						| (0x7d as libc::c_int as ecs_entity_t) << 56 as libc::c_int
						| cur,
				);
			}
		}
		cur = e
	}
	return cur;
}
/* * Find or create entity from path.
 * This operation will find or create an entity from a path, and will create any
 * intermediate entities if required. If the entity already exists, no entities
 * will be created.
 *
 * If the path starts with the prefix, then the entity will be created from the
 * root scope.
 *
 * @param world The world.
 * @param parent The entity relative to which the entity should be created.
 * @param path The path to create the entity for.
 * @param sep The separator used in the path.
 * @param prefix The prefix used in the path.
 * @return The entity.
 */
#[no_mangle]
pub unsafe extern "C" fn ecs_new_from_path_w_sep(
	mut world: *mut ecs_world_t,
	mut parent: ecs_entity_t,
	mut path: *const libc::c_char,
	mut sep: *const libc::c_char,
	mut prefix: *const libc::c_char,
) -> ecs_entity_t {
	return ecs_add_path_w_sep(
		world,
		0 as libc::c_int as ecs_entity_t,
		parent,
		path,
		sep,
		prefix,
	);
}
/* Add alias for entity to global scope */
#[no_mangle]
pub unsafe extern "C" fn ecs_use(
	mut world: *mut ecs_world_t,
	mut entity: ecs_entity_t,
	mut name: *const libc::c_char,
) {
	let mut al: *mut ecs_alias_t = _ecs_vector_add(
		&mut (*world).aliases,
		::std::mem::size_of::<ecs_alias_t>() as libc::c_ulong as ecs_size_t,
		if ::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
			> ::std::mem::align_of::<ecs_alias_t>() as libc::c_ulong as int64_t
		{
			::std::mem::size_of::<ecs_vector_t>() as libc::c_ulong as ecs_size_t as libc::c_long
		} else {
			::std::mem::align_of::<ecs_alias_t>() as libc::c_ulong as int64_t
		} as int16_t,
	) as *mut ecs_alias_t;
	(*al).name = ecs_os_api.strdup_.expect("non-null function pointer")(name);
	(*al).entity = entity;
}
